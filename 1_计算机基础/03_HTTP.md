# TCP/IP协议族

通常使用的网络（包括互联网） 是在 TCP/IP 协议族的基础上运作的。 而 HTTP 属于它内部的一个子集。  

计算机与网络设备想要相互通信，双方必须基于同样的规则，方法。我们就把这种规则称为
协议（protocol）

TCP/IP 是互联网相关的各类协议族的总称  

## TCP/IP的分层管理

TCP/IP 协议族里重要的一点就是分层。 TCP/IP 协议族按层次分别分为以下 4 层： 应用层、 传输层、 网络层和数据链路层。  

分层的好处：

* 如果互联网只由一个协议统筹， 某个地方需要改变设计时， 就必须把所有部分整体替换掉。 而分层之后只需把变动的层替换掉即可。 把各层之间的接口部分规划好之后， 每个层次内部的设计就能够自由改动了。  

* 设计也变得相对简单了。 处于应用层上的应用可以只考虑分派给自己的任务， 而不需要弄清对方在地球上哪个地方、 对方的传输路线是怎样的、 是否能确保传输送达等问题。  

### 分层模型

* 应用层：应用层决定了向用户提供应用服务时通信的活动。

    TCP/IP 协议族内预存了各类通用的应用服务：

    * FTP(File Transfer Protocol)文件传输协议
    * DNS(Domain Name System)域名系统
    * HTTP

* 传输层：传输层对上层应用层， 提供处于网络连接中的两台计算机之间的数据传输  

    在传输层有两个性质不同的协议：

    * TCP(Ttransmission Control Protocal)传输控制协议
    * UDP（User Data Protocol）用户数据报协议

* 网络层(网络互连层)：网络层用来处理在网络上流动的数据包。 数据包是网络传输的最小数据单位。 该层规定了通过怎样的路径（所谓的传输路线） 到达对方计算机， 并把数据包传送给对方。  

* 链路层(数据链路层， 网络接口层  )
* 用来处理连接网络的硬件部分。 包括控制操作系统、 硬件的设备驱动、 NIC（Network Interface Card， 网络适配器， 即网卡） ， 及光纤等物理可见部分（还包括连接器等一切传输媒介） 。 硬件上的范畴均在链路层的作用范围之内。  

## TCP/IP通信传输流

利用 TCP/IP 协议族进行网络通信时， 会通过分层顺序与对方进行通信。 发送端从应用层往下走， 接收端则往应用层往上走。  

![TCP IP通信传输_分层](https://gitee.com/wangziming707/note-pic/raw/master/img/IP%E9%80%9A%E4%BF%A1%E4%BC%A0%E8%BE%93_%E5%88%86%E5%B1%82.png)

发送端在层与层之间传输数据时， 每经过一层时必定会被打上一个该层所属的首部信息。 反之， 接收端在层与层传输数据时， 每经过一层时会把对应的首部消去。这种把数据信息包装起来的做法称为封装（encapsulate） 。  

![TCP IP传输封装](https://gitee.com/wangziming707/note-pic/raw/master/img/TCP%20IP%E4%BC%A0%E8%BE%93%E5%B0%81%E8%A3%85.png)

## HTTP与 IP、TCP、DNS

IP、 TCP 和 DNS  协议是与HTTP密不可分的协议

### IP协议

IP(Internet Protocol) 网际协议位于网络层。IP 协议的作用是把各种数据包传送给对方。  

要保证确实传送到对方那里， 则需要满足各类条件。 其中两个重要的条件是 IP 地址和 MAC地址（Media Access Control Address） 。  

IP 间的通信依赖 MAC 地址,在网络上，  通常是经过多台计算机和网络设备中转
才能连接到对方。  在进行中转时， 会利用下一站中转设备的 MAC地址来搜索下一个中转目标。 这时， 会采用 ARP 协议（AddressResolution Protocol） 。 ARP 是一种用以解析地址的协议， 根据通信方的 IP 地址就可以反查出对应的 MAC 地址。  

### TCP协议

TCP 位于传输层， 提供可靠的字节流服务。  

字节流服务（Byte Stream Service） 是指， 为了方便传输， 将大块数据分割成以报文段（segment） 为单位的数据包进行管理。 而可靠的传输服务是指， 能够把数据准确可靠地传给对方。

为了准确无误地将数据送达目标处， TCP 协议采用了三次握手（three-way handshaking） 策略，经过三次握手后建立连接：

握手需要用到主要TCP首部字段：

* 确认标志位ACK： 取值为1时确认号字段才有效；取值为0时确认号字段无效。TCP规定，在连接建立后所有传送的TCP报文段都必须把ACK置1。

* 同步标志位SYN： 在TCP连接建立时用来同步序号。

三次握手的步骤：

* 首先客户端发送标有SYN的数据包给服务端
* 然后服务端返回标有SYN/ACK的数据包给客户端
* 最后客户端发送标有ACK的数据包给服务端

三次握手结束后，客户端和服务端进入建立连接的状态

### DNS服务

DNS（Domain Name System） 服务是和 HTTP 协议一样位于应用层的协议。 它提供域名到 IP 地址之间的解析服务。  

计算机既可以被赋予 IP 地址， 也可以被赋予主机名和域名。   

用户通常使用主机名或域名来访问对方的计算机， 而不是直接通过 IP地址访问。 而计算机最终是通过IP地址来访问计算机。

 所以DNS 协议提供通过域名查找 IP 地址， 或逆向从 IP 地址反查域名的服务。  



## URL和URI

* URI(Uniform Resource Identifier)统一资源标识符

    是用来区别于其他互联网资源的标识

* URL(Uniform Resource Locator)统一资源定位符

    是URI的子集，它也标识了互联网资源，但额外地指定对其进行操作或获取该资源的方法。也就是它不仅唯一标识资源，而且还提供了定位该资源的信息。

URI 是一种语义上的抽象概念，可以是绝对的，也可以是相对的，而URL则必须提供足够的信息来定位，是绝对的。

如果参照物是整个互联网，那么URI就相当于URL

绝对URI格式：

~~~
[协议名]://[用户名]:[密码]@[服务器地址]:[服务器端口号]/[路径]?[查询字符串]#[片段ID]
~~~

* 登录信息（用户名：密码）
    指定用户名和密码作为从服务器端获取资源时必要的登录信息（身份认证）。此项是可选项。
* 服务器地址
    使用绝对 URI 必须指定待访问的服务器地址。地址可以是类似 hackr.jp 这种 DNS 可解析的名称，或是 192.168.1.1 这类 IPv4 地址 名，还可以是 [0:0:0:0:0:0:0:1] 这样用方括号括起来的 IPv6 地址名。
* 服务器端口号
    指定服务器连接的网络端口号。此项也是可选项，若用户省略则自动使用默认端口号。
* 带层次的文件路径
    指定服务器上的文件路径来定位特指的资源。这与 UNIX 系统的文件目录结构相似。
* 查询字符串
    针对已指定的文件路径内的资源，可以使用查询字符串传入任意参数。此项可选。
* 片段标识符
    使用片段标识符通常可标记出已获取资源中的子资源（文档内的某个位置）。但在 RFC 中并没有明确规定其使用方法。该项也为可选项。

# HTTP协议基础

HTTP协议用于客户端和服务器之间的通信

请求访问资源的一端称为客户端，提供资源响应的一端称为服务端

客户端和服务器之间通过发送请求报文和返回响应报文完成通信

## HTTP报文

用于 HTTP 协议交互的信息被称为 HTTP 报文。 请求端（客户端） 的HTTP 报文叫做请求报文， 响应端（服务器端） 的叫做响应报文。HTTP 报文本身是由多行（用 CR+LF 作换行符） 数据构成的字符串文本。
HTTP 报文大致可分为报文首部和报文主体两块。 两者由最初出现的空行（CR+LF） 来划分。 通常， 并不一定要有报文主体  

请求报文和响应报文的结构：

![HTTP报文结构](https://gitee.com/wangziming707/note-pic/raw/master/img/HTTP%E6%8A%A5%E6%96%87%E7%BB%93%E6%9E%84.png)

* 请求行：包含用于请求的方法， 请求 URI 和 HTTP 版本。  

* 状态行：包含表明响应结果的状态码， 原因短语和 HTTP 版本。  

* 首部字段：包含表示请求和响应的各种条件和属性的各类首部  

    一般有 4 种首部， 分别是： 通用首部、 请求首部、 响应首部和实体首部。  

* 其他：可能包含 HTTP 的 RFC 里未定义的首部（Cookie 等）

## 请求报文

请求报文是由请求方法、 请求 URI、 协议版本、 可选的请求首部字段和内容实体构成的。  

![HTTP请求报文](https://gitee.com/wangziming707/note-pic/raw/master/img/HTTP%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87.png)

* method方法：表示请求访问服务器的类型
* URI：请求URI知名请求访问的资源对象
* HTTP协议版本：用来提示客户端使用HTTP协议功能

### 请求方法

* `GET `用来请求访问已被 URI 识别的资源。指定的资源经服务器端解析后返回响应内容。   

* `POST `用来向服务端传输信息资源。虽说 POST 的功能与 GET 很相似， 但
    POST 的主要目的并不是获取响应的主体内容，而是向服务端发送信息。

* `PUT `用来传输文件要求在请求报文的主体中包含文件内容， 然后保存到请求 URI 指定的位置。  

    但是， 鉴于 HTTP/1.1 的 PUT 方法自身不带验证机制， 任何人都可以上传文件 , 存在安全性问题， 因此一般的 Web 网站不使用该方法。  

* `HEAD `获取报文首部。HEAD 方法和 GET 方法一样， 只是不返回报文主体部分。 用于确认URI 的有效性及资源更新的日期时间等。  

* `DELETE `用来删除文件：DELETE 方法按请求 URI 删除指定的资源。  

    但是， HTTP/1.1 的 DELETE 方法本身和 PUT 方法一样不带验证机制， 所以一般的 Web 网站也不使用 DELETE 方法。   

* `OPTIONS `用来询问只对请求URI指定的资源支持的方法

* `TRACK ` 让 Web 服务器端将之前的请求通信环回给客户端  

* `CONNECT` 方法要求在与代理服务器通信时建立隧道， 实现用隧道协议进行 TCP 通信。

     主要使用 SSL（Secure Sockets Layer， 安全套接层） 和 TLS（Transport Layer Security， 传输层安全） 协议把通信内容加 密后经网络隧道传输。  

## 响应报文

响应报文基本上由协议版本、 状态码（表示请求成功或失败的数字代码） 、 用以解释状态码的原因短语、 可选的响应首部字段以及实体主体构成。   

![HTTP响应报文](https://gitee.com/wangziming707/note-pic/raw/master/img/HTTP%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87.png)

* 协议版本：表示服务器对应的 HTTP 版本  

* 状态码：表示请求的处理结果  
* 原因短语：对状态码的简单解释



### HTTP状态码

HTTP 状态码负责表示客户端 HTTP 请求的返回结果、 标记服务器端的处理是否正常、 通知出现的错误等工作。  

状态码数字中的第一位指定了响应类别，响应类别有以下五种：

|      | 类别                             | 原因短语                   |
| ---- | -------------------------------- | -------------------------- |
| 1XX  | Informational（信息性状态码）    | 接收的请求正在处理         |
| 2XX  | Success（成功状态码）            | 请求正常处理完毕           |
| 3XX  | Redirection（重定向状态码）      | 需要进行附加操作以完成请求 |
| 4XX  | Client Error（客户端错误状态码） | 服务器无法处理请求         |
| 5XX  | Server Error（服务器错误状态码） | 服务器处理请求出错         |

下面介绍常用的状态码：

* `200 OK` 表示从客户端发来的请求在服务器端被正常处理了。  

* `204 No Content`表示服务器接收的请求已成功处理， 但在返回的响应报文中不
    含也不允许返回实体的主体部分。只允许返回实体首部

* `206 Partial Content`表示客户端进行了范围请求， 而服务器成功执行了这部分的GET 请求。   

* `301 Moved Permanently`永久性重定向。 该状态码表示请求的资源已被分配了新的 URI， 以后应使用资源现在所指的 URI。也就是说， 如果已经把资源对应的 URI保存为书签了， 这时应该按 Location 首部字段提示的 URI 重新保存。  

* `302 Found`临时性重定向。 该状态码表示请求的资源已被分配了新的 URI， 希望用户（本次） 能使用新的 URI 访问。  

* `303 See Other`该状态码表示由于请求对应的资源存在着另一个 URI， 应使用 GET方法定向获取请求的资源  

    该状态码表示由于请求对应的资源存在着另一个 URI， 应使用 GET方法定向获取请求的资源  

* `304 Not Modified`表示客户端发送附带条件的请求时， 服务器端允许请求访问资源， 但未满足条件  

    304 状态码返回时， 不包含任何响应的主体部分。 304 虽然被划分在 3XX 类别中， 但是和重定向没有关系  

* `307 Temporary Redirect`临时重定向。 该状态码与 302 Found 有着相同的含义。307 会遵照浏览器标准， 不会从 POST 变成 GET。     

* `400 Bad Request`该状态码表示请求报文中存在语法错误。 当错误发生时， 需修改请求的内容后再次发送请求。  

* `401 Unauthorized  `该状态码表示发送的请求需要有通过 HTTP 认证（BASIC 认证、DIGEST 认证） 的认证信息。 另外若之前已进行过 1 次请求， 则表示用 户认证失败  

* `403 Forbidden` 该状态码表明对请求资源的访问被服务器拒绝了。  

* `404 Not Found  `该状态码表明服务器上无法找到请求的资源。   

* `500 Internal Server Error`表明服务器端在执行请求时发生了错误。 也有可能是 Web应用存在的 bug 或某些临时的故障  

* `503 Service Unavailable  `该状态码表明服务器暂时处于超负载或正在进行停机维护， 现在无法处理请求。  

**注意1：**当 301、 302、 303 响应状态码返回时， 几乎所有的浏览器都会把POST 改成 GET， 并删除请求报文内的主体， 之后请求会自动再次发送。  

**注意2：**304中附带条件的请求是指采用 GET方法的请求报文中包含 If-Match， If-ModifiedSince， If-None-Match， If-Range， If-Unmodified-Since 中任一首部。  

## HTTP首部

HTTP首部字段是构成HTTP报文的要素之一。

给浏览器和服务器提供报文主体大小、 所使用的语言、 认证信息等内容。   

它在请求或响应的报文首部中。

根据实际用途，它被分为一下四种类型：

* 通用首部字段 :请求报文和响应报文两方都会使用的首部。  
* 请求首部字段: 补充了请求的附加内容、 客户端信息、 响应内容相关优先级等信息。  
* 响应首部字段:补充了响应的附加内容， 也会要求客户端附加额外的内容信息。  
* 实体首部字段:针对请求报文和响应报文的实体部分使用的首部。 补充了资源内容更新时间等与实体有关的信息  

### HTTP首部字段结构

HTTP 首部字段是由首部字段名和字段值构成的， 中间用冒号“:” 分隔  

示例：

~~~properties
首部字段名 : 字段值[，字段值...]
~~~

### 通用首部字段

#### Cache-Control

通过指定首部字段 Cache-Control 的指令， 就能操作缓存的工作机制  

##### 缓存请求指令

| 指令                | 参数   | 说明                         |
| ------------------- | ------ | ---------------------------- |
| no-cache            | 无     | 强制向源服务器再次验证       |
| no-store            | 无     | 不缓存请求或响应的任何内容   |
| max-age = [ 秒]     | 必需   | 响应的最大Age值              |
| max-stale( = [ 秒]) | 可省略 | 接收已过期的响应             |
| min-fresh = [ 秒]   | 必需   | 期望在指定时间内的响应仍有效 |
| no-transform        | 无     | 代理不可更改媒体类型         |
| only-if-cached      | 无     | 从缓存获取资源               |
| cache-extension     | -      | 新指令标记（token）          |

* no-cache:告知缓存服务器，客户端不接受缓存过的响应，此时缓存服务器必须把客户端请求转发给源服务器

* no-store:缓存不能在本地和缓存服务器存储请求或响应的任一部分。  

* max-age:只接受缓存时间小于max-age的缓存，如果缓存服务器中该资源的缓存时间大于max-age，那么服务器将请求转发给源服务器

* min-fresh：要求缓存服务器返回缓存时间小于指定时间的缓存资源。  

* max-stale:可指示缓存资源， 即使过期也照常接收 

    *  如果指令未指定参数值， 那么资源的缓存时间多长， 客户端都会接收响应 
    * 如果指令中指定了具体数值， 那么即使资源过期， 只要缓存时间仍处于 max-stale指定的时间内， 仍旧会被客户端接收。  

* only-if-cached 指使缓存服务器仅在本地缓存有该资源的情况下才会返回资源。

    该指令要求缓存服务器不重新加载响应， 也不会再次确认资源有效性。 若发生请求缓存服务器的本地缓存无响应， 则返回状态码 504 Gateway Timeout。 

* no-transform 规定无论是在请求还是响应中， 缓存都不能改变实体主体的媒体类型。  

##### 缓存响应指令

| 指令             | 参数   | 说明                                            |
| ---------------- | ------ | ----------------------------------------------- |
| public           | 无     | 可向任意方提供响应的缓存                        |
| private          | 可省略 | 仅向特定用户返回响应                            |
| no-cache         | 可省略 | 缓存前必须先确认其有效性                        |
| no-store         | 无     | 不缓存请求或响应的任何内容                      |
| no-transform     | 无     | 代理不可更改媒体类型                            |
| must-revalidate  | 无     | 可缓存但必须再向源服务器进行确认                |
| proxy-revalidate | 无     | 要求中间缓存服务器对缓存的响应有效性再 进行确认 |
| max-age = [ 秒]  | 必需   | 响应的最大Age值                                 |
| s-maxage = [ 秒] | 必需   | 公共缓存服务器响应的最大Age值                   |
| cache-extension  | -      | 新指令标记（token）                             |

* public 告知缓存服务器，其他用户也可利用该缓存
* private 告知缓存服务器，该缓存只提供给特定的用户

* no-cache: 告知缓存服务器，不能对该资源进行缓存

    若no-cache字段指定了参数值，那么接受这个响应的浏览器将不能缓存该响应

* no-store:缓存不能在本地和缓存服务器存储请求或响应的任一部分。  

* s-maxage:和max-age相似，但只针对代理服务器缓存，对浏览器缓存无效

* max-age：通知缓存服务器不再对资源的有效性进行确认，max-age值代表资源保存为缓存的最长时间

* must-revalidate 代理会向源服务器再次验证即将返回的响应缓存目前是否仍然有效。  

    使用 must-revalidate 指令会忽略请求的 max-stale 指令  

* proxy-revalidate 指令要求所有的缓存服务器在接收到客户端带有该指令的请求返回响应之前， 必须再次验证缓存的有效性。  

* no-transform 规定无论是在请求还是响应中， 缓存都不能改变实体主体的媒体类型。  

**注意：**使用 no-cache 并不意味着不缓存 

使用 no-cache 指令的目的是为了防止从缓存中返回过期的资源。 

no-cache 表示不缓存过期的资源  ，缓存会向源服务器进行有效期确认后处理资源  

如果服务器说资源仍然有效，那么缓存可以用它的表示进行响应（协商缓存）

#### Connection

具有一下两个作用：

* 控制不再转发给代理的首部字段
* 管理持久连接  

~~~properties
# 告知代理服务器，删除指定的字段再进行转发
Connection : 不再转发的首部字段名
# 服务端向明确断开连接时，和客户端想使用持久连接时
Connection : Close|Keep-Alive
~~~

#### Date

表明报文创建的日期和时间

#### Teailer

首部字段 Trailer 会事先说明在报文主体后记录了哪些首部字段。 该首部字段可应用在 HTTP/1.1 版本分块传输编码时  

#### Transfer-Encoding

规定了传输报文主体时采用的编码方式。  

#### Upgrade

用于检测 HTTP 协议及其他协议是否可使用更高的版本进行通信  

对于附有首部字段 Upgrade 的请求， 服务器可用 101 SwitchingProtocols 状态码作为响应返回  

#### Via

追踪客户端与服务器之间的请求和响应报文的传输路径。  

报文经过代理或网关时， 会先在首部字段 Via 中附加该服务器的信息， 然后再进行转发。   

首部字段 Via 不仅用于追踪报文的转发， 还可避免请求回环的发生。所以必须在经过代理时附加该首部字段内容  

#### Warning

告知用户一些与缓存相关的问题的警告  

~~~properties
Warning: [警告码][警告的主机:端口号]“[警告内容]”([日期时间])
~~~

| 警告码 | 警告内容                                          | 说明                                                         |
| ------ | ------------------------------------------------- | ------------------------------------------------------------ |
| 110    | Response is stale（响应已过期）                   | 代理返回已过期的资源                                         |
| 111    | Revalidation failed（再验证失败）                 | 代理再验证资源有效性时失败（服务 器无法到达等原因）          |
| 112    | Disconnection operation（断开连接操 作）          | 代理与互联网连接被故意切断                                   |
| 113    | Heuristic expiration（试探性过期）                | 响应的使用期超过24小时（有效缓存 的设定时间大于24小时的情况下） |
| 199    | Miscellaneous warning（杂项警告）                 | 任意的警告内容                                               |
| 214    | Transformation applied（使用了转换）              | 代理对内容编码或媒体类型等执行了 某些处理时                  |
| 299    | Miscellaneous persistent warning（持久 杂项警告） | 任意的警告内容                                               |

### 请求首部字段

请求首部字段是从客户端往服务器端发送请求报文中所使用的字段，用于补充请求的附加信息、 客户端信息、 对响应内容相关的优先级等内容  

#### Accept

Accept 首部字段可通知服务器， 用户代理能够处理的媒体类型及媒体类型的相对优先级。 可使用 type/subtype 这种形式， 一次指定多种媒体类型。  

accept常用的字段值：

~~~properties
text/html :HTML格式
text/plain :纯文本格式      
text/xml :  XML格式
image/gif :gif图片格式    
image/jpeg :jpg图片格式 
image/png:png图片格式
video/mpeg:视频
vedio/quicktime:视频
application/xhtml+xml :XHTML格式
application/xml     : XML数据格式
application/atom+xml  :Atom XML聚合格式    
application/json    : JSON数据格式
application/pdf       :pdf格式  
application/msword  : Word文档格式
application/octet-stream : 二进制流数据（如常见的文件下载）
application/x-www-form-urlencoded : < form encType=””>中默认的encType，form表单数据被编码为key/value格式发送到服务器（表单默认的提交数据的格式）
multipart/form-data : 在表单中上传文件时，设置这种类型。（在表单中经常使用，它不是application开头的）。
~~~

若想要给显示的媒体类型增加优先级， 则使用 q= 来额外表示权重值1， 用分号（;） 进行分隔。 权重值 q 的范围是 0~1（可精确到小数点后 3 位） ， 且 1 为最大值。 不指定权重 q 值时， 默认权重为 q=1.0。  

当服务器提供多种内容时， 将会首先返回权重值最高的媒体类型。  

#### Accept-Charset

Accept-Charset 首部字段可用来通知服务器用户代理支持的字符集及字符集的相对优先顺序。 另外， 可一次性指定多种字符集。 与首部字段 Accept 相同的是可用权重 q 值来表示相对优先级。  

该首部字段应用于内容协商机制的服务器驱动协商  

#### Accept-Encoding

告知服务器用户代理支持的内容编码及内容编码的优先级顺序。 可一次性指定多种内容编码。  

例如：

* gzip

    由文件压缩程序 gzip（GNU zip） 生成的编码格式（RFC1952） ， 采用 Lempel-Ziv 算法（LZ77） 及 32 位循环冗余校验（Cyclic Redundancy Check， 通称 CRC） 。

* compress
    由 UNIX 文件压缩程序 compress 生成的编码格式， 采用 LempelZiv-Welch 算法（LZW） 。

* deflate
    组合使用 zlib 格式（RFC1950） 及由 deflate 压缩算法（RFC1951） 生成的编码格式。

* identity
    不执行压缩或不会变化的默认编码格式  

采用权重 q 值来表示相对优先级， 这点与首部字段 Accept 相同。 另外， 也可使用星号（*） 作为通配符， 指定任意的编码格式。  

#### Accept-Language

用来告知服务器用户代理能够处理的自然语言集（指中文或英文等） ， 以及自然语言集的相对优先级。 可一次指定多种自然语言集。  

和 Accept 首部字段一样， 按权重值 q 来表示相对优先级。   

#### Authorization

告知服务器， 用户代理的认证信息（证书值） 。  

通常， 想要通过服务器认证的用户代理会在接收到返回的401 状态码响应后， 把首部字段 Authorization 加入请求中。   

#### Expect

告知服务器， 期望出现的某种特定行为。   (希望服务端响应特定的状态码)

例如

~~~properties
Expect: 100-continue
~~~

#### From

告知服务器使用用户代理的用户的电子邮件地址。   

使用代理时， 应尽可能包含 From 首部字段  

#### Host

告知服务器， 请求的资源所处的互联网主机名和端口号。   

(因为虚拟主机技术，相同的 IP 地址下可以部署运行着多个域名  )

#### If-Match

只有当 If-Match 的字段值跟 ETag 值匹配一致时， 服务器才会接受请求  

服务器会比对 If-Match 的字段值和资源的 ETag 值， 仅当两者一致时， 才会执行请求。 反之， 则返回状态码 412 Precondition Failed 的响应。  

还可以使用星号（*） 指定 If-Match 的字段值。 针对这种情况， 服务器将会忽略 ETag 的值， 只要资源存在就处理请求。  

#### If-Modified-Since

如果请求资源的修改时间晚于  If-Modified-Since 字段值  则服务器处理该请求

否则返回状态码 304 Not Modified 的响应。  

(也就是说，资源必须在 If-Modified-Since 指定的时间之后有过修改)

#### If-None-Match

首部字段 If-Match作用相反。 用于指定 If-None-Match 字段值的实体标记（ETag） 值与
请求资源的 ETag 不一致时， 服务器才会处理该请求。  

#### If-Range

该字段可以指定 ETag值或者时间

服务器若指定的 IfRange 字段值（ETag 值或者时间） 和请求资源的 ETag 值或时间相一致时， 则作为范围请求处理。 反之， 则返回全体资源。  

#### If-Unmodified-Since

和首部字段 If-Modified-Since 的作用相反。   

如果请求资源的修改时间早于  If-Modified-Since 字段值  则服务器处理该请求

否则以状态码 412 Precondition Failed 作为响应返回。  

(也就是说，资源必须在 If-Modified-Since 指定的时间之后没有修改过)

#### Max-Forwards

服务器在往下一个服务器转发请求之前， Max-Forwards 的值减 1 后重新赋值。 当服务器接收到 Max-Forwards 值为 0 的请求时， 则不再进行转发， 而是直接返回响应  

该字段能够保证请求在陷入循环时，会结束循环

#### Proxy-Authorization

客户向代理提供访问我认证  

#### Range

对于只需获取部分资源的范围请求， 包含首部字段 Range 即可告知服务器资源的指定范围  

接收到附带 Range 首部字段请求的服务器， 会在处理请求之后返回状态码为 206 Partial Content 的响应。 无法处理该范围请求时， 则会返回状态码 200 OK 的响应及全部资源。  

#### Referer

告知服务器请求的原始资源的 URI。  

(能够让服务器知道该请求时从那个网页发起的)

#### TE

TE 会告知服务器客户端能够处理响应的传输编码方式及相对优先级。

 它和首部字段 Accept-Encoding 的功能很相像， 但是用于传输编码。  

#### User-Agent

将创建请求的浏览器和用户代理名称等信息传达给服务器。  

### 响应首部字段

响应首部字段是由服务器端向客户端返回响应报文中所使用的字段，用于补充响应的附加信息、 服务器信息， 以及对客户端的附加要求等信息。  

#### Accept-Ranges

告知客户端服务器是否能处理范围请求， 以指定获取服务器端某个部分的资源  

* bytes 可处理范围请求
* none 不能处理范围请求  

#### Age

告知客户端， 源服务器在多久前创建了响应。 字段值的单位为秒  

若创建该响应的服务器是缓存服务器， Age 值是指缓存后的响应再次发起认证到认证完成的时间值。 代理创建响应时必须加上首部字段Age。  

#### ETag

知客户端实体标识。 它是一种可将资源以字符串形式做唯一性标识的方式。 服务器会为每份资源分配对应的 ETag值。  

当资源更新时， ETag 值也需要更新。

 生成 ETag 值时， 并没有统一的算法规则， 而仅仅是由服务器来分配。  

ETag 中有强 ETag 值和弱 ETag 值之分。  

* 强 ETag 值  不论实体发生多么细微的变化都会改变其值  
* 弱 ETag 值   只用于提示资源是否相同。 只有资源发生了根本改变， 产生差异时才会改变 ETag 值。   

#### Location

将响应接收方引导至某个与请求 URI 位置不同的资源。  

基本上， 该字段会配合 3xx ： Redirection 的响应， 提供重定向的URI。  

#### Proxy-Authenticate  

把由代理服务器所要求的认证信息发送给客户端。  

#### Retry-After

首部字段 Retry-After 告知客户端应该在多久之后再次发送请求。 主要配合状态码 503 Service Unavailable 响应， 或 3xx Redirect 响应一起使用。  

字段值可以指定为具体的日期时间（Wed, 04 Jul 2012 06： 34： 24GMT 等格式） ， 也可以是创建响应后的秒数。  

#### Server

告知客户端当前服务器上安装的 HTTP 服务器应用程序的信息。   



#### Vary  

可对缓存进行控制  

理服务器接收到源服务器返回包含 Vary 指定项的响应之后， 若再要进行缓存， 仅对请求中含有相同 Vary 指定首部字段的请求返回缓存。   

即使对相同资源发起请求， 但由于 Vary 指定的首部字段不相同， 因此必须要从源服务器重新获取资源。  

#### WWW-Authenticate  

用于 HTTP 访问认证。 它会告知客户端适用于访问请求 URI 所指定资源的认证方案  

### 实体首部字段

实体首部字段是包含在请求报文和响应报文中的实体部分所使用的首部， 用于补充内容的更新时间等与实体相关的信息。  

#### Allow

于通知客户端能够支持 Request-URI 指定资源的所有 HTTP 方法  

当服务器接收到不支持的 HTTP 方法时， 会以状态码405 Method Not Allowed 作为响应返回。 与此同时， 还会把所有能支持的 HTTP 方法写入首部字段 Allow 后返回  。

#### Content-Encoding  

告知客户端服务器对实体的主体部分选用的内容编码方式。   

#### Content-Language

告知客户端， 实体主体使用的自然语言（指中文或英文等语言） 。  

#### Content-Length  

表明了实体主体部分的大小（单位是字节） 。 

对实体主体进行内容编码传输时， 不能再使用 Content-Length首部字段。   

#### Content-Location  

给出与报文主体部分相对应的 URI  

#### Content-MD5  

首部字段 Content-MD5 是一串由 MD5 算法生成的值， 其目的在于检查报文主体在传输过程中是否保持完整， 以及确认传输到达。  

#### Content-Range

针对范围请求， 返回响应时使用的首部字段 Content-Range，

 能告知客户端作为响应返回的实体的哪个部分符合范围请求。

 字段值以字节为单位， 表示当前发送部分及整个实体大小  

#### Content-Type  

首部字段 Content-Type 说明了实体主体内对象的媒体类型。  

和首部字段 Accept 一样， 字段值用 type/subtype 形式赋值。

常用的值也与Accept一样；

参数 charset 使用 iso-8859-1 或 euc-jp 等字符集进行赋值。  

#### Expires

将资源失效的日期告知客户端。   

缓存服务器在接收到含有首部字段 Expires 的响应后， 会以缓存来应答请求， 在Expires 字段值指定的时间之前， 响应的副本会一直被保存。 当超过指定的时间后， 缓存服务器在请求发送过来时， 会转向源服务器请求资源。  

#### Last-Modified  

指明资源最终修改的时间。   



### 为Cookie服务的首部字段

Cookie 的工作机制是用户识别及状态管理。  

#### Set-Cookie

当服务器准备开始管理客户端的状态时， 会事先告知各种信息。  

Set-Cookie 字段的属性  ：

| 属性         | 说明                                                         |
| ------------ | ------------------------------------------------------------ |
| NAME=VALUE   | 赋予 Cookie 的名称和其值（必需项）                           |
| expires=DATE | Cookie 的有效期（若不明确指定则默认为浏览器关闭前为止）      |
| path=PATH    | 将服务器上的文件目录作为Cookie的适用对象（若不指定则默 认为文档所在的文件目录） |
| domain=域名  | 作为 Cookie 适用对象的域名 （若不指定则默认为创建 Cookie 的服务器的域名） |
| Secure       | 仅在 HTTPS 安全通信时才会发送 Cookie                         |
| HttpOnly     | 加以限制， 使 Cookie 不能被 JavaScript 脚本访问              |

#### Cookie  

告知服务器， 当客户端想获得 HTTP 状态管理支持时， 就会在请求中包含从服务器接收到的 Cookie。 接收到多个Cookie 时， 同样可以以多个 Cookie 形式发送。  









## HTTP特征

### 无状态协议

HTTP是一种不保存状态，即无状态（stateless）协议。HTTP 协议自身不对请求和响应之间的通信状态进行保存。 也就是说在 HTTP 这个级别， 协议对于发送过的请求或响应都不做持久化处理。  

使用 HTTP 协议， 每当有新的请求发送时， 就会有对应的新响应产生。 协议本身并不保留之前一切的请求或响应报文的信息。  

* 优点：更快地处理大量事务
* 缺点：有些互联网业务有保持状态的需求，为此引入了Cookie技术

### 持久连接

在HTTP协议的初始版本，每进行一次HTTP通信就要断开一次TCP连接

随着网站WEB的发展，请求的一张HTML页面中可能包含其他的资源请求，比如图片，视频等。这样每次的请求都会造成无谓的 TCP 连接建立和断开， 增加通信量的开销  

为了解决这样的问题HTTP/1.1提出了持久连接的方法：

只要任意一端没有明确提出断开连接，则保持TCP连接状态。

持久连接使得多数请求以管线化（pipelining） 方式发送成为可能  ：

不用等待响应亦可直接发送下一个请求  

### Cookie

Cookie 技术通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态。  

* Cookie 会根据从服务器端发送的响应报文内的一个叫做 Set-Cookie 的首部字段信息， 通知客户端保存 Cookie。 当下次客户端再往该服务器发送请求时， 客户端会自动在请求报文中加入 Cookie 值后发送出去。  

* 服务器端发现客户端发送过来的 Cookie 后， 会去检查究竟是从哪一个客户端发来的连接请求， 然后对比服务器上的记录， 最后得到之前的状态信息。  

### 编码

HTTP 在传输数据时可以按照数据原貌直接传输， 但也可以在传输过程中通过编码提升传输速率。 通过在传输时编码， 能有效地处理大量的访问请求。 但是， 编码的操作需要计算机来完成， 因此会消耗更多的 CPU 等资源  

* 报文：HTTP通信的基本单位，通过 HTTP 通信传输。  

* 实体：作为请求或响应的有效载荷数据（补充项） 被传输， 其内容由实体首部和实体主体组成。  

报文为客户端和服务端要发送的内容，实体是在传输过程中实际传输的内容

如果没有进行编码，实体就是报文

#### 内容编码

HTTP 协议中有一种被称为内容编码的功能  ，可以对报文内容压缩后传输

常用的内容编码有以下几种。

* gzip（ GNU zip）
* compress（ UNIX 系统的标准压缩）
* deflate（ zlib）
* identity（ 不进行编码）  



#### 分块传输编码

HTTP提供了分块传输编码功能，将实体主体分块传输

分块传输编码会将实体主体分成多个部分（块） 。 每一块都会用十六进制来标记块的大小， 而实体主体的最后一块会使用“0(CR+LF)”来标记。
使用分块传输编码的实体主体会由接收的客户端负责解码， 恢复到编码前的实体主体  

### 多部分对象集合

HTTP 协议中提供多部分对象集合， 发送的一份报文主体内可含有多类型实体。 通常是在图片或文本文件等上传时使用。  

多部份的对象集合包含以下对象：

* `multipart/form-data`

    在 Web 表单文件上传时使用  

* `multipart/byteranges`

    状态码 206（Partial Content， 部分内容） 响应报文包含了多个范围的内容时使用。  

### 范围请求

范围请求(Range Request)指定下载的实体范围

* 执行范围请求时，会用到首部字段Range来指定资源的byte范围

* 指定范围请求响应时，会返回状态码为 Partial Content的响应报文

    另外， 对于多重范围的范围请求， 响应会在首部字段 ContentType 标明 multipart/byteranges 后返回响应报文。  

### 内容协商

内容协商(Content Negotiation) :使用同一URI的不同资源表述方式的机制

内容协商会以响应资源的语言、 字符集、 编码方式等作为判断的基准。  

例如：当浏览器的默认语言为英语或中文， 访问相同 URI 的 Web 页面时，则会显示对应的英语版或中文版的 Web 页面。   

包含在请求报文的某些首部字段就是判断的基准：

* `Accept`
* `Accept-Charset`
* `Accept-Encoding`
* `Accept-Language`
* `Content-Language`

内容协商技术有以下 3 种类型:

* 服务器驱动协商(Server-driven Negotiation)

    由服务器端进行内容协商.以请求的首部字段为参考， 在服务器端自动处理。   

* 客户端驱动协商(Agent-driven Negotiation)

    由客户端进行内容协商的方式。 用户从浏览器显示的可选项列表中手动选择。   

* 透明协商(Tranparent Negotiation)

    是服务器驱动和客户端驱动的结合体， 是由服务器端和客户端各自进行内容协商的一种方法。  





# HTTP通信数据转发

HTTP 通信时， 除客户端和服务器以外， 还有一些用于通信数据转发的应用程序， 例如代理、 网关和隧道。 它们可以配合服务器工作。  

## 代理

代理是一种有转发功能的应用程序， 它扮演了位于服务器和客户端“中间人”的角色， 接收由客户端发送的请求并转发给服务器， 同时也接收服务器返回的响应并转发给客户端。  

代理服务器的基本行为就是接收客户端发送的请求后转发给其他服务器。 代理不改变请求 URI， 会直接发送给前方持有资源的目标服务器  

每次通过代理服务器转发请求或响应时， 会追加写入 Via 首部信息  以标记出经过的主机信息。  

使用代理技术我们可以：

* 利用缓存技术减少网络带宽的流量
* 组织内部针对特定网站的控制权限
* 以获取访问日志为主要目的

代理有多种使用方法， 按两种基准分类。 一种是是否使用缓存， 另一种是是否会修改报文。  

* 缓存代理：代理转发响应时， 缓存代理（Caching Proxy） 会预先将资源的副本（缓存） 保存在代理服务器上。当代理再次接收到对相同资源的请求时， 就可以不从源服务器那里获取资源， 而是将之前缓存的资源作为响应返回。  

* 透明代理:转发请求或响应时， 不对报文做任何加工的代理类型被称为透明代理（Transparent Proxy） 。 反之， 对报文内容进行加工的代理被称为非透明代理。  

## 网关

网关的工作机制和代理十分相似。 而网关能使通信线路上的服务器提供非 HTTP 协议服务。  

利用网关能提高通信的安全性， 因为可以在客户端与网关之间的通信线路上加密以确保连接的安全。 比如， 网关可以连接数据库， 使用SQL语句查询数据。 另外， 在 Web 购物网站上进行信用卡结算时，网关可以和信用卡结算系统联动  



## 隧道

隧道可按要求建立起一条与其他服务器的通信线路， 届时使用 SSL等加密手段进行通信。 隧道的目的是确保客户端能与服务器进行安全的通信。  