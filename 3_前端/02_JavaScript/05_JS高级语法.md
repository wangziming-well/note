# 迭代器和生成器

可迭代对象和迭代器时ES的一个特性。数组、字符串、Set对象等都是可迭代的。

可迭代对象意味着可以通过`for/of`循环来迭代：

~~~js
let sum = 0;
for(let i of [1,2,3])
    sum +=i;
console.log(sum) //6
~~~

迭代器让`...`操作符能够展开或者扩展可迭代对象：

~~~js
let chars =[..."abcd"] // ["a","b","c","d"]
let date = [1,2,3,4,5];
Math.max(...date); //5
~~~

迭代器也可以用于解构赋值：

~~~JS
let [x,y] = [1,2];  //相等于 let x = 1, y =2;
[x,y] = [x+1,y+1];
~~~

接下来我们会介绍迭代器的原理，如何创建可迭代对象，最后将如何用生成器简化迭代器的创建。

## 迭代器原理

要理解迭代是如何发生的，需要理解下面三种对象：

* 可迭代对象指任何具有专用迭代器方法，且该方法返回迭代器对象的对象。

* 迭代器对象指具有next()方法，且该方法返回迭代结果对象的对象。

* 迭代结果对象指具有属性value和done的对象。

要迭代一个可迭代对象，首先要调用其迭代器方法，获取一个迭代器对象，然后，重复调用这个迭代器对象的`next()`方法，直到返回done属性为true的迭代结果对象。

这里比较特殊的是，可迭代对象的迭代器方法没有使用惯用名称，而是使用了符号`Symbol.iterator`最为名字：

因此，最开始给出的`for/of`循环实际上进行了如下的等价操作：

~~~js
let sum = 0;
let array = [1,2,3];
let iter = array[Symbol.iterator];
for(let result =iter.next();!result.done;result=iter.next())
    sum += result.value;
console.log(sum) //6
~~~

## 实现可迭代对象

除了JS提供的可迭代对象。我们也可以将自己实现的对象实现为可迭代对象。

为了让类可迭代，必须要实现一个名为`Symbol.iterator`的迭代器方法，该方法返回一个迭代器对象。而迭代器对象有一个`next()`方法。而这个`next()`方法必须返回一个迭代结果对象。而迭代结果对象有`value`和`done`属性。

例如下面range对象:

~~~js
class Range{
    constructor(from,to) {
        this.from = from;
        this.to = to;
    }

    has(x){return typeof x === "number" && this.from <=x && x <= this.to;}

    [Symbol.iterator](){
        let next = Math.ceil(this.from)
        let last = this.to;
        return {
            next(){
                return (next <= last) ? {value: next++}: {done:true}
            }
        }
    }
}

for (let x of new Range(1,5)){
    console.log(x)
}
~~~

可迭代对象和迭代器有一个重要特性，即迭代计算式惰性的:不会一次性计算所有值，而是没调用一个`next()`方法计算一次值。

### `return()`方法

迭代器有时候不一定会跑完，如`for/of`循环可能会呗break，return或异常中止。

除了`next()`方法，迭代器对象还可以实现`return()`方法。如果迭代在`next()`返回done属性为true的迭代结果之前停止，那么解释器会检查迭代器对象是否有`return()`方法。如果有解释器就会调用它，让迭代器有机会关闭文件，释放内存，或者做一些其他清理工作。

这个`return()`方法必须返回一个迭代器结果对象。这个对象的属性会被忽略，但返回非对象值会导致报错。

## 生成器

生成器是使用信息ES6语法定义的迭代器，适合哟啊迭代的值不是某个数据结构的元素，而是计算结果的场景。

要创建生成器，首先必须定义一个生成器函数。生成器函数在语法上类似于常规的函数，但使用的关键字是`function*`而非`function`

调用生成器函数并不会实际执行函数体，而是返回一个生成器对象。这个生成器对象是一个迭代器。调用它的`next()`方法会导致生成器函数的函数体从头开始执行，直到于道以恶yield语句。yield语句的值回成为调用迭代器的next()方法的返回值。

例如：

~~~js
function* increment(){
    yield 2;
    yield 3;
    yield 4;
    yield 5;
}

let iter = increment(); //调用生成器函数，获取生成器对象
console.log(iter.next().value) //2
console.log(iter.next().value) //3
console.log(iter.next().value) //4
console.log(iter.next().value) //5
console.log(iter.next().done) //true
~~~

既然生成器就是迭代器，那么我们就可以用生成器函数简化可迭代对象的定义：

~~~js
class Range{
    constructor(from,to) {
        this.from = from;
        this.to = to;
    }

    has(x){return typeof x === "number" && this.from <=x && x <= this.to;}

    *[Symbol.iterator](){
        let next = Math.ceil(this.from)
        let last = this.to;
        for (let i = next; i <= last; i++) {
            yield i;
        }
    }
}

for (let x of new Range(1,5)){
    console.log(x)
}
~~~

## 生成器特性

生成器函数最常见的用途是创建迭代器，但生成器的基本特性是可以暂停计算，回送中间结果，然后后续在某个时刻恢复计算

### 生成器函数的返回值

生成器函数也可以有`return`语句。对于返回值的生成器。最后一次调用next()返回的对象的value和done都有定义：value是生成器的返回值，done是true最后这个值会被`for/of`循环或者扩展操作符忽略，但手工迭代时可以通过显式调用`next()`得到

~~~js
function *oneAndDone(){
    yield 1;
    return "done";
}

console.log(...oneAndDone()); //[1]
let iter = oneAndDone();
console.log(iter.next()) //{ value: 1, done: false }
console.log(iter.next()) //{ value: 1, done: false }
console.log(iter.next()) //{ value: undefined, done: true }
~~~

### yield表达式的值

yield表达式本身也会求值

调用生成器的next()方法时，生成器函数会一直运行直到达到一个yield表达式，yield关键字后面的表达式会被求值，该值成为`next()`调用的返回值。此时，生成器函数就在求值yield表达式的中途停下来。下一次调用生成器`next()`方法时，传给`next()`的参数会变成暂停的`yield`表达式的值。也就是说生成器通过yield向调用者返回值，调用者通过`next()`给生成器传值。

~~~js
function *oneAndDone(){
    let a =yield 1;
    console.log("a="+a)
}
let iter = oneAndDone();
console.log(iter.next())
console.log(iter.next(10))
~~~

上述程序输出如下：

~~~cmd
{ value: 1, done: false }
a=10
{ value: undefined, done: true }
~~~

# 异步JS

浏览器中的JS程序是典型的事件驱动型程序，即它们会等待用户单击或触发，然后才会真正执行。而基于JS的服务器通常需要等待客户端通过网络发送请求，然后才能执行。

接下来介绍JS三种重要的语言特性，来简化异步编程：

* ES6新增期约(Promise)对象，代表某个异步操作尚不可知的结果
* ES2017引入关键字`async`和`await`，简化异步编程语法
* ES2018一如`for/await`循环，允许在看起来同步的简单循环中操作异步事件流

## 使用回调的异步编程

JS异步编程在基本层面上使用回调实现。

回调就是函数，这个函数传递给其他函数，而其他函数会在满足某个条件或者发生某个(异步)事件时调用(回调)这个函数。回调函数被调用，相当于通知你满足某个条件或发生了某个事件。

### 定时器

最简单的异步操作时一定时间过后运行某些代码，可以使用`setTimeout()`函数实现这样的操作：

~~~js
function callback(){console.log("happened")}
setTimeout(callback,5000)
~~~

关于定时器的内容，在之前的章节已经介绍过

### 事件

客户端JS几乎都是事件驱动的，等待用户做一些事，然后响应用户动作。如用户在按下鼠标，移动鼠标，单击元素等，浏览器会生成对应事件。

JS程序在特定上下文中为特定类型的事件注册回调函数，而浏览器在指定事件发生时调用这些函数。这些回调函数叫做事件处理程序或者事件监听器，是通过`addEventListener()`注册的

~~~html
<body>
<button id="btn">请点击</button>
</body>
<script>
let btn = document.querySelector("#btn");
btn.addEventListener('click',callback)
function callback(){
    alert("good")
}
</script>
~~~



## 期约

期约(Promise)是一种简化异步编程的核心语言特性



