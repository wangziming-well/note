# 类

在JS中，类使用基于原型的继承。如果两个对象从同一个原型继承属性，那么就说这些对象是同一个类的实例。JS的类和基于原型的继承机制与Java等语言中类和基于类的继承机制有本质的区别

JS一直允许定义类。ES6新增了相关语法让创建类更容易。

## 类和原型

在JS中，类意味着一组对象从同一个原型对象继承属性。因此，原型对象是类的核心特征。

`Object.create()`函数用于创建一个新对象，这个新对象继承指定的原型对象。如果我们定义了一个原型对象，然后使用`Object.create()`创建一个继承它的对象，那我们就定义了一个JS类。

通常，一个类的实例需要初始化，所以常见的做法是定义一个函数来创建和初始化新对象。例如：

~~~js
//该方法返回一个range范围对象
function range(from,to){
    //创建并初始化对象
    let r = Object.create(range.methods);
    r.from = from;
    r.to = to;
    return r;
}

range.methods = {
    includes(x) {return this.from <=x && x<= this.to; },
    *[Symbol.iterator](){
        for (let x = Math.ceil(this.from);x<=this.to;x++)
            yield x;
    },
    toString() { return "(" + this.from + "..."+this.to + ")"}
}
let r = range(1,3);
r.includes(2) // true
r.toString(); //"(1...3)"
[...r]; // [1,2,3];
~~~

## 类和构造函数

上一节介绍了定义JS类的简单方式。不过这种方式并非习惯写法，因为它没有定义构造函数。

构造函数是专门用于初始化对象的函数。

之前已经介绍过，构造函数使用`new`关键字调用。使用`new`调用构造函数会自动创建并返回新对象。

因此构造函数本身只需要初始化新对象的状态。构造函数调用关键在于构造函数的`prototype`属性会被用作新对象的原型。

下面是示例：

~~~js
function Range(from,to){
    this.from = from;
    this.to = to;
}

Range.prototype = {
    includes(x) {return this.from <=x && x<= this.to; },
    *[Symbol.iterator](){
        for (let x = Math.ceil(this.from);x<=this.to;x++)
            yield x;
    },
    toString() { return "(" + this.from + "..."+this.to + ")"}
}

let r = new Range(1,3);
r.includes(2) // true
r.toString(); //"(1...3)"
[...r]; // [1,2,3];
~~~

### 构造函数、类标识和`instanceof`

原型对象是类标识的基本:当且仅当对象继承同一个原型对象时，它们才是同一个类的实例。

两个不同的构造函数产生的对象可能有同一个类，因为两个构造函数的`prototype`可能指向同一个原型对象。

虽然构造函数不像原型这么基本，但构造函数充当类的外在表现。就像构造函数的名字通常都用作类名。

使用`instanceof`测试类的成员关系时，构造函数是其右操作数：

~~~js
r instanceof Range // true : r继承了Range.prototype
~~~

对于表达式`o instanceof C` ，如果`o`继承`C.prototype`则表达式求值为true

这里的继承不一定是直接继承，间接继承表达式的求值也为`true`

### `constructor`属性

在构造函数的示例中，`Range.prototype`设置为一个新对象，其中包含类的方法。尽管把方法定义为对象字面量的属性很方便，但实际上没必要创建一个新对象。

任何普通JS函数(不包含箭头函数、生成器函数和异步函数)都可以用作构造函数，而构造函数调用需要要给`prototype`属性。因此，每个普通JS函数自动拥有一个`prototype`属性。在初始状态时，这个属性的值是一个对象，有一个不可枚举的`constructor`属性。而这个`constructor`属性的值就是该函数对象：

~~~js
function Range(from,to){
    this.from = from;
    this.to = to;
}

Range.prototype.constructor === Range; // true
~~~

这个预定义对象以及`constructor`属性的存在，意味着构造函数生成的对象也会继承一个引用其构造函数的`constructor`属性：

~~~js
let o = new F();
let a = o.constructor === F ; //true
~~~

所以像在构造函数示例中那样粗暴的将`Range.prototype`设置为自定义值会丢失这个预定义的对象和其`constructor`属性。这个问题可以通过显示地为原型添加一个`constructor`属性来解决：

~~~js

Range.prototype = {
    constructor : Range,
    includes(x) {return this.from <=x && x<= this.to; },
    ...
}
~~~

另一个方法时不覆盖预定义的原型对象和其`constructor`属性，而是逐个添加方法：

~~~js
function Range(from,to){
    this.from = from;
    this.to = to;
}

Range.prototype.includes = function (x) {return this.from <=x && x<= this.to; };
...
~~~

不过这种方法无法为类添加可迭代方法。

## 使用`class`关键字的类

ES6后引入`class`关键字，可以更方便的定义类：

~~~js
class Range {
    constructor(from,to) {
        this.from = from;
        this.to = to;
    }
    includes(x) {return this.from <=x && x<= this.to; }
    *[Symbol.iterator](){
        for (let x = Math.ceil(this.from);x<=this.to;x++)
            yield x;
    }
    toString() { return "(" + this.from + "..."+this.to + ")"}
}
let r = new Range(1,3);
r.includes(2) // true
r.toString(); //"(1...3)"
[...r]; // [1,2,3];
~~~

使用`class`关键字定义的类与构造方法定义的类工作方式完全一样。`class`关键字并未改变JS类基于原型的本质。

关于`class`定义的类，需要注意以下几点：

* 类是以`class`关键字声明的，后面更着类名和花括号中的类体
* 类体使用对象字面量方法简写形式定义方法。与对象字面量不同的是，方法之间没有逗号。
* 类体中不支持`key:value`形式的属性定义
* 关键字`constructor`用于定义类的构造函数。
* 如果类不需要初始化，可以省略`constructor`关键字以及其方法体。解释器会隐式创建一个空构造函数。
* 即使没有`"use strict"`命令，class声明体中的所有代码默认处于严格模式
* 与函数声明不同，类声明不会提生

函数声明有语句和表达式两张形式。类也一样：

~~~js
let Square = class{
    constructor(x) {
        this.areas = x*x;
    }

}
new Square(3).areas // 9
~~~

### 静态方法

在`class`体中，使用`static`关键字放在方法声明前面可以定义静态方法。静态方法是作为构造函数而非原型对象的属性定义的：

例如,在`Range`类声明中新增：

~~~js
static parse(s){
    let matches = s.match(/^\((\d+)\.\.\.(\d+)\)$/);
    if (!matches)
        throw new TypeError(`Cannot parse Range from "${s}"`);
    return new Range(parseInt(matches[1]),parseInt(matches[2]));
}
~~~

这个方法用来将字符串转换为`Range`类对象：

~~~js
let r = Range.parse("(1...3)");
[...r] // [1,2,3]
~~~

### 获取方法、设置方法以及其他形式的方法

在`class`体内，可以像在对象字面量中一样定义获取方法和设置方法，唯一的区别是类体内的获取方法和设置方法后面不加逗号：

~~~js
class Range {
    get start(){return this.from}
    set start(from){this.from = from}
    ....
}
~~~

一般来说，对象字面量支持的所有简写的方法定义语法都可以在类体中使用。这包括生成器方法和名字为方括号中表达式值的方法等。

## 子类

在面向对象编程中，有继承和父类子类的概念。

接下来介绍ES6之前如何定义子类，和用`class`和`extends`关键字定义子类

### 子类与原型

使用原型实现子类，需要子类的`prototype`属性是父类`prototype`属性指向对象的扩展：

Range的简单子类：

~~~js
function Span(start,span){
    if (span >=0){
        this.from = start;
        this.to = start+ span;
    } else {
        this.to = start;
        this.from = start + span;
    }
}
Span.prototype = Object.create(Range.prototype);
Span.prototype.constructor = Span;
Span.prototype.toString = function () {
    return `(${this.from}...${this.to})`
}
~~~

这里核心的语句是`Span.prototype = Object.create(Range.prototype);`,Span的原型继承自Range的原型。

这样通过`Span()`创建的对象就会继承`Span.prototype`，也会继承`Range.prototype`

### 通过`extends`和`super`创建子类

在ES6之后，要继承父类，可以简单地在类声明上加上一个`extends`子句，对内置的类也同样可以：

~~~js
class EZArray extends Array{
    get first(){return this[0]}
    get last(){return this[this.length-1]}
}
let ezArray = new EZArray(1,2,3);
ezArray.first; //1
ezArray.last; //3
~~~

在子类中，可以通过`super`关键字访问父类属性、方法、构造函数(`super()`)

`super()`只能在子类构造函数中使用，使用它需要注意：

* 如果使用`extends`关键字定义了一个类，这个类的构造函数必须使用`super()`构造父类构造函数。

* 如果没有在子类中定义构造函数，解释器会自动创建一个。并隐式调用`super()`
* 在通过`super()`调用父类构造函数之前，不能再构造函数中使用`this`关键字。这保证了父类先于子类初始化

# 模块

模块化编程的目标是能够用不同作者和来源的代码模块组装成大型程序。实践中，模块化的作用主要体现在封装和隐藏私有实现细节，以及保证全局命名空间清洁上，因此模块之间不会意外修改各自定义的变量、函数和类。

一开始，JS没有内置对模块的支持。我们只能用类、对象和闭包的弱模块化能力实现。

之后由于打包工具的支持，基于闭包的模块化在实践中成为常用模块化形式，核心是沿用了Node的`require()`函数。

ES6及以后，使用`import`和`export`关键字定义了自己的模块。

实践中，JS的模块化依然依赖代码打包工具。

## 基于类、对象和闭包的模块

类的一个重要特性，就是它们充当了自己方法的模块：多个类中的同名方法不会被覆盖。

不相关的类的方法之所以能够相互独立，是因为每个类的方法都被定义为独立原型对象的属性。

而类之所以成为模块，是因为对象是模块：给一个JS对象定义属性不影响程序的全局命名空间，也不影响其他兑现的属性。

使用类和对象实现模块化是JS编程中常见且有用的技术，但这还不够。特别地，类和对象没有提供任何方式来隐藏模块的内部实现细节。

我们之前已经知道，在函数中声明的局部变量和嵌套函数都是函数自有的。这意味着我们可以使用立即调用的函数表达式来把实现细节和辅助函数隐藏在包装函数中，只将模块的公共API作为函数的值返回。以实现隐藏模块内部实现。

以`BitSet`为例，可以像下面这样实现模块：

~~~js
const BitSet =(function () { //将BitSet设置为这个函数的返回值
    //这里实现私有细节
    function isValid(){}
    ......
    //返回公共API:BitSet类
    return class BitSet {
        //省略实现
    }
}())
~~~

## Node中的模块

编写Node程序时，可以随意将程序拆分到任意多个文件中。这些JS代码文件被假定始终存在于一个快速文件系统中。

于通过相对较慢的网络连接读取JS文件的浏览器不同，把所有Node代码写到一个JS文件中既无必要也无益处。

在Node中，每个文件都是一个拥有私有命名空间的独立模块。在一个文件中定义的常量、变量、函数、类对该文件而言都是私有的，除非该文件会导出它们。而被模块导出的值只有被另一个模块显式导入后才会对该模块可见。

