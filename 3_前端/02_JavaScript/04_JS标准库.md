# 集合和映射

对象在JS编程中经常被用做映射和集合，但却要收到字符串约束的限制。另外对象正常都会继承原型的属性，这些对集合和映射都是多余的。所以ES6新增了真正的Set和Map类

## Set

集合没有索引或顺序，不允许重复。

可以使用`Set()`构造函数创建集合对象,其期望一个可迭代对象：

~~~js
let s1 = new Set();
let s2 = new Set([1,"A"]);
~~~

其TS定义如下：

~~~ts
interface Set<T> {
    add(value: T): this; //向集合中添加元素
    clear(): void; //清空集合
    delete(value: T): boolean; //删除指定元素，删除成功返回true，否则返回false
    forEach(callbackfn: (value: T, value2: T, set: Set<T>) => void, thisArg?: any): void; //迭代
    has(value: T): boolean; //测试是否包含指定值(使用全等操作符===)
    readonly size: number; //集合大小
}
~~~

`Set`是可迭代的，所有可以用`for/of`循环枚举集合的所有元素

## Map

Map维护一组键值对，键在Map中是唯一的,可以使用`Map()`构造函数映射对象：

~~~js
let m1 = new Map();
let m2 = new Map([
    ["one",1],
    ["two",2]
]);
~~~

其构造函数的可选参数是一个可迭代对象，其迭代元素是包含两个元素的数组`[key,value]`

其TS定义接口如下:

~~~ts
interface Map<K, V> {
    clear(): void;
    delete(key: K): boolean;
    forEach(callbackfn: (value: V, key: K, map: Map<K, V>) => void, thisArg?: any): void;
    get(key: K): V | undefined;
    has(key: K): boolean;
    set(key: K, value: V): this;
    readonly size: number;
}
~~~

# 定型数组

常规JS数组可以包含任意类型的元素，可以动态扩展或收缩。但是这种数组于C和Java等较低级语言的数组还是有很大区别。

ES6新增定型数组，于这些语言的低级数组非常接近。

定型数组和常规数组有如下区别：

* 定型数组的元素全部都是数组。定型数组允许指定存储再数组中的数值的类型
* 定型数组再创建时必须指定长度，且长度不能改变
* 定型数组的元素在创建时会被初始化为0

## 定型数组的类型

JS定义了11种定型数组，每种都有自己的元素类型和构造函数：

| 构造函数              | 数值类型                     |
| --------------------- | ---------------------------- |
| `Int8Array()`         | 有符号8位整数                |
| `Uint8Array()`        | 无符号8位整数                |
| `Uint8ClampedArray()` | 无符号8位整数(上溢不归零)    |
| `Int16Array()`        | 有符号16位短整数             |
| `Unit16Array()`       | 无符号16位短整数             |
| `Int32Arrat()`        | 有符号32位短整数             |
| `Unit32Array()`       | 无符号32位短整数             |
| `BigInt64Array()`     | 有符号64位`BigInt`值(ES2020) |
| `BigUnit64Array()`    | 无符号64位`BigInt`值(ES2020) |
| `Float32Array()`      | 32位浮点值                   |
| `Float64Array()`      | 64位浮点值                   |

`Uint8ClampedArray()`是`Uint8Array()`的一种特殊变体，两种类型都保留无符号字节，可表示的数值范围是0到255，它们的不同之处在于

* 对`Uint8Array()`来说，当存储的值大于255或者小于0时，会截取其低8位，计算其值存储。
* 对`Uint8ClampedArray()`来说，如果要存储的值大于255或者小于0时，那么实际存储值会固定位255或0.

以上定型数组构造函数都有一个`BYTES_PER_ELEMENT`属性，根据存储的元素大小，可能值为1、2、4、8

## 创建定型数组

可以通过对应构造函数创建定型数组，并传入要给表示数组元素个数的数值参数：

~~~js
let bytes = new Uint8Array(1024);
let matrix = new Float64Array(9);
let pont = new Int16Array(3);
~~~

用这种方式创建定型数组，则数组元素一定会初始化为0、0n、0.0。

如果在创建时需要指定值，可以使用构造函数的静态工厂方法`of()`：

~~~js
let white = Uint8ClampedArray.of(255,255,255,0);
~~~

而`from()`支持赋值已有的定型数组，尽管类型可能会改变：

~~~js
let ints = Uint32Array.from(white);
~~~

还可以通过`ArrayBuffer`创建定型数组。

`ArrayBuffer`类不允许读取或写入分配的任何字节。但可以创建使用该缓冲区内存的定型数组，通过这个数组来读取或写入该内存。

为此，在调用定型数组的构造函数时，将`ArrayBuffer`作为第一个参数，将该缓冲区内的字节偏移量作为第二个参数，将数组的长度作为第三个参数。如果省略第二个和第三个参数，则数组会使用缓冲区的所有内存。如果只省略长度，则数组会使用从起始位置到缓冲区结束的所有可用内存。

~~~js
let buffer = new ArrayBuffer(1024*1024);
let array = new Int32Array(buffer,1024,256);
~~~

**注意：**数组的内存必须是对齐的，如果指定了字节偏移量，那么这个值必须是类型大小的倍数。例如`Int32Array()`指定的字节偏移量必须是4的倍数。

同一个`ArrayBuffer`可以提供给不同的数组，这样的多个数组就作为同一个`ArrayBuffer`的视图。

实际上，所有的定型数组底层都有一个`ArrayBuffer`，如果没有指定，创建时会自动创建一个缓冲区。

## 使用定型数组

创建定型数组后，可以通过中括号语法读取或写入其元素，和操作普通数组一样：

~~~js
let array = new Int8Array(8);
array[0] = 10;
array[1]; //0
~~~

定型数组实现了普通数组的多数方法，所有几乎可以像使用常规数组一样使用它们：

~~~js
let ints = new Int16Array(10);
ints.fill(3).map(x=>x*x).join(""); // "999999999"
~~~

定型数组的长度是固定的，因此`length`属性是只读的，而定型数组并未实现改变数组长度的方法(如`push()`、`pop()`等)

## 定型数组方法和属性

除了标准的数组方法，定型数组也实现了它们自己的一些方法。

`set()`用于一次性设置定型数组的多个元素，即把常规数组或定型数组的元素复制到当前定型数组中,它接受两个参数，第一个是要复制的数组，第二个是在数组中复制的位置,不指定默认为0

~~~js
let array = new Uint8Array(8);
array.set(Uint8Array.of(1,2,3,4));
array.set([1,2,3,4],4);
array //[1,2,3,4,1,2,3,4]
~~~

`subarray()`方法返回调用它的定型数组的一部分，注意`subarray()`不复制内存，只返回底层值的一个新视图，对`subarray()`返回的数组的修改，会反映到原数组：

~~~js
let source = new Uint8Array([1,2,3,4]);
let target = source.subarray(0,2);
target[0] = 10;
source[0] === 10 ; //true
~~~

这实际上是因为它们共用一个`ArrayBuffer`

每个定型数组都有三个属性和缓冲区相关：`buffer`:数组对应的缓冲区、`byteOffset`：数组在缓冲区中的偏移量、`byteLength`：数组在缓冲区中视图的字节长度

# 正则匹配

JS用`RegExp`类表示正则表达式。

## 定义正则表达式

`RegExp`对象可以使用`RegExp()`构造函数来创建，也可以通过字面量语法来创建。

与字符串字面量雷系，正则表达式字面量就是包含在一对`/`字符之间的字符，例如：

~~~js
let pattern =/s$/
~~~

通过构造函数创建的方式如下：

~~~js
let pattern = new RegExp("s$");
~~~

## 模式匹配的字符串方法

`String`支持4个使用正则表达式的语法：

### `search()`

`search()`接受一个正则表达式参数，返回第一个匹配项起点字符的位置，如果没有知道匹配项，返回-1:

~~~js
"JavaScript".search(/script/i); //4
"Python".search(/script/i); //-1
~~~

如果`search()`方法的参数不是正则表达式，它会先把这个参数传给`RegExp()`构造函数。

`search()`不支持全局搜索，正则表达式参数中的`g`标志会被忽略

### `replace()`

`replace()`方法执行替换操作。它第一个参数接受一个正则表达式，第二个参数接受一个替换字符串。

它搜索调用它的字符串，寻找与指定模式匹配的文本。如果正则表达式带`g`标志，会用替换字符串中的所有匹配项，否则，值替换第一个匹配项。

同样的，如果第一个参数不是正则表达式，它会先把这个参数传给`RegExp()`构造函数。

~~~js
"java".replace(/a/g,"e"); // "jeve"
~~~

如果模式使用分组匹配，可以在替换字符串中使用`$n`的格式，其中n为数字，表示模式匹配指定子表达式的匹配结果，例如：

~~~js
 "keep it".replace(/(it)/,"<$1>"); // "keep <it>"
~~~

如果`RexExp`中使用的是命名捕获组，可以使用名字来引用匹配的文本：

~~~js
"keep it".replace(/(?<flag>it)/,"<$<flag>>"); // "keep <it>"
~~~

除了给`replace()`传替换字符串，还可以传一个函数，这个函数会被调用以计算替换的值。

这个替换函数接受以下参数：1、匹配到的整个文本，2、如果RexExp有捕获组，则后面几个参数分别是这些捕获组匹配的子字符串。3、再然后是字符串找到匹配项的位置。4、再然后是调用`replace()`方法的整个字符串。5、最后，如果`RexExp`包含命名捕获组，还会接受一个对象参数，这个参数属性名是捕获组的名字，属性值是匹配的文本

~~~js
"441678514@qq.com".replace(/(?<username>\w*)@(?<domainName>\w*\.\w*)/,replacer);
~~~

在这个表达式中，`replacer`这个函数将接收到以下函数：

~~~js
Array(6) [441678514@qq.com,441678514,qq.com,0,441678514@qq.com,Object]
~~~

其中，最后一个对象是：

~~~js
{
  "username": "441678514",
  "domainName": "qq.com"
}
~~~

### `match()`

`match()`接收一个正则表达式参数，返回一个数组，其中包含匹配的结果，如果没有找到匹配项，就返回`null`

如果正则表达式有`g`标志，会进行全局搜索，并且忽略捕获组，只返回匹配项：

~~~js
"441678514@qq.com wangzimign@gmail.com"
    .match(/(?<username>\w*)@(?<domainName>\w*\.\w*)/g);
// Array(2) [441678514@qq.com,wangzimign@gmail.com]
~~~

如果正则表达式没有`g`标志，不会进行全局搜索，此时如果有捕获组，返回的数组中的第一个元素是匹配的字符串，剩下的所有的元素是正则表达式中括号分组的捕获组匹配的子字符串。

~~~js
"441678514@qq.com wangzimign@gmail.com"
    .match(/(?<username>\w*)@(?<domainName>\w*\.\w*)/);
// Array(3) [441678514@qq.com,441678514,qq.com]
~~~

并且返回的结果数组有额外的几个属性：

* `index`匹配项的第一个字符的索引
* `input`进行匹配的整个字符串
* `groups`如果有命名捕获组，捕获组名称会成为这个对象的属性，值为捕获组匹配的字符串。

~~~js
let url = /(?<protocal>\w+):\/\/(?<host>[\w.]+)\/(?<path>\S*)/;
let text = "My blog at https://www.example.com/~david";
let match = text.match(url);
let index = match.index; //11
let input = match.input; // My blog at https://www.example.com/~david
let groups = match.groups; // {"protocal": "https","host": "www.example.com","path": "~david"}
~~~

### `matchAll()`

`matchAll`是ES2020中定义的。它接收一个带g标志的正则表达式。返回一个迭代器。

这个迭代器琪每次迭代产生一个与使用`match()`时传入非全局RegExp得到的匹配对象相同的对象。

~~~js
let matches = "441678514@qq.com wangzimign@gmail.com"
    .matchAll(/(?<username>\w*)@(?<domainName>\w*\.\w*)/g);

for (let match of matches){
    console.log(match.groups.username + "--" + match.groups.domainName);
}
~~~

这段程序输出下面内容：

~~~
441678514--qq.com
wangzimign--gmail.com
~~~

### `split()`

`split()`方法使用传入的参数作为分隔符，将字符串拆分为子字符串保存在一个数组中。它可以接收一个字符串作为参数，也可以接收一个正则表达式参数：

~~~js
let s = "123,456,789".split(","); // ["123","456","789"]
let s1 = "1, 2, 3,\n4,5".split(/\s*,\s*/); // ["1","2","3","4","5"]
~~~

## RegExp类

`RegExp()`构造函数接收一个或两个字符串参数，创建一个新的`RegExp`对象。第一个参数是包含正则表达式主体的表达式，第二个可选参数指定正则表达式的标志。

`RegExp()`构造韩式主要用于动态创建正则表达式。

### 属性

* `source`：只读属性，包含正则表达式的源文本
* `flags`:只读属性，包含指定RegExp模式的一个或多个字母

* `lastIndex`：用于指定下一次匹配的起始字符位置。

除此之外，它还有代表了各个模式的布尔属性：

| 属性       | 标志 |
| ---------- | ---- |
| global     | g    |
| ignoreCase | i    |
| multiline  | m    |
| dotAll     | s    |
| unicode    | u    |
| sticky     | y    |

### 方法

`exec()`方法是使用正则表达式最通常、最强大的方法。该方法接收一个字符串参数，并从这个字符串寻找匹配。

如果没有找到匹配项，则返回null。如果找到了匹配项，则返回一个数组。这个数组和字符串的`match()`方法在非全局搜索时返回的数组一样。

与`String`的`match()`方法不同，`exec()`方法无论正则表达式是否设置了`g`标志都会返回相同的数组。

但通过`lastIndex`属性，可以多次调用`exec()`方法实现类似遍历匹配的操作：

如果设置了`g`标志，`lastIndex`属性决定从哪里开始查找匹配。对一个新创建的`RegExp`对象来说，它的`lastIndex`为0.每次`exec()`成功执行，找到一个匹配项，都会更新RegExp的`lastIndex`属性，将其改写为匹配文本之后的第一个字符的索引。如果`exec()`没有找到匹配项，它会将`lastIndex`重置为0.

所以我们多次调用`exec()`方法，以找到字符串中所有的匹配项。

~~~js
let regexp =  /(?<username>\w*)@(?<domainName>\w*\.\w*)/g;
let text = "441678514@qq.com wangzimign@gmail.com";
let match ;

while ((match = regexp.exec(text)) !== null){
    console.log(match.groups.username + "--" + match.groups.domainName)
}
~~~

这段程序输出：

~~~
441678514--qq.com
wangzimign--gmail.com
~~~

# 日期和时间

`Date`类是JS中用于操作日期和时间的API。使用`Date()`构造函数可以创建一个日期对象。

在不传参数的情况下，会返回一个表示当前日期和时间的`Date`对象

如果传入一个数值参数，`Date()`构造函数会将其解释为自1970年至今经过的毫秒数

如果传入一个或多个整数参数，会被解释为本地时区的年、月、日、时、分、秒和毫秒：

~~~js
let d1 = new Date(); //"2023-11-20T06:55:03.281Z" UTC时区
let d2 = new Date(0); // "1970-01-01T00:00:00.000Z" UTC时区
let d3 = new Date(2100, 0, 1, 2,3,4,5); // "2099-12-31T18:03:04.005Z" UTC时区
~~~

在使用多个参数调用时，`Date()`构造函数会使用本地计算机的时区解释它们。如果想以UTC指定日期和时间，可以使用`Date.UTC()`。

这个接收和`Date()`构造函数相同的参数，但使用UTC来解释它们，并返回毫秒时间戳：

~~~js
let utcTime = new Date(Date.UTC(2012,1,1,12,0,0,0)); // "2012-02-01T12:00:00.000Z" UTC时区
let localTime = new Date(2012,1,1,12,0,0,0); // "2012-02-01T04:00:00.000Z" UTC时区
~~~

如果想要打印日期，默认会以本地时区打印。如果想以UTC显式日期，应该使用`toUTCString()`和`toISOString()`转换它。

如果给`Date()`构造函数传入字符串，它会尝试按照日期和时间格式来解析该字符串。这个构造函数可以解析`toString()`、`toUTCStrign()`和`toISOString()`方法产生的格式：

~~~js
let date = new Date("Wed Feb 01 2012 20:00:00 GMT+0800 (中国标准时间)"); //"2012-02-01T12:00:00.000Z"
~~~

可以通过多个方法获取或设置这个对象的年、月、日、时、分、秒和毫秒字段。这个方法都有两种形式，一种使用本地时间获取和设置，另一种使用UTC时间获取和设置。例如，要获取和设置一个Date对象的年份，可以使用：

`getFullYear() getUTCFullYear() setFullYear() setUTCfullYear()`

要获取或设置其他字段将方法中的`FullYear`替换为"Month","Date","Hours","Minutes","Seconds","Milliseconds"即可。

其中一些方法允许我们一次性设置多个字段.`setFullYear()`和`setUTCFUllYear()`可以可选地设置月和日。

`setHours`和`setUTCHours()`可以指定分钟、秒和毫秒字段。

## 时间戳

JS在内部将日期表示为整数，代表从1970年1月1日0点起的毫秒数

`getTime()`和`setTime()`用于获取和设置这个时间戳：

~~~js
date.setTime(date.getTime()+30000); //为这个对象添加30s
~~~

静态的`Date.now()`用于返回当前时间的时间戳，返回整数值，经常用于度量代码运行时间。

## 日期计算

`Date`对象可以使用JS标准的`< <= > >= `等比较操作符进行比较。两个`Date`对象也可以进行减法操作，以确定时间差。

这本质上是因为`Date`对象定义的`valueOf()`方法返回的是时间戳的数值。

如果想要给Date对象加或者减指定单位的时间，可以使用`setDate()`、`setMonth()`和`setYear()`

~~~js
let date = new Date();  //"2023-11-20T07:46:21.321Z"
date.setMonth(date.getMonth()+3); //"2024-02-20T07:46:21.321Z"
~~~

## 格式化和解析日期字符串

Date类定义了一些方法，可以将日期转换为字符串：

~~~js
let date = new Date();
let s1 = date.toString(); //Mon Nov 20 2023 16:41:05 GMT+0800 (中国标准时间)
let s2 = date.toUTCString(); //Mon, 20 Nov 2023 08:41:05 GMT
let s3 = date.toLocaleDateString(); //2023/11/20
let s4 = date.toLocaleTimeString(); //16:41:05
let s5 = date.toISOString(); //2023-11-20T08:41:05.748Z
~~~

# Error类

