# Web编程基础

我们需要了解如何编写Web应用中的JS程序，如何将这些程序加载到浏览器，以及如何获取输入、产生输出，如何运行响应事件的异步代码。在浏览器上运行的JS我们一般称为客户客户端JS程序。

## `<script>`标签中的JS

浏览器显示HTML文档，需要在HTML文档中包含后者引用JS代码，才能执行它。这就需要HTML`script`标签

JS可以通过`<sript>`标签嵌入html文档中，例如：

~~~html
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <script >
        alert(1)
    </script>
</head>
~~~

但是更常见的方式是使用`<script>`标签的src属性引用JS代码：

~~~html
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <script src="demo.js" type="text/javascript"></script>
</head>
~~~

使用src引用js文件有如下优点：

* 简化HTML文件，实现JS和页面的分离
* 可以实现JS文件代码的共享：让多个页面共享同一份JS代码
* 在浏览器中，当多个页面共享一份JS文件代码时，这个JS文件只需被下载一次
* src以任意URL为值，即可以是本地服务器的URL，也可以是其他服务商暴露的地址

如果要以模块方式引用JS文件，需要使用带`type="module"`属性的`<script>`标签来加载

### 脚本运行时机

在浏览器引入JS语言之初，还没有任何API可以遍历和操作已经渲染号的文档的结构和内容。JS代码唯一能够影响文档内容的方式，就是在浏览器加载文档的过程中动态生成内容。为此，JS使用`document.write()`方式在脚本所在位置向HTML中注入文本

现在已经不提倡使用`document.write()`生成内容了，但是由于还存在这种可能，所以浏览器在解析`<script>`的脚本的默认行为是必须要加载并运行脚本，就是为了确保不漏掉脚本可能输出的HTML内容，然后才能再继续解析和渲染文档。这有可能严重拖慢网页的解析和渲染过程。

这种默认行为可以通过`<script>`的`defer`和`async`属性来改变，这两个属性是布尔值。

* `defer`属性为true时，会让浏览器把脚本的执行推迟到文档完全加载和解析之后
* `async`属性会让浏览器异步加载脚本，这样不会阻塞文档解析。`async`必须在有`defer`属性时才起作用

带有`type="module"`属性的脚本默认会在文档加载完毕后执行。

如果不使用async和defer属性，可以选择把`<script>`标签放在HTML文件的末尾，这样就可以解析操作所有的文档内容了。

另外如果不是通过`src`引用的外部脚本，而是直接通过`<script>`内嵌的脚本，则`defer`属性无效

## 文档对象模型

客户端JS编程中最重要的一个对象就是Document对象，它代表浏览器窗口或标签页中显示的HTML文档。

用于操作HTML文档的API被称为文档对象模型(Document Object Model,DOM)

DOM API于HTML文档的树形结构一一对应。文档中的每个HTML标签都有一个对应的JavaScript Element对象，而文档中的每一行文本都有一个与之对应的Text对象。Element和Text类，以及Document类本身，都是一个更通用的Node类的子类。各种Node对象组合形成一个树形结构，JS可以使用DOM API对其进行查询和遍历。

DOM API包含创建新Element和Text结点的方法，也包含把它们作为其他Element对象的孩子插入文档的方法。还有用来在文档中移动元素的方法，以及把它们从文档中删除的方法。

每个HTML标签类型都有一个与之对应的JS类，文档中出现的每个标签在JS中都有对应类的一个实例表示。

例如`<body>`标签由`HTMLBodyElement`的实例表示。`<table>`标签由`HTMLTableElement`的实例表示。

这些元素对象都有于HTML标签属性对应的属性。在JS中修改属性的值，也会改变HTML属性的值。

有些元素也定义了额外的方法。比如，`HTMLAudioElement`和`HTMLVideoElement`类都定义了`play()`和`pause()`方法用于控制音频和视频文件的回放。

## 浏览器中的全局对象

每个浏览器窗口或标签页都有一个全局对象。在一个窗口中运行的所有JS代码(不包括在工作线程中运行的代码)都共享一个全局对象。

所以文档中所有脚本和模块共享一个全局对象，如果有脚本在全局对象上定义了一个属性，则改属性对其他所有脚本可见。

全局对象定义了JS标准库，比如`Math`对象，`Set`类，`parseInt()`函数等。

在浏览器中，全局对象页包含各种Web API的主入口，比如：document属性表示当前显示的文档，`fetch()`方法用于发送HTTP网络请求，`Audio()`构造函数允许JS程序播放声音。

在浏览器中，全局对象具有双重角色。它既时定义JS语言内置类型和函数的地方，也代表当前浏览器窗口定义了`history`和`innerWidth`等Web API的属性。

全局对象的属性中有一个属性叫`window`，它的值就是全局对象本身。所以我们可以直接通过`window`引用全局对象。

在使用窗口特定的功能时，最好加上window前缀。比如写`window.innerWidth`比只写`innerWidth`更明确。

## 脚本命名空间

在模块中，定义在模块顶级的常量、变量、函数和类时模块私有的，除非它们被明确地导出。

但在非模块脚本中，如果在顶级脚本中定义了一个常量、变量、函数或类，则改声明将对同一文档中的所有脚本可见。既它们共享一个命名空间

这种特性在大型程序中会有命名冲突的麻烦，特别是在某些脚本还是第三方库的情况下。

这个共享的命名空间在运行时有一些历史遗留问题。比如，顶级的`var`和`function`声明会在共享的全局对象上创建属性。而使用ES6中`const`、`let`和`class`的顶级声明则不会在全局对象上创建属性。

## JS程序的执行

客户端JS中没有程序的正式定义，但我们可以说JS程序由文档中包含和引用的所有JS代码组成。这些分开的代码共享一个全局Window对象，访问同一个底层Document对象。不是模块的脚本还额外共享同一个顶级命名空间。

如果网页中有嵌入的窗口(`<iframe>`元素),被嵌入文档和嵌入它的文档中的JS代码拥有不同的全局对象和Document对象，可以看成两个不同的JS程序。

但是关于JS程序的边界是没有正式定义的。如果包含文档和被包含文档是从同一个服务器加载的，则一个文档中的代码就能和另一个文档中的代码交互。

我们可以将JS程序的执行想象成发生了两个阶段：

* 第一阶段，加载阶段:文档内容加载完成，`<script>`元素指定的JS代码运行。脚本通常按照它们在文档中出现的顺序依次执行(但可以通过`async`和`defer`改变这一行为).任何一个脚本中的JS代码都自上而下运行
* 第二阶段，事件驱动阶段：当文档加载完毕且所有脚本都运行后，JS执行进入第二阶段。这个阶段是异步的、事件驱动的。如果脚本要在第二阶段执行，那么它在第一阶段必须至少注册一个将被异步调用的事件处理程序或者其他回调函数。第二阶段代码通常是为响应用户操作(鼠标点击，敲击键盘等)而被调用。

事件驱动阶段发生的第一次事件主要由`DOMContentLoaded`和`load`。

`DOMContentLoaded`在HTML文档被完全加载和解析后触发。而`load`事件在所有文档的外部资源(如图片)都完全加载后触发。

JS程序经常使用这两个事件作为触发器或启动信息。

JS的加载阶段相对较短，一般少于1s。文档加载一完成，事件驱动阶段将在浏览器文档的过程中一直持续。

### 客户端JS的线程模型

JS是单线程语言，这意味着浏览器会在脚本和事件处理程序执行期间停止响应用户输入。所有我们需要保证JS脚本和事件处理程序不会长时间运行。否则，可能导致文档加载延迟，浏览器没有响应，导致用户以为程序已经崩溃。

Web平台定义了受控的编程模型，既Web工作线程。工作线程是一个后台线程，可以执行计算密集型任务而不冻结用户界面。工作线程中运行的代码无权访问文档内容，不会于主线程和其他工作线程共享任何状态，只能通过异步消息事件于主线程或其他工作线程通信。所有这种多线程不会有线程安全的问题

### 客户端JS时间线

前面介绍了JS程序加载和执行的处理阶段。具体可以细分为下列步骤：

* 浏览器创建Document对象并开始解析网页，随着解析，不断向文档中添加Element对象和Text节点。此时,`document.readyState`属性的值是`loading`

* HTML解析器在碰到一个没有`async`、`defer`或`type="module"`属性的`<script>`标签时，会把该标签添加到文档中，然后加载并执行其中的脚本。脚本的加载和执行是同步的，在脚本下载和运行期间，HTML解析器会暂停。

  类似这样的脚本可以使用`document.write()`向输入流中插入文本，该文本在解析器恢复时将会称为文档的一部分。

  这样的脚本只能看到它自己的`<script>`标签以及该标签之前的内容

* 解析器在碰到一个有`async`属性的`<script>`元素时，会异步下载该脚本的代码，并继续解析文档(既加载脚本不阻塞文档解析)。脚本在下载完成后会尽快执行，但计息期不会停下来等待它下载。

  这样的异步脚本必须不能使用`document.write()`方法。

* 在文档解析完成后，`document.readState`属性变为`interactive`
* 任何有`defer`属性的脚本都会在按照它们在文档中出现的顺序依次执行
* 浏览器在`Document`对象派发`DOMContentLoaded`事件。标志着程序执行从同步脚本执行阶段过渡到异步的事件驱动阶段。但要注意，此时仍然可能存在尚未执行的async脚本
* 文档已经完全解析，但浏览器可能仍然在等待其他内容(如图片)加载。当所有外部资源都加载完成，且所有async脚本都加载并执行完成时，`document.readyState`变为`complete`，浏览器在Window对象上派发`load`事件
* 接下来，浏览器开始异步调用事件处理阶段。

## 程序输入和输出

和其他程序一样，客户端JS程序也处理输入数据，产生输出数据。输入的来源有很多：

* 文档的内容本身，和附带的其他信息(如文档的URL和Cookie)可以通过DOM API来访问
* 事件形式的用户输入，如点击鼠标和输入文本
* 全局`navigator`属性暴露了关于浏览器、操作系统以及它们能力的信息。

客户端JS通常以借助DOM API 操作HTML文档的形式产生输出。或者使用`console.log()`及相关方法产生输出。

## 程序错误

与直接运行在操作系统上的应用程序不同，在浏览器中运行的JS程序不会真正”崩溃“。如果JS程序在运行期间出现异常，且没有catch语句处理它，开发者控制台将会显示一条错误消息，但任何已经注册的事件处理程序照样会继续运行和响应事件。

如果想要处理全局的所有未捕获异常，可以把Window对象的onerror属性设置为一个错误处理函数。当未捕获异常沿调用栈一路向上传播，最终`window.onerror`函数会以三个字符串参数被调用。

* 第一个参数描述错误的消息
* 第二个参数包含导致错误的JS代码的URL
* 第三个参数是文档中发生错误的行号

如果`onerror`处理程序返回true。则表示这个错误已经处理了，不会显示在控制台。

如果期约被拒绝而没有`.catch()`函数处理它，那么可以通过定义`window.onunhandledrejection`函数或者使用`window.addEventListener()`为`unhandledrejection`事件注册一个处理程序来发现它。这个监听器回调接收一个对象

传给这个处理程序的事件对象有promise属性，值为被拒绝的Promise对象，有reason属性，值为本来要传给`.catch()`函数的拒绝理由。如果调用对象的`preventDefault()`则浏览器认为错误已经处理，不会再控制台显示错误。

如果想要知道用户在使用时发生了哪些错误，可以使用这两种方式在回调中把错误上报给服务器

## Web安全模型

由于网页可以在客户的设备上执行任意JS代码，因此存在明显的安全隐患。所以浏览器厂商需要对JS做安全处理：防止恶意代码读取或者修改用户数据、侵犯用户隐私、欺诈用户或者浪费用户时间。

下面简单介绍Web平台的安全限制和已知问题

### JS代码不能做

浏览器对恶意代码的第一道防线就是不支持某些能力。例如，客户端JS不能向客户端计算机中写入或删除任何文件。

客户端JS没有通用的网络能力，虽然可以发送HTTP请求和WebSocket，但是只能和特定的服务器通信

### 同源策略

同源策略指的是对JS代码能够访问和操作什么Web内容的一整套限制。通常在页面中包含`<iframe>`元素时会涉及同源策略。同源策略控制一个窗口的JS和另一个窗口的JS的交互。比如，脚本只能读取和包含它的文档同源的Window和Document对象。

文档的源就是文档URL的协议、主机和端口。必须协议、主机和端口都相同的文档URL，文档才算是同源。

注意同源策略指的是脚本所在文档的源。而不是脚本自身的源。

同源策略也会应用到脚本发起的HTTP请求中。JS代码可以向托管其包含文档的服务器发起任意HTTP请求，但不能和其他服务器通信(除非浏览器开启了CORS)

同源策略对使用多子域的大型网站造成了麻烦。为了支持多子域名网站，脚本可以通过把`document.domain`设置为一个域名后缀来修改自己的源。

第二种缓解同源策略的技术是跨源资源共享(Cross-Origin Resource Sharing,CORS),它允许服务器决定对哪些源提供服务。

CORS扩展了HTTP协议，增加了新的`Origin:`响应头和`Access-Control-Allow-Origin`响应头。

服务器可以使用这个头部明确列出哪些源提供服务，或者使用痛批恶妇表示可以接收任何网站的请求。

浏览器通过这些CORS头部的有无决定是否放松同源限制

### 跨站点脚本

跨站点脚本(Cross-Site Scripting,XSS)是一种攻击方式，指攻击者向目标网站注入HTML标签和脚本。

如果网页的内容是动态生成的，比如说根据用户的提交生成内容，但没有对用户提交的数据进行任何审查。就有可能称为跨站点脚本的攻击目标。比如说用户输入的不是常规字符串，而是一串包含脚本调用的标签:`<img src="x.png" onload="unkownScript()">`

如果将这样的用户输入未经处理地加载到自己的页面上，在图片加载完成后，就会运行一段未知的恶意脚本。

之所以称为跨站点脚本攻击，是因为涉及不止一个网站：

网站B包含一个特殊编制的链接(带有标签和脚本的)，指向网站A。

如果网站B能够说服用户点击这个链接，用户就会导航到网站A，网站A就会运行来自网站B的代码。该代码可能会破环网站A的页面，或者读取A存储的cookie，并将该数据发送给网站B。

一般来说，防止XSS攻击的办法是从不可信数据中删除HTML标签，然后再使用。或者将不可信能够只能展示在`<iframe>`中，并将这个`<iframe>`的`sandbox`设置为禁用脚本和其他功能。

# 事件

和任意具有图形用户界面的应用一样，客户端JS程序使用异步事件驱动的编程模型。浏览器会在发生值得关注的事情时生成事件。例如，在加载完文档时，用户鼠标点击时，用户键盘输入时生成事件。

如果JS应用关注特定类型的事件，那么可以注册一个或者多个函数，让这些函数在该类事件发生时被调用。

在客户端JS中，事件可以在HTML文档上的任何元素上发生，所有事件模型比Node的事件模型更复杂。

接下来介绍和事件模型相关的重要定义：

* 事件类型：事件类型是一个字符串。表示发生了什么事件。例如`"mousemove"`表示用户移动了鼠标，`"keydown"` 表示用户按下了键盘上 某个键。`"load"`表示文档或其他资源通过网络加载完成。事件类型有时也称事件名称。
* 事件目标：事件目标是一个对象，而事件就发生在该对象上或者事件与该对象有关。`Window`、`Document`和`Element`对象是最常见的时间目标，例如一个`<button>`元素上发生了单击(click)事件。
* 事件处理程序或者事件监听器：事件监听器是一个函数，负责处理或响应事件。应用通过浏览器注册自己的事件处理程序，指定事件类型和事件目标。当在事件目标上发生指定类型的事件时，浏览器就会调用这个处理器。当事件处理程序在某个对象上被调用时，我们说浏览器“触发”，“派发”了该事件。
* 事件对象：事件对象是与事件关联的对象，包含有关该事件的细节。事件对象作为事件处理程序的参数传入。所有事件对象都有`type`和`target`属性，分别表示事件类型和事件目标。每个事件类型都为相关事件兑现定义了一组属性。比如，与鼠标事件相关的事件对象包含鼠标指针的坐标，与键盘事件相关的事件对象包含于被按下的键以及按住不放的修饰键的信息。
* 事件传播：事件传播是一个过程，浏览器会决定在这个过程中哪些对象触发事件处理程序。HTML文档的元素是嵌套的，如果在一个`<a>`标签上移动鼠标，同时也意味着在`<a>`标签所在的标签移动鼠标，最终在`document`上移动鼠标。所以有些事件需要沿着HTML文档的树形结构向上冒泡，直到根节点`document`。事件处理程序可以阻止事件传播，从而让事件不再冒泡。另一种形式的事件传播是事件捕获：注册在包含元素上的处理程序在事件被发送到实际目标之前，有机会拦截(或捕获)事件。

## 事件类别

客户端JS支持的事件类型非常多。我们只将这些事件分成通用的类别，不详细介绍每个事件。

* 设备相关输入事件：这类事件直接于特定输入设备(如键盘鼠标)相关。如："mousedown", "mousemove", "mouseup", "touchstart", "touchmove", "touchend", "keydown" "keyup"等等
* 设备无关输入事件：这类事件不与特定输入设备直接相关。比如"clikc"事件表示一个链接或者按钮已经被激活。一般来说，这个事件由鼠标触发，但也可能通过键盘或在触摸屏上通过轻击触发。而"input"事件既支持键盘输入，也支持剪切粘贴和表意文字的输入法。"pointerdown","pointermove",和"pointerup"事件既支持鼠标类型的指针也适用于触屏和手写笔输入。
* 用户界面事件：UI事件是高级事件，通常在定义应用界面的HTML表单元素上触发。比如："focus"(当文本输入字段获得键盘焦点时)、"change"(当用户修改了表单元素显示的值时)和"submit"(当用户单击表单中的提交按钮时)
* 状态变化事件：有些事件并不直接由用户活动触发，而是由网络或浏览器活动触发。这类事件表示生命周期或者状态的变化。其中最常用的两个事件时分别由`Window`和`Document`对象在文档加载结束时触发的`load`和`DOMContentLoaded`事件。浏览器会在网络连接发生变化时在`Window`对象上触发`online`和`offline`事件。浏览器的历史管理机制会触发`popstate`事件作为对浏览器”后退“按钮的回应

* API特定事件一些HTML和Web API包含自己的事件类型，HTML的`<video>`和`<audio>`元素定义了一些列事件，例如"waiting", "playing" ,"seeking", "volumechange"等。

## 注册事件处理程序

有两种注册事件处理程序的方式。第一种是设置作为事件目标的对象或文档元素的一个属性。第二种更通用的方式是把处理程序传给对象或元素的`addEventListener()`方法

### 设置事件处理程序属性

可以把事件目标的一个属性设置为关联的事件处理程序函数。这样的属性的名字都由on和事件名称组成。例如：`onclick`、`onchange`、`onload`等等。这些属性名区分大小写，且必须全部小写，即使包含多个单词。例如：

~~~js
document.querySelector("#btn").onclick = function () {
    alert("点击了一个按钮")
}
~~~

设置事件处理程序属性的缺点就是每个事件目标对每种事件最多只有一个处理程序。

事件处理程序属性也可以直接在HTML文件中组为对应HTML标签的属性来定义(要注册Window元素上的处理程序可以定义在`<body>`)，属性的值用改是JS代码字符串。这段代码通常是函数调用表达式，例如：

~~~html
<button id="btn" onclick = "clickBut()">按钮</button>
~~~

如果有多条语句，需要用分号分开

~~~html
<button id="btn" onclick = "cosole.log('Thank you') ; alert('Thank you');">按钮</button>
~~~

在这段JS代码字符串中，可以通过它引用当前的事件对象

### `addEventListener()`

任何可以作为事件目标的对象都定义了一个名为`addEventListener()`的方法，可以使用它俩注册目标为调用对象的事件处理程序。

这个方法接收三个参数：第一个参数是注册处理程序的事件类型字符串。第二个参数是作为事件处理程序的函数。第三个参数是可选的，后续介绍。一个示例如下：

~~~js
document.querySelector("#btn").addEventListener("click",btnClickListener)
function btnClickListener(){
    alert("点击了一个按钮")
}
~~~

可以在同一个事件目标上多次调用`addEventListener()`函数注册监听器。事件触发时会按照监听器的注册顺序执行多个监听器。

对应的`removeEventListener()`方法可以从一个对象上移除事件监听器。它的前两个参数和`addEventListener()`一样。这样我们可以临时注册一个事件监听器，然后后续移除它。

`addEventListener()`可选的第三个参数是一个布尔值或对象。如果传入true，函数就会被注册为捕获事件处理程序，从而在事件派发的另一个阶段调用它。如果注册监听器是第三个参数传了true，那么移除事件时，第三个参数也要传true。

可以给第三个参数传一个对象，显示指定选项：

~~~js
document.querySelector("#btn").addEventListener("click",btnClickListener,{
    capture: true,
    once: true,
    passive : true
})
~~~

如果capture属性为true，那么函数就会被注册为捕获处理程序，和第三个参数直接传true一样。默认为false

如果once属性为true，那么事件监听器被触发依次后自动移除。默认为false

如果passive属性为true，则表示事件处理程序永远不调用`preventDefault()`取消默认动作，这对于移动设备上的触摸事件很重要

## 调用事件处理程序

注册事件处理程序后，浏览器会在指定对象发生指定事件时自动调用它。接下来介绍事件处理程序的细节，如监听器函数的参数，上席文和返回值的含义

### 事件监听器的参数

事件处理器被调用时接收一个Event对象作为唯一的参数。这个Event对象的属性提供了事件的详细信息：

* `type`：发生事件的类型
* `target`：发生事件的对象
* `currentTarget`：对于传播的事件，这个属性是注册当前事件处理程序的对象
* `timeStamp`表示事件发生时间的时间戳(ms),不是绝对时间
* `isTrusted`，如果这个事件由浏览器派发，则这个属性为true，如果事件由JS代码派发，这个属性为false

### 事件监听器的上下文

事件监听器在被调用时，以注册事件监听器的目标对象作为上下文this值的。不论通过`addEventListener()`注册，还是通过事件监听属性`onxxx`注册。

但是，这不适用于箭头函数。对于箭头函数形式的事件监听器，其`this`值始终等于定义它的作用域的this值。

### 事件监听器的返回值

在现代JS中，事件处理程序不应该由返回值。但在比较老的代码中，事件监听器可能会有返回值，这个返回的值通常用于告诉浏览器不要执行于事件相关的默认动作。比如，如果一个表单submit按钮的onclick监听器返回false，浏览器将不会提交表单。

而阻止浏览器执行默认动作的标准且推荐的方式，是调用`Event`对象的`preventDefault()`方法，后续会介绍。

### 调用顺序

一个事件目标上注册多个监听器时。当事件发生时，浏览器会按照它们的注册顺序调用它。即使混合使用`addEventListener()`注册和对象属性的`onxxx`注册，结果同样如此。

## 事件传播

如果事件的目标是Window或者其他独立对象，浏览器对这个事件的响应就是简单地调用该对象上对应的监听器。但如果事件目标是Document或者其他文档元素，就没有那么简单了。

注册在目标元素上的事件监听器在被调用后，多数事件会沿DOM树向上”冒泡“。目标父元素的事件监听器会被调用。这样一直往上到Document对象，然后到Window对象。

有了事件冒泡，我们就可以不用给个别文档元素注册很多事件处理程序，只需要在它们公共祖父元素上注册一个时间处理程序。

多数文档元素上发生的事件都会冒泡。明显的例外是"focus" "blur" 和"scroll"事件。文档元素的"load"事件冒泡，但是到Document对象就会停止，不会传播到Window对象。

在目标监听器被调用之前，事件可以被捕获。当`addEventListener()`的第三个可选参数为true或者其option对象的capture为true时，这个监听器就会被注册为捕获监听器。

而捕获的顺序和冒泡相反，最先被调用的捕获监听器是`Window`对象上的，然后时Document对象的，然后沿着DOM树一直往下，直到事件目标父元素的捕获监听器被调用。注册在事件目标本身的捕获事件监听器并不会被调用。

也就是说，在一个事件发生，被处理之前，会从DOM树的根开始被其目标的父元素注册的捕获事件监听器捕获。

## 事件取消

浏览器默认对很对用户事件都会做出响应，无论是否在代码中指定。比如

* 用户在一个链接上单击鼠标，浏览器就会跟随该链接
* 如果一个HTML文本输入元素获得了键盘焦点，而且用户按了某个键，就浏览器就会打出用户的输入
* 如果用户在触摸屏上滑动手指，浏览器就会滚动

我们可以阻止浏览器执行这样的默认响应。方法时在目标上注册事件处理程序，在处理程序中调用事件对象的`preeventDefault()`方法，就可以阻止浏览器执行默认响应(除非监听器的passive属性为true)

取消于事件关联的默认动作时事件取消的一种情况。除此之外，还可以调用事件对象的`stopPropagation()`方法，取消事件传播。

`stopPropagation()`可以在捕获阶段，以及在冒泡阶段起作用。但不会阻止同一对象上的其他监听器的调用

`stopImmediatePropagation()`于`stopPropgation()`类似，但它也会阻止在同一个对象上注册的后续事件处理程序的执行。

## 派发自定义事件

JS事件API能够定义和派发自己的事件。

如果一个目标对象除了`addEventListener()`、`removeEventListener()`方法，还有`dispatchEvent()`方法，它接收一个事件对象，表示目标派发了这个事件。我们可以通过`CustomEvent()`构造方法创建事件对象。这样，我们就可以派发自定义事件了。

`CustomEvent()`的第一个参数是一个字符串，表示事件类型；第二个参数是一个对象，用于指定事件对象的属性。这个对象有如下属性：

* detail ：添加给事件对象的额外信息，监听器可以通过事件的detail属性获取
* bubbles：表示该事件是否能冒泡
* cancelable：表示该事件是否能取消
* composed：事件是否会触发阴影DOM根节点之外的事件监听器，默认为false

我们在Document上注册一个自定义的监听器，首先为自定义的事件注册监听器：

~~~js
document.addEventListener("selfDefinitionEvent",listener)
~~~

然后手动调用`dispatchEvent()`派发这个事件，触发监听器：

~~~js
document.dispatchEvent(new CustomEvent("selfDefinitionEvent",{detail:true}))
~~~

# 操作DOM

通过脚本操作网页时JS的核心目标。 而DOM API为这个目标提供支持

每个Window对象都有一个document属性，引用一个Document对象，这个Document对象代表窗口的内容，它时DOM中表示和操作文档内容的核心内容

## 选择Document元素

客户端JS程序经常要操作文档中的一个或者对各元素。全局document属性引用Document对象，而Document对象向下延申出以Element对象为节点的树形结构对应文档的嵌套元素。首先必须通过某种方式获取或者选择表示文档元素的Element对象。

### `querySelector()`

DOM方法`querySelector()`和`querySelectorAll()`可以通过CSS选择语法来在文档中找到匹配的元素

`querySelector()`方法接收一个CSS选择符字符串作为参数，返回它在文档中找到的第一个匹配的元素，如果没有找打，则返回null：

~~~js
document.querySelector("#myId")
~~~

`querySelectorAll()`方法类似，但是它返回文档中匹配的所有元素，而不是只返回第一个：

~~~js
let divs = document.querySelector(".div");
~~~

`querySelectorAll()`的返回值不是Element对象的数组，而是一个类似数组的NodeList对象，可以像数组一样通过索引访问，所以可以用传统的for循环遍历。NodeList也是可迭代对象，因此也可以用`for/of`循环中使用。

如果文档中没有与指定选择符匹配的元素，则`querySelectorAll()`返回的NodeList的length属性为0

Element类和Document类都实现了`querySelector()`和`querySelectorAll()`当在元素上调用时，这两个方法只查找返回该元素后代中的元素。

注意，用CSS的伪类选择器调用这两个方法将什么也得不到，既不支持伪类选择器。

### `closest()`

`closest()`方法也是基于CSS选择器的，这个方法时Element类定义的，以一个选择符作为唯一参数。如果选择符匹配那个调用它的元素，则返回该元素，否则就返回与选择符匹配的最近祖先元素，如果没有匹配，则返回null。

所以`closest()`可以看成`querySelector()`的逆向操作：`closest()`从当前元素开始，沿DOM树向上匹配，而`querySelector()`则从当前元素开始，沿DOM树向下匹配。

### 其他选择元素的方法

除了`querySelector()`和`querySelectorAll()`，DOM也定义了一些老式的元素选择方法：

* `getElementById()`
* `getElementsByClassName()`
* `getElementsByName()`
* `getElementsByTagName()`

通过匹配标签的id/class/name/tagName获取元素

## 文档结构

从Document中选择一个Element之后，常常还需要查找文档结构中相关的部分(父节点、兄弟节点、孩子节点)

Element对象提供一组属性。这些属性引用当前元素的相关节点：

* `parentNode`,引用元素的父节点
* `children`是HTMLCollection，包含元素的所有子元素，不含非Element节点，如Text节点
* `childElementCount`元素的所有子元素的个数，与`children.length`返回的值相同
* `firstElementChild`、`lastElementChild`，分别引用元素的第一个子元素和最后一个子元素，如果没有子元素，它们的值为null
* `previousElementSibling`、`nextElementsibling`这两个属性分别引用元素前一个和后一个兄弟元素，如果没有同辈元素则为null

这样我们可是使用一些常规的深度优先、广度优先遍历算法来遍历整个DOM树

如果在遍历文档或文档中某些部分时不想忽略Text节点，可以使用另一组在所有Node对象上都有定义的属性。通过这些属性可以看到Element、Text节点，甚至Comment节点(表示文档上的HTML注释)

所有Node对象都定义了一下属性：

~~~js
parentNode: ParentNode | null; //当前节点的父节点
childNodes: NodeListOf<ChildNode>; //只读的NodeList对象，包含节点的所有子节点
firstChild: ChildNode | null; //节点的第一个孩子节点
lastChild: ChildNode | null; //节点的最后一个孩子节点
nextSibling: ChildNode | null; // 节点的后一个兄弟节点
previousSibling: ChildNode ; //节点的前一个兄弟节点
nodeType: number; //表示当前节点类型的数值，Document节点值为9，Element节点值为1，Text节点值为3，Comment节点的值为8
nodeValue: string | null; //Text或Comment节点的文本内容
nodeName: string; //Element节点的HTML标签名，会转换为全部大写
~~~

## 属性

HTML元素由标签名和一组称为属性的名/值对构成。

Element类定义了通用的`getAttribute()`、`setAttribute()`、`hasAttribute()`和`removeAttribute()`方法用于访问和操作元素的属性。

但HTML元素的属性(标准HTML元素的标准属性)同时也表示在这些元素的HTMLElement对象上具有相应的属性。通过JS属性来获取它们，通常要比调用`getAttribute()`和其他方法更便捷：

~~~js
let img = document.querySelector("#img");
img.src = "www.xxx.com/xxx/.."
~~~

对于某些属性，例如`<input>`，有的HTML属性会映射到不同的JS属性。比如，`<input>`元素在HTML中的value属性对应到JS中是`defaultValue`属性。而JS中的value属性包含的是用户当前在`<input>`元素中输入的值。

有些HTML属性名是JS中的保留字，对于这些属性，通用规则是在对应的JS属性包含前缀`html`，比如`<label>`元素在HTML中的for元素，对应JS中的`htmlFor`属性。`class`也是JS的保留字，但这个HTML class 属性比较特殊，它在JS代码中会变成className

### class属性

HTML元素的class属性特别重要。它的值是空格分隔的CSS类命的列表，用于给元素应用CSS样式。由于class在JS中是保留字，所以这个HTML属性是通过Element对象上的className属性反映的。className值是一个字符串。但是我们通常把HTML class 当成一个列表，在这个列表中添加和删除某个类名是很常见的，而不是仅仅把它看作整个字符串。

为此，Element对象定义了classList属性，支持将class属性作为一个列表来操作。classList属性引用一个可迭代的类数组对象。定义了`add()`、`contains()`、`contains()`和`toggle()`方法

### dataset属性

有时候会需要在HTML元素上附加一些信息。这样JS代码在选择并操作相应的元素是可以使用这些信息。

在HTML中，任何以前缀`date-`开头的小写属性都被认为是有效的，可以将它们用于任何目的。这些数据集(dataset)属性不影响它们所在的元素的展示，在确保文档正确性的前提下定义了一种附加额外数据的标准方式。

在DOM中，Element对象有一个dataset属性，该属性引用的对象包含于HTML中的`date-`对应的属性，但不带这个前缀。也就是说dataset.x中保存的是HTML中data-x属性的值。而连字符份额的属性将映射为驼峰式属性名：HTML中的data-section-number会变成JS中的dataset.sectionNumber

如果文档中有如下元素：

~~~html
<h2 id="title" data-section-number="15.1">Attributes</h2>
~~~

那么可以通过如下方式访问：

~~~js
document.querySelector("#title").dataset.sectionNumber;
~~~

## 元素内容

接下来介绍如何擦偶哦元素内容的HTML表示和纯文本表示

### 作为HTML的内容

Element的innerHTML属性会返回该元素内容的标记字符串。在元素上设置这个属性会调用浏览器的解析器，并以新字符串解析后的表示替换元素当前内容。

设置innerHTML通常效率很高。不过使用`+=`操作符给innerHTML追加文本内容的效率不高。因为这个操作既涉及序列化操作，也会涉及解析操作：先把元素转换为字符串，然后再把新字符串转换为元素内容

注意：最好不要使用用户输入或者其他外部来源的内容设置innerHTML

Element的outerHTML属性于innerHTML属性类似，只是返回的值包含元素自身。在读取outerHTML是，该值包含元素的开始和结束标签。在设置元素的outerHTML时，新内容会取代元素自身。

Element提供`insertAdjacentHTML()`用于插入别调用的元素相邻的任意HTML字符串。这个方法接收两个参数，

* 第一个参数指定要插入的位置，有四个可选的字符串值：`beforebegin`、`afterbegin`、`beforeend`、`afterend`
* 第二个参数指定要插入的HTML内容

这四个可选的值具体的位置示意如下：

![image-20231229155543522](https://gitee.com/wangziming707/note-pic/raw/master/img/ElementinsertAdjacentHTMLPosition.png)

### 作为纯文本的内容

有时候需要得到元素的纯文本内容，或者向文档中插入纯文本。这样做的标准方法是使用textContent属性：

~~~js
let title = document.querySelector("#title");
let text = title.textContent;
title.textContent = "Hello World!";
~~~

这个textContent属性由Node类定义，所有在Textr节点和Element节点上都可以使用。对于Element节点，它会找到并返回元素所有后代中的文本

Element类定义了一个innerText属性，于textContent类似。但是innerText有一些少见和复杂的行为，如试图阻止表格格式化。这个属性的定义不严谨，浏览器间的实现也存在兼容性问题，因此不应该再使用了。

## 创建、插入和删除节点

Document类定义了创建Element对象的方法，而Element和Text对象拥有在树种插入、删除和替换节点的方法。

使用Document类的`createElement()`方法可以创建一个新元素。并通过Element自己的`append()`和`prepend()`方法为元素自己添加文本或者其他子元素。

注意：`createElement()`创建的仅仅是JS元素对象，不会同步在HTML文档中创建，如果要将创建的元素插入到HTML文档上，需要调用已有元素的`append()`或者`prepend()`方法：

~~~js
let p = document.createElement("a");
p.append("1234132")
document.body.append(p)
~~~

`append()`和`prepend()`接收任意多个参数，这些参数可以是Node对象或者字符串。字符串参数会自动转换为Text节点(也可以使用document.createTextNode()来创建Text节点，但很少需要这样做)。`append()`把参数添加到孩子列表的末尾。`prepend()`把参数添加到孩子列表的开头

如果想要在同辈位置插入节点，可以使用`befor()`和`after()`插入。

`before()`和`after()`同样接收任意个数的字符串和Node对象参数，在将字符串转换为Text节点后把它们全部插入文档中。

`append()`和`prepend()`只在`Element`对象上有定义，而`after()`和`before()`同时存在于Element和Text节点上。

注意，一个JS Element对象对应的HTML 元素表示只能被插入到文档中的一个地方，如果这个对应HTML元素已经在文档中了，把它插入其他地方时，它会转移到新位置，而不是复制一个新的过去。

如果确实需要创建一个元素的副本，可以使用`cloneNode()`方法，传入`true`以复制其全部内容

~~~js
greetings.after(paragraph.cloneNode(true));//创建paragraph的一个副本，再把它插入到greetings元素后面
~~~

一个节点调用`remove()`方法可以把自己从文档中删除，或者可以调用`replaceWith()`替换自己

`relpace()`方法不接受参数,`replaceWith()`和`before()`和`after()`一样，接收任意多个字符串和元素。

# 操作CSS

JS不止可以控制HTML文档的逻辑结构和内容，也可以通过对CSS编程，控制文档的外观和布局。

## CSS类

使用JS操作CSS样式的最简单的方式时给HTML标签的class属性添加或删除CSS类名。之前介绍`class`属性是已经提到，通过`classList`属性能很方便的实现此类操作。

假设已经定义了下面CSS类：

~~~css
.hidden {
    display:none;
}
~~~

那么通过下面js代码，可以控制隐藏指定元素：

~~~js
document.querySelector("#title").classList.add("hidden")
~~~

## 行内样式

HTML通过元素的style属性设置它自己的行内样式。DOM在所有Element对象上都定义了style属性。但是于大多数镜像属性不同，这个style属性不是字符串，而是`CSSStyleDeclaration`对象。`CSSStyleDeclaration`的属性名和值对应HTML style属性字符串中的键值对， 可以通过如下方法使用它操作样式：

~~~js
document.querySelector("#title").style.display = "none"
//相当于在style属性中写了 display: none;
~~~

**注意**很多CSS样式属性(如`font-size`)的名字中都包含连字符。而连字符在JS中会被解释成减号，因此不允许出现在属性名和其他标识符中。所以`CSSStyleDeclaration`对象的属性与CSS属性名不完全一样。对有连字符的CSS属性，会映射为驼峰式命名的属性名，例如`font-size`在`CSSStyleDeclaration`的属性名为`fontSize`

还有`CSSStyleDeclaration`的属性值都是字符串,例如：

~~~js
e.style.display = "block";
e.style.fontFamily = "sans-serif";
e.style.backgroundColor = "#ffffff";
~~~

有时候，以字符串而非`CSSStyleDeclaration`对象形式设置和读取行内样式会更方便。可以使用Element的`getAttribute()`和`setAttribute()`方法，或者使用`CSSStyleDeclaration`对象的cssText属性：

~~~js
e.style.cssText = "display: block; font-family: sans-serif; background-color: rgb(255, 255, 255);";
~~~

## 计算样式

一个元素的样式受 外联样式表、内联样式表等样式表和行内样式决定。

元素的计算样式是浏览器根据一个元素的行内样式和所有样式表中适用的样式规则计算得到的一组属性值，浏览器实际上使用哦个这组属性值来显示该元素。计算样式同样以`CSSStyleDeclaration`对象表示，但计算样式是只读的。

使用`Window`对象的`getComputedStyle()`方法可以获取一个元素的计算样式。这个方法的第一个参数是要查询的元素，可选的第二个参数用于指定一个CSS 伪元素。

~~~js
let e = document.querySelector("#title");
let computedStyle = window.getComputedStyle(e);
~~~

`getComputedStyle()`的返回值是一个`CSSStyleDeclaration`对象。这个对象和表示行内样式的`CSSStyleDeclaration`对象有重要区别：

* 计算样式的属性是只读的
* 计算样式的属性是绝对值：百分比和点等相对单位都被转换为了绝对值。
* 简写属性不会被计算。所以，不能查询`margin`属性，而是要查询`marginLeft`和`marginTop`等
* 计算样式的cssText属性是undefined

# 文档视图

到目前为止，我们一直将文档抽象为元素和文本节点构成的树形结构。但当浏览器在窗口中渲染文档时，它会创建文档的一个视觉表示，其中每个元素都有自己的位置和大小。

有时候我们需要知道某个元素精确的几何位置。这是可以做到的

## 文档坐标和视口坐标

文档元素的位置以CSS像素度量，其中x坐标向右表示增大，y坐标向下表示增大。但是坐标原点可以有两个

* 坐标原点可以在文档的左上角，在此坐标系上产生的坐标是文档坐标
* 也可以在文档的视口的左上角，在此坐标系上产生的坐标是视口坐标

在顶级窗口和标签页中，视口就是浏览器窗口中实际显示文档内容的区域。对于显示在`<iframe>`标签中的文档，由DOM中的内嵌窗格(iframe)元素定义嵌套文档的视口。

如果文档比视口小，或者如果文档没有被滚动或，则文档的左上角就位于视口左上角。此时文档坐标系和视口坐标系是相同的。

一般来说，文档坐标并不真正适合网页。因为CSS的overflow属性允许文档中的元素包含比它能显示的更多的内容。元素可以有自己的滚动条，并作为它们所包含内容的视口。所以Web允许在滚动文档中存在滚动元素，所以不能只使用一个(x,y)点描述元素在文档中的位置

所以JS也通常使用视口坐标

## 查询元素的位置

Element对象的`getBoundingClientRect()`方法可以确定当前元素的大小(包括CSS边框和内边距，包括外边距)和位置(在视口坐标中).

这个方法没有参数，返回一个`DOMRect`对象,该对象定义如下,这个对象有left、right、top、bottom、width和height属性

## 确定坐标所在元素

`getBoundingClientRect()`方法可以确定视口中某个元素的当前位置。但是有时候我们需要在视口上某个给定位置上是哪个元素。

可以使用`Document`对象的`elementFromPoint()`方法。这个方法传入一个视口坐标x和y。返回一个位于指定位置的Element对象

## 滚动

Window对象的`scrollTo()`方法接收一个点的x和y坐标(文档坐标),并据以设置滚动条的位移。也就是说，这个方法会滚动窗口，从而使让指定的点位于视口的坐标原点，左上角。如果这个点太接近文档底部或右边，浏览器会尽可能让指定的点接近左上角：

~~~js
let documentHeight = document.documentElement.offsetHeight; //文档高度
let viewportHeight = window.innerHeight; //视口高度
window.scrollTo(0,documentHeight - viewportHeight) //滚动到最后一页
~~~

Window对象的`scrollBy()`方法和`scrollTo()`类似，但它的参数是相对值，会在当前位置的基础上滚动：

~~~js
setInterval(()=> scrollBy(0,50),500) //每500ms向下滚动50像素
~~~

如果想让`scrollTo()`和`scrollBy()`平滑滚动，需要传入一个对象，而不是两个数值：

~~~js
window.scrollTo({
    left:0,
    top:documentHeight -viewportHeight,
    behavior: "smooth"
}) //滚动到最后一页
~~~

有时候，我们不是想让文档滚动到指定像素距离，而是想滚动到某个元素在视口上可见。我们可以在相应HTML元素对象上调用`scrollIntoView()`方法。这个方法保证在上面调用它的哪个元素在视口中可见。

默认情况下，滚动后的结果会尽量让元素的上边对其或者接近视口上沿。如果给这个方法传入唯一的参数false，则滚动后的结果会尽量让元素底边对其视口下沿。

同样可以给`scrollIntoView()`传入一个对象，设置`behavior:"smooth"`属性，以实现平滑滚动。设置block属性可以指定元素在垂直方向上如何定位，设置inline属性可以指定元素在水平方向上如何定位。这两个属性的有效值包括start、end、nearest和center

~~~js
let element = document.querySelector("#m3");
element.scrollIntoView({
    behavior:"smooth",
    block: "center",
    inline: "center"
});
~~~

## 视口大小、内容大小和滚动位置

浏览器窗口和一些HTML元素可以显示滚动的内容。在这种情况下，我们需要知道视口大小、内容大小和视口中内容的滚动位移。

对浏览器窗口而言，视口大小可以通过`window.innerWidth`和`window.innerHeight`属性获取

文档的整体大小和`<html>`元素，即`document.documentElement`的大小相同，可以通过其`offsetWidth`和`offsetHeight`属性获取其大小。

文档在视图中的滚动位移可以通过`window.scrollX`和`window.scrollY`获得。这两个属性是只读的

对元素来说，每个Element对象都定义了下列三组属性：

offsetXXX,offsetParent,clientXXX,scrollXXX

其中XXX可以是 Width,Height,Left,Top

元素的offsetWidth和offsetHeight属性返回它们在屏幕上的CSS像素大小。这个大小包含元素边框和内边距，不包括外边距。

元素的offsetLeft和offsetTOP属性返回元素左上角的x和y坐标。对大多数元素来说，这两个值都是文档坐标。但对定位元素的后代或者另一些元素(如表格单元)，这两个值是相对于祖先元素而非文档的坐标。

offsetParent属性保存前述坐标值是相对于哪个元素的。这一组属性都是只读的。

元素的clientWidth和clientHeight属性和offXXX属性类似，但是它们不包含元素边框，只包含内容区和内边距。

clientLeft和clientTop属性是元素内边距外沿到边框外沿的水平和垂直距离。对于行内元素(如`<span>`，`<i>`)而言它们都是0

元素的`scrollWidth`和`scrollHeight`属性是元素内容去大小加上元素内边框，再加上溢出内容的大小，在内容合适内容区没有溢出时，这两个属性等于`clientWidth`和`clientHeight`。

`scrollLeft`和`scrollTop`时元素内容在元素视口中的滚动唯一。这两个属性时可写属性，可以通过设置它们的值滚动元素中的内容。

多数浏览器中，Element兑现也跟Window对象一样也有scrollTo()和scrollBy()方法

# Web组件

HTML提供了丰富的标签，但是像`<input>`和`<button>`等简单的HTML标签已经不能满足现代UI设计的需要。我们可以使用它们，但是必须以CSS和JS来增强这些HTML标签的外观和行为。如果不借助其他框架和工具，每次使用一个标签，我们就可能需要定义它的CSS和JS。

现在的Web开发者会使用React、Angular框架，这些框架支持可重用的用户界面组件。

Web组件时浏览器原生支持可重用的用户界面组件的特性，主要涉及比较新的三个Web标准。

这些Web标准允许JS使用新标签扩展HTML，扩展后的标签就是自成一体的、可重用的UI组件。

## DocumentFragment节点

DOM API将文档组织成一个Node对象树，其中Node可以是Document、Element、Text节点或者Comment节点。

但这些节点都不能用来表示一个文档片段(多个节点的组合)，或者一组没有父节点的同辈节点。这时候可以使用DocumentFragment

DocumentFragment也是一种Node类型，可以临时充当一组同辈节点的父节点，方便将这些同辈节点作为一个单元来使用。

可以使用`document.createDocumentFragment()`来创建`DocumentFragment`节点。创建这个节点后，可以像使用Element一样，通过`append()`为它添加内容。

当向文档中插入`DocumentFragment`节点时，DocumentFragment本身不会被插入，实际上插入的是它的子节点。

## HTML模板

HTML的`<template>`标签可以对网页中频繁使用的标签进行优化。

`<template>`标签和其子元素不会被浏览器渲染，只能在使用JS的网页中使用。

当网页中包含多个重复的基本HTML结构时(比如表格行或Web组件的内部实现)，就可以使用`<template>`定义一次该结构，然后通过JS按照需要任意重复使用该结构。

在JS中，`<template>`标签对应一个`HTMLTemplateElement`对象，这个对象只定义了一个content属性，而这个属性的值是包含`<template>`所有子节点的`DocumentFragment`。可以克隆这个`DocumentFragment`，然后把克隆的副本插入文档中需要的地方。

作为一个使用示例，假设HTML文档中有如下标签：

~~~html
<template id="template">
    <tr>
        <td>1</td>
        <td>2</td>
    </tr>
    <tr>
        <td colspan="2">3</td>
    </tr>
</template>

<table id="t1" ></table>
<table id="t2" ></table>
~~~

通过js代码，可以把模板中的表格行插入t1和t2，注意插入一次就必须复制一次节点：

~~~js
let template = document.querySelector("#template");
let clone1 = template.content.cloneNode(true);
let clone2 = template.content.cloneNode(true);
document.querySelector("#t1").append(clone1);
document.querySelector("#t2").append(clone2);
~~~

这个模板元素并非只出现在HTML文档中才可以使用。也可以通过JS代码创建一个模板(DocumentFragment对象)，通过innerHTML或者`append()`创建其子节点，在按照需要克隆任意多个副本。这样还不必每次解析innerHTML。这也是Web组件中使用HTML模板的方式。

## 自定义元素

自定义要素是实现Web组件的浏览器特性之一，可以把一个HTML标签和一个JS类关联起来，然后文档中出现的这个标签就会在DOM树种转换为相应的类的实例。

创建自定义元素需要使用`customElements.define()`方法，这个方法以一个Web组件的标签名作为第一个参数(这个标签名必须包含一个连字符)，以一个HTMLElement的子类作为其第二个参数。文档种具有该标签名的元素会被升级为这个类的一个新实例。如果浏览器将来再解析HTML，都会自动为遇到的这个标签创建一个这个类的实例。

自定义元素类应该扩展HTMLElement，而不是HTMLElement的子类(如HTMLButtonElement)。所以如果自定义元素类有构造器，必须先调用`super()`，再干别的。

浏览器会自动调用自定义元素类的特定的生命周期方法：

* 当自定义元素被插入文档时，会调用`connectedCallback()`，很多自定义元素通过这个方法来执行初始化
* 当自定义元素从文档种移除时，会调用`disconnectedCallback()`，这个方法用的不多

可以为自定义类定义一个静态的`observedAttributes`属性用来为自定义的元素定义自己的自定义属性，其值时一个属性名的数组。如果`observedAttributes`中的属性再这个自定义元素上的一个实例上被设置或修改，浏览器会调用`attributeChangedCallback()`方法，传入属性名、旧值和新值。这个回调可以根据属性值的变化采取必要的操作以更新组件。

自定义元素类也可以按照需要定义其他属性和方法。一般它们会定义setter和getter方法，将自己的属性暴露出来。一遍调用方方便的修改元素。(需要再getter和setter方法中调用自己的getAttribute()和setAttribute()方法)

下面我们自定义一个行内圆圈的元素作为案例：

~~~js
class InlineCircle extends HTMLElement{
	//初始化元素
    connectedCallback() {
        this.style.display = "inline-block";
        this.style.borderRadius = "50%";
        this.style.border = "solid black 1px";
        this.style.transform = "translateY(10%)";
        if (!this.style.width){
            this.style.width = "0.8em";
            this.style.height = "0.8em";
        }
    }
	//指定自定义的属性
    static get observedAttributes() {return ["diameter","color"]}
	//当自定义属性被设置时，进行修改
    attributeChangedCallback(name,oldValue,newValue){
        if (name === "diameter"){
            this.style.width = newValue;
            this.style.height = newValue;
        } else if (name === "color"){
            this.style.backgroundColor = newValue;
        }
    }
	//暴露自定义属性，并使用getAttribute和setAttribute方法，所以当set方法被调用时，会触发attributeChangedCallback方法
    get diameter() {return this.getAttribute("diameter");}
    set diameter(diameter) {this.setAttribute("diameter",diameter);}
    get color() {return this.getAttribute("color");}
    set color(color) {this.setAttribute("color",color);}
}
//定义自定义元素并绑定对应类
customElements.define("inline-circle",InlineCircle);
~~~

## Shadow DOM

上一节中定义的自定义要素并没有很好的封装。例如，设置其diameter和color属性会导致其style属性被修改，而对于一个真正的HTML元素，这不是我们希望看到的行为。

要把一个自定义元素转换为真正的Web组件，还需要使用一个强大的封装机制：影子DOM(Shadow DOM)

影子DOM允许把一个“影子根节点”附加给要给自定义元素(也可以附加给一些标准HTML元素，如`<div>`，`<span>`等)。被附加了影子根节点的自定义元素就可以称为影子宿主。

影子宿主元素和所有HTML元素一样，随时可以作为包含后代元素和文本节点的正常DOM树的根。影子根节点则时另一个更私密的后代元素树的根，这些元素从影子根节点上生长出来，可以把它们看成一个迷你文档。

影子根节点后代构成的子树不属于常规DOM树，不会出现在它们宿主元素的`children`数组中，而且对`querySelector()`等常规DOM遍历方法也不可见。

### 影子DOM封装

影子DOM的关键特性是它所提供的封装。影子根节点的后代对常规DOM树而言是隐藏且独立的，几乎就像它们是在一个独立的文档中一样。它提供了三种非常重要的封装：

* 影子DOM中的元素对`querySelector()`等常规DOM方法是不可见的。在创建影子根节点并将其附加于影子宿主时，可以指定其模式是open还是closed。关闭的影子根节点将被完全封闭，不可访问。开放模式的影子根节点的宿主会有一个shadowRoot属性，JS可以通过它访问到影子根节点的元素
* 在影子根节点之下定义的样式对该子树是私有的，不会影响外部的阳光DOM元素。应用给影子宿主元素的阳光DOM样式也不会影响影子根节点。影子DOM中的元素会从阳光DOM继承字体大小和背景颜色等，而影子DOM中的样式可以选择使用阳光DOM中定义的CSS变量。不过大多数情况下，阳光DOM的样式和影子DOM的样式是完全独立的。
* 影子DOM中发生的某些事件(如`load`)会封闭在影子DOM中。而另外一些事件，如`focus`、`mouse`和键盘事件则会向上冒泡，穿透影子DOM.当一个发源于影子DOM内的事件跨国边界向阳光DOM传播时，其target属性会变成影子宿主元素。

### 影子DOM插槽和阳光DOM子元素

作为影子宿主的HTML元素有两个后代子树。一个是`children[]`数组，即常规的阳光DOM后代，另一个则是影子根节点及其后代。

影子宿主的两个完全不同的子树按照下面规则显示：

* 影子根节点的后代始终显示在影子宿主内
* 如果这些后代中包含一个`<slot>`元素，那么宿主元素的常规阳光DOM子元素会像它们本来就是该`<slot>`的子元素一样显示，替代该插槽中的任何影子DOM元素。如果影子DOM中不包含`<slot>`，那么宿主的阳光DOM内容永远不会显示。如果影子DOM有一个`<slot>`，但影子宿主没有阳光DOM子元素，那么该插槽的影子DOM内容将作为默认内容显示。
* 当阳光DOM内容显示在影子DOM插槽中时，我们就说那些元素“已分配”，但是这些元素实际上并未变成影子DOM的一部分。使用`querySelector()`依旧可以查询它们

* 如果影子DOM定义了多个`<slot>`，且通过`name`属性为它们命名，那么影子宿主的阳光DOM后代可以通过`slot="slotname"`属性指定自己想出现在哪个插槽中。

### 影子DOM API

要把一个阳光DOM元素转换为影子宿主，只需要调用其`attachShadow()`方法，传入`{mode:"open"}`这个唯一参数即可。

这个方法返回一个影子根节点对象，同时也将该对象设置为这个宿主的`shadowRoot`属性的值。这个影子根节点对象是一个`DocumentFragment`,可以使用DOM方法为其添加内容，也可以直接将其`innerHTML`属性设置为一个HTML字符串。

如果Web组件想知道影子DOM的插槽中的阳光DOM内容什么时候发生变化，可以在`<slot>`元素上注册一个`"slotchanged"`事件

### 搜索框示例

通过下面js定义一个搜索框自定义元素：

~~~js
class SearchBox extends HTMLElement{
    constructor() {
        super();
        //为SearchBox元素创建影子DOM树，影子根节点设置为this.shadowRoot
        this.attachShadow({mode:"open"});
        //克隆模板，将模板内容添加到影子根节点
        this.shadowRoot.append(SearchBox.template.content.cloneNode(true))
        //取得对影子DOM中重要元素的引用
        this.input = this.shadowRoot.querySelector("#input");
        this.leftSlot = this.shadowRoot.querySelector("slot[name='left']");
        this.rightSlot = this.shadowRoot.querySelector("slot[name='right']");
        //当影子DOM中的input输入框得焦或者失焦时，设置整个searchBox得焦或者失焦
        //以便样式表在整个组件上生效或隐藏人造的焦点环
        //事件会冒泡，就像起源于<search-box>一样
        this.input.onfocus = () => {this.setAttribute("focused","");};
        this.input.onblur = ()=> {this.removeAttribute("focused");};
        //当用户点击放大镜，或者输入框发生变化，触发search事件，该事件不会传播
        this.leftSlot.onclick = this.input.onchange = (event) =>{
            event.stopPropagation();
            if (this.disabled) return;
            this.dispatchEvent(new CustomEvent("search",{
                detail: this.input.value
            }));
        }
        //当用户单击了X图标，触发clear事件，如果事件处理程序没有调用preventDefault()则清除输入
        this.rightSlot.onclick = (event)=>{
            event.stopPropagation();
            if (this.disabled) return;
            let e = new CustomEvent("clear",{cancelable:true});
            this.dispatchEvent(e);
            if (!e.defaultPrevented) {
                this.input.value = "";
            }
        }
    }

    attributeChangedCallback(name,oldValue,newValue){
        if (name === "disabled"){
            this.input.disabled = (newValue !== null);
        } else  if (name === "placeholder"){
            this.input.placeholder =newValue;
        } else if (name === "size"){
            this.input.size = newValue;
        } else if(name ==="value"){
            this.input.value = newValue;
        }
    }

    get placeholder(){return this.getAttribute("placeholder");}
    get size(){return this.getAttribute("size");}
    get disabled(){return this.getAttribute("disabled");}
    get hidden(){return this.getAttribute("hidden");}

    set placeholder(value){ this.setAttribute("placeholder",value);}
    set size(value){ this.setAttribute("size",value);}
    set value(value){ this.setAttribute("value",value);}
    set disabled(value){
        if (value)
            this.setAttribute("disabled",value);
        else
            this.removeAttribute("disabled")
    }
    set hidden(value){
        if (value)
            this.setAttribute("hidden",value);
        else
            this.removeAttribute("hidden")
    }

}
//创建一个模板
SearchBox.template= document.createElement("template");
SearchBox.observedAttributes= ["disabled","placeholder","size","value"];
//设置模板内容
SearchBox.template.innerHTML = `
<style>
	//:host 用于在影子DOM内部选择影子根宿主 
    :host {
        display: inline-block;
        border: solid black 1px;
        border-radius: 5px;
        padding: 4px 6px;
    }
    :host([hidden]){
        display:none;
    }
    :host([disabled]){
        opacity: 0.5;
    }
    :host([focused]){
        box-shadow: 0 0 2px 2px #6AE;
    }
    input {
        border-width: 0;
        outline: none;
        font: inherit;
        background:inherit;
    }
    slot {
        cursor: default;
        user-select: none;
    }

</style>
<div>
    <slot name="left">\u{1f50d}</slot>
    <input type="text" id="input"/>
    <slot name="right">\u{2573}</slot>
</div>`

//定义自定义元素
customElements.define("search-box",SearchBox);
~~~

注意：CSS伪类选择器 `:host `用于在影子DOM内部选择影子根宿主 

接下来我们试着使用这个搜索框：

~~~html
<search-box id="sb"></search-box>
~~~

并为其添加上搜索事件的监听器：

~~~js
//为search-box设置一个监听器
document.querySelector("#sb").addEventListener("search",function (event) {
    console.log("用户搜索了:"+event.detail) //这里只弹出用户的输入，单通常要将用户的搜索内容发送给服务器
})
~~~

