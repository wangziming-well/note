# Web编程基础

我们需要了解如何编写Web应用中的JS程序，如何将这些程序加载到浏览器，以及如何获取输入、产生输出，如何运行响应事件的异步代码。在浏览器上运行的JS我们一般称为客户客户端JS程序。

## `<script>`标签中的JS

浏览器显示HTML文档，需要在HTML文档中包含后者引用JS代码，才能执行它。这就需要HTML`script`标签

JS可以通过`<sript>`标签嵌入html文档中，例如：

~~~html
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <script >
        alert(1)
    </script>
</head>
~~~

但是更常见的方式是使用`<script>`标签的src属性引用JS代码：

~~~html
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <script src="demo.js" type="text/javascript"></script>
</head>
~~~

使用src引用js文件有如下优点：

* 简化HTML文件，实现JS和页面的分离
* 可以实现JS文件代码的共享：让多个页面共享同一份JS代码
* 在浏览器中，当多个页面共享一份JS文件代码时，这个JS文件只需被下载一次
* src以任意URL为值，即可以是本地服务器的URL，也可以是其他服务商暴露的地址

如果要以模块方式引用JS文件，需要使用带`type="module"`属性的`<script>`标签来加载

### 脚本运行时机

在浏览器引入JS语言之初，还没有任何API可以遍历和操作已经渲染号的文档的结构和内容。JS代码唯一能够影响文档内容的方式，就是在浏览器加载文档的过程中动态生成内容。为此，JS使用`document.write()`方式在脚本所在位置向HTML中注入文本

现在已经不提倡使用`document.write()`生成内容了，但是由于还存在这种可能，所以浏览器在解析`<script>`的脚本的默认行为是必须要加载并运行脚本，就是为了确保不漏掉脚本可能输出的HTML内容，然后才能再继续解析和渲染文档。这有可能严重拖慢网页的解析和渲染过程。

这种默认行为可以通过`<script>`的`defer`和`async`属性来改变，这两个属性是布尔值。

* `defer`属性为true时，会让浏览器把脚本的执行推迟到文档完全加载和解析之后
* `async`属性会让浏览器异步加载脚本，这样不会阻塞文档解析。`async`必须在有`defer`属性时才起作用

带有`type="module"`属性的脚本默认会在文档加载完毕后执行。

如果不使用async和defer属性，可以选择把`<script>`标签放在HTML文件的末尾，这样就可以解析操作所有的文档内容了。

另外如果不是通过`src`引用的外部脚本，而是直接通过`<script>`内嵌的脚本，则`defer`属性无效

## 文档对象模型

客户端JS编程中最重要的一个对象就是Document对象，它代表浏览器窗口或标签页中显示的HTML文档。

用于操作HTML文档的API被称为文档对象模型(Document Object Model,DOM)

DOM API于HTML文档的树形结构一一对应。文档中的每个HTML标签都有一个对应的JavaScript Element对象，而文档中的每一行文本都有一个与之对应的Text对象。Element和Text类，以及Document类本身，都是一个更通用的Node类的子类。各种Node对象组合形成一个树形结构，JS可以使用DOM API对其进行查询和遍历。

DOM API包含创建新Element和Text结点的方法，也包含把它们作为其他Element对象的孩子插入文档的方法。还有用来在文档中移动元素的方法，以及把它们从文档中删除的方法。

每个HTML标签类型都有一个与之对应的JS类，文档中出现的每个标签在JS中都有对应类的一个实例表示。

例如`<body>`标签由`HTMLBodyElement`的实例表示。`<table>`标签由`HTMLTableElement`的实例表示。

这些元素对象都有于HTML标签属性对应的属性。在JS中修改属性的值，也会改变HTML属性的值。

有些元素也定义了额外的方法。比如，`HTMLAudioElement`和`HTMLVideoElement`类都定义了`play()`和`pause()`方法用于控制音频和视频文件的回放。

## 浏览器中的全局对象

每个浏览器窗口或标签页都有一个全局对象。在一个窗口中运行的所有JS代码(不包括在工作线程中运行的代码)都共享一个全局对象。

所以文档中所有脚本和模块共享一个全局对象，如果有脚本在全局对象上定义了一个属性，则改属性对其他所有脚本可见。

全局对象定义了JS标准库，比如`Math`对象，`Set`类，`parseInt()`函数等。

在浏览器中，全局对象页包含各种Web API的主入口，比如：document属性表示当前显示的文档，`fetch()`方法用于发送HTTP网络请求，`Audio()`构造函数允许JS程序播放声音。

在浏览器中，全局对象具有双重角色。它既时定义JS语言内置类型和函数的地方，也代表当前浏览器窗口定义了`history`和`innerWidth`等Web API的属性。

全局对象的属性中有一个属性叫`window`，它的值就是全局对象本身。所以我们可以直接通过`window`引用全局对象。

在使用窗口特定的功能时，最好加上window前缀。比如写`window.innerWidth`比只写`innerWidth`更明确。

## 脚本命名空间

在模块中，定义在模块顶级的常量、变量、函数和类时模块私有的，除非它们被明确地导出。

但在非模块脚本中，如果在顶级脚本中定义了一个常量、变量、函数或类，则改声明将对同一文档中的所有脚本可见。既它们共享一个命名空间

这种特性在大型程序中会有命名冲突的麻烦，特别是在某些脚本还是第三方库的情况下。

这个共享的命名空间在运行时有一些历史遗留问题。比如，顶级的`var`和`function`声明会在共享的全局对象上创建属性。而使用ES6中`const`、`let`和`class`的顶级声明则不会在全局对象上创建属性。

## JS程序的执行

客户端JS中没有程序的正式定义，但我们可以说JS程序由文档中包含和引用的所有JS代码组成。这些分开的代码共享一个全局Window对象，访问同一个底层Document对象。不是模块的脚本还额外共享同一个顶级命名空间。

如果网页中有嵌入的窗口(`<iframe>`元素),被嵌入文档和嵌入它的文档中的JS代码拥有不同的全局对象和Document对象，可以看成两个不同的JS程序。

但是关于JS程序的边界是没有正式定义的。如果包含文档和被包含文档是从同一个服务器加载的，则一个文档中的代码就能和另一个文档中的代码交互。

我们可以将JS程序的执行想象成发生了两个阶段：

* 第一阶段，加载阶段:文档内容加载完成，`<script>`元素指定的JS代码运行。脚本通常按照它们在文档中出现的顺序依次执行(但可以通过`async`和`defer`改变这一行为).任何一个脚本中的JS代码都自上而下运行
* 第二阶段，事件驱动阶段：当文档加载完毕且所有脚本都运行后，JS执行进入第二阶段。这个阶段是异步的、事件驱动的。如果脚本要在第二阶段执行，那么它在第一阶段必须至少注册一个将被异步调用的事件处理程序或者其他回调函数。第二阶段代码通常是为响应用户操作(鼠标点击，敲击键盘等)而被调用。

事件驱动阶段发生的第一次事件主要由`DOMContentLoaded`和`load`。

`DOMContentLoaded`在HTML文档被完全加载和解析后触发。而`load`事件在所有文档的外部资源(如图片)都完全加载后触发。

JS程序经常使用这两个事件作为触发器或启动信息。

JS的加载阶段相对较短，一般少于1s。文档加载一完成，事件驱动阶段将在浏览器文档的过程中一直持续。

### 客户端JS的线程模型

JS是单线程语言，这意味着浏览器会在脚本和事件处理程序执行期间停止响应用户输入。所有我们需要保证JS脚本和事件处理程序不会长时间运行。否则，可能导致文档加载延迟，浏览器没有响应，导致用户以为程序已经崩溃。

Web平台定义了受控的编程模型，既Web工作线程。工作线程是一个后台线程，可以执行计算密集型任务而不冻结用户界面。工作线程中运行的代码无权访问文档内容，不会于主线程和其他工作线程共享任何状态，只能通过异步消息事件于主线程或其他工作线程通信。所有这种多线程不会有线程安全的问题

### 客户端JS时间线

前面介绍了JS程序加载和执行的处理阶段。具体可以细分为下列步骤：

* 浏览器创建Document对象并开始解析网页，随着解析，不断向文档中添加Element对象和Text节点。此时,`document.readyState`属性的值是`loading`

* HTML解析器在碰到一个没有`async`、`defer`或`type="module"`属性的`<script>`标签时，会把该标签添加到文档中，然后加载并执行其中的脚本。脚本的加载和执行是同步的，在脚本下载和运行期间，HTML解析器会暂停。

  类似这样的脚本可以使用`document.write()`向输入流中插入文本，该文本在解析器恢复时将会称为文档的一部分。

  这样的脚本只能看到它自己的`<script>`标签以及该标签之前的内容

* 解析器在碰到一个有`async`属性的`<script>`元素时，会异步下载该脚本的代码，并继续解析文档(既加载脚本不阻塞文档解析)。脚本在下载完成后会尽快执行，但计息期不会停下来等待它下载。

  这样的异步脚本必须不能使用`document.write()`方法。

* 在文档解析完成后，`document.readState`属性变为`interactive`
* 任何有`defer`属性的脚本都会在按照它们在文档中出现的顺序依次执行
* 浏览器在`Document`对象派发`DOMContentLoaded`事件。标志着程序执行从同步脚本执行阶段过渡到异步的事件驱动阶段。但要注意，此时仍然可能存在尚未执行的async脚本
* 文档已经完全解析，但浏览器可能仍然在等待其他内容(如图片)加载。当所有外部资源都加载完成，且所有async脚本都加载并执行完成时，`document.readyState`变为`complete`，浏览器在Window对象上派发`load`事件
* 接下来，浏览器开始异步调用事件处理阶段。

## 程序输入和输出

和其他程序一样，客户端JS程序也处理输入数据，产生输出数据。输入的来源有很多：

* 文档的内容本身，和附带的其他信息(如文档的URL和Cookie)可以通过DOM API来访问
* 事件形式的用户输入，如点击鼠标和输入文本
* 全局`navigator`属性暴露了关于浏览器、操作系统以及它们能力的信息。

客户端JS通常以借助DOM API 操作HTML文档的形式产生输出。或者使用`console.log()`及相关方法产生输出。

## 程序错误

与直接运行在操作系统上的应用程序不同，在浏览器中运行的JS程序不会真正”崩溃“。如果JS程序在运行期间出现异常，且没有catch语句处理它，开发者控制台将会显示一条错误消息，但任何已经注册的事件处理程序照样会继续运行和响应事件。

如果想要处理全局的所有未捕获异常，可以把Window对象的onerror属性设置为一个错误处理函数。当未捕获异常沿调用栈一路向上传播，最终`window.onerror`函数会以三个字符串参数被调用。

* 第一个参数描述错误的消息
* 第二个参数包含导致错误的JS代码的URL
* 第三个参数是文档中发生错误的行号

如果`onerror`处理程序返回true。则表示这个错误已经处理了，不会显示在控制台。

如果期约被拒绝而没有`.catch()`函数处理它，那么可以通过定义`window.onunhandledrejection`函数或者使用`window.addEventListener()`为`unhandledrejection`事件注册一个处理程序来发现它。这个监听器回调接收一个对象

传给这个处理程序的事件对象有promise属性，值为被拒绝的Promise对象，有reason属性，值为本来要传给`.catch()`函数的拒绝理由。如果调用对象的`preventDefault()`则浏览器认为错误已经处理，不会再控制台显示错误。

如果想要知道用户在使用时发生了哪些错误，可以使用这两种方式在回调中把错误上报给服务器

## Web安全模型

由于网页可以在客户的设备上执行任意JS代码，因此存在明显的安全隐患。所以浏览器厂商需要对JS做安全处理：防止恶意代码读取或者修改用户数据、侵犯用户隐私、欺诈用户或者浪费用户时间。

下面简单介绍Web平台的安全限制和已知问题

### JS代码不能做

浏览器对恶意代码的第一道防线就是不支持某些能力。例如，客户端JS不能向客户端计算机中写入或删除任何文件。

客户端JS没有通用的网络能力，虽然可以发送HTTP请求和WebSocket，但是只能和特定的服务器通信

### 同源策略

同源策略指的是对JS代码能够访问和操作什么Web内容的一整套限制。通常在页面中包含`<iframe>`元素时会涉及同源策略。同源策略控制一个窗口的JS和另一个窗口的JS的交互。比如，脚本只能读取和包含它的文档同源的Window和Document对象。

文档的源就是文档URL的协议、主机和端口。必须协议、主机和端口都相同的文档URL，文档才算是同源。

注意同源策略指的是脚本所在文档的源。而不是脚本自身的源。

同源策略也会应用到脚本发起的HTTP请求中。JS代码可以向托管其包含文档的服务器发起任意HTTP请求，但不能和其他服务器通信(除非浏览器开启了CORS)

同源策略对使用多子域的大型网站造成了麻烦。为了支持多子域名网站，脚本可以通过把`document.domain`设置为一个域名后缀来修改自己的源。

第二种缓解同源策略的技术是跨源资源共享(Cross-Origin Resource Sharing,CORS),它允许服务器决定对哪些源提供服务。

CORS扩展了HTTP协议，增加了新的`Origin:`响应头和`Access-Control-Allow-Origin`响应头。

服务器可以使用这个头部明确列出哪些源提供服务，或者使用痛批恶妇表示可以接收任何网站的请求。

浏览器通过这些CORS头部的有无决定是否放松同源限制

### 跨站点脚本

跨站点脚本(Cross-Site Scripting,XSS)是一种攻击方式，指攻击者向目标网站注入HTML标签和脚本。

如果网页的内容是动态生成的，比如说根据用户的提交生成内容，但没有对用户提交的数据进行任何审查。就有可能称为跨站点脚本的攻击目标。比如说用户输入的不是常规字符串，而是一串包含脚本调用的标签:`<img src="x.png" onload="unkownScript()">`

如果将这样的用户输入未经处理地加载到自己的页面上，在图片加载完成后，就会运行一段未知的恶意脚本。

之所以称为跨站点脚本攻击，是因为涉及不止一个网站：

网站B包含一个特殊编制的链接(带有标签和脚本的)，指向网站A。

如果网站B能够说服用户点击这个链接，用户就会导航到网站A，网站A就会运行来自网站B的代码。该代码可能会破环网站A的页面，或者读取A存储的cookie，并将该数据发送给网站B。

一般来说，防止XSS攻击的办法是从不可信数据中删除HTML标签，然后再使用。或者将不可信能够只能展示在`<iframe>`中，并将这个`<iframe>`的`sandbox`设置为禁用脚本和其他功能。

# 事件

和任意具有图形用户界面的应用一样，客户端JS程序使用异步事件驱动的编程模型。浏览器会在发生值得关注的事情时生成事件。例如，在加载完文档时，用户鼠标点击时，用户键盘输入时生成事件。

如果JS应用关注特定类型的事件，那么可以注册一个或者多个函数，让这些函数在该类事件发生时被调用。

在客户端JS中，事件可以在HTML文档上的任何元素上发生，所有事件模型比Node的事件模型更复杂。

接下来介绍和事件模型相关的重要定义：

* 事件类型：事件类型是一个字符串。表示发生了什么事件。例如`"mousemove"`表示用户移动了鼠标，`"keydown"` 表示用户按下了键盘上 某个键。`"load"`表示文档或其他资源通过网络加载完成。事件类型有时也称事件名称。
* 事件目标：事件目标是一个对象，而事件就发生在该对象上或者事件与该对象有关。`Window`、`Document`和`Element`对象是最常见的时间目标，例如一个`<button>`元素上发生了单击(click)事件。
* 事件处理程序或者事件监听器：事件监听器是一个函数，负责处理或响应事件。应用通过浏览器注册自己的事件处理程序，指定事件类型和事件目标。当在事件目标上发生指定类型的事件时，浏览器就会调用这个处理器。当事件处理程序在某个对象上被调用时，我们说浏览器“触发”，“派发”了该事件。
* 事件对象：事件对象是与事件关联的对象，包含有关该事件的细节。事件对象作为事件处理程序的参数传入。所有事件对象都有`type`和`target`属性，分别表示事件类型和事件目标。每个事件类型都为相关事件兑现定义了一组属性。比如，与鼠标事件相关的事件对象包含鼠标指针的坐标，与键盘事件相关的事件对象包含于被按下的键以及按住不放的修饰键的信息。
* 事件传播：事件传播是一个过程，浏览器会决定在这个过程中哪些对象触发事件处理程序。HTML文档的元素是嵌套的，如果在一个`<a>`标签上移动鼠标，同时也意味着在`<a>`标签所在的标签移动鼠标，最终在`document`上移动鼠标。所以有些事件需要沿着HTML文档的树形结构向上冒泡，直到根节点`document`。事件处理程序可以阻止事件传播，从而让事件不再冒泡。另一种形式的事件传播是事件捕获：注册在包含元素上的处理程序在事件被发送到实际目标之前，有机会拦截(或捕获)事件。

## 事件类别

客户端JS支持的事件类型非常多。我们只将这些事件分成通用的类别，不详细介绍每个事件。

* 设备相关输入事件：这类事件直接于特定输入设备(如键盘鼠标)相关。如："mousedown", "mousemove", "mouseup", "touchstart", "touchmove", "touchend", "keydown" "keyup"等等
* 设备无关输入事件：这类事件不与特定输入设备直接相关。比如"clikc"事件表示一个链接或者按钮已经被激活。一般来说，这个事件由鼠标触发，但也可能通过键盘或在触摸屏上通过轻击触发。而"input"事件既支持键盘输入，也支持剪切粘贴和表意文字的输入法。"pointerdown","pointermove",和"pointerup"事件既支持鼠标类型的指针也适用于触屏和手写笔输入。
* 用户界面事件：UI事件是高级事件，通常在定义应用界面的HTML表单元素上触发。比如："focus"(当文本输入字段获得键盘焦点时)、"change"(当用户修改了表单元素显示的值时)和"submit"(当用户单击表单中的提交按钮时)
* 状态变化事件：有些事件并不直接由用户活动触发，而是由网络或浏览器活动触发。这类事件表示生命周期或者状态的变化。其中最常用的两个事件时分别由`Window`和`Document`对象在文档加载结束时触发的`load`和`DOMContentLoaded`事件。浏览器会在网络连接发生变化时在`Window`对象上触发`online`和`offline`事件。浏览器的历史管理机制会触发`popstate`事件作为对浏览器”后退“按钮的回应

* API特定事件一些HTML和Web API包含自己的事件类型，HTML的`<video>`和`<audio>`元素定义了一些列事件，例如"waiting", "playing" ,"seeking", "volumechange"等。

## 注册事件处理程序

有两种注册事件处理程序的方式。第一种是设置作为事件目标的对象或文档元素的一个属性。第二种更通用的方式是把处理程序传给对象或元素的`addEventListener()`方法

### 设置事件处理程序属性

可以把事件目标的一个属性设置为关联的事件处理程序函数。这样的属性的名字都由on和事件名称组成。例如：`onclick`、`onchange`、`onload`等等。这些属性名区分大小写，且必须全部小写，即使包含多个单词。例如：

~~~js
document.querySelector("#btn").onclick = function () {
    alert("点击了一个按钮")
}
~~~

设置事件处理程序属性的缺点就是每个事件目标对每种事件最多只有一个处理程序。

事件处理程序属性也可以直接在HTML文件中组为对应HTML标签的属性来定义(要注册Window元素上的处理程序可以定义在`<body>`)，属性的值用改是JS代码字符串。这段代码通常是函数调用表达式，例如：

~~~js
<button id="btn" onclick = "clickBut()">按钮</button>
~~~

如果有多条语句，需要用分号分开

~~~js
<button id="btn" onclick = "cosole.log('Thank you') ; alert('Thank you');">按钮</button>
~~~

在这段JS代码字符串中，可以通过它引用当前的事件对象

### `addEventListener()`

任何可以作为事件目标的对象都定义了一个名为`addEventListener()`的方法，可以使用它俩注册目标为调用对象的事件处理程序。

这个方法接收三个参数：第一个参数是注册处理程序的事件类型字符串。第二个参数是作为事件处理程序的函数。第三个参数是可选的，后续介绍。一个示例如下：

~~~js
document.querySelector("#btn").addEventListener("click",btnClickListener)
function btnClickListener(){
    alert("点击了一个按钮")
}
~~~

可以在同一个事件目标上多次调用`addEventListener()`函数注册监听器。事件触发时会按照监听器的注册顺序执行多个监听器。

对应的`removeEventListener()`方法可以从一个对象上移除事件监听器。它的前两个参数和`addEventListener()`一样。这样我们可以临时注册一个事件监听器，然后后续移除它。

`addEventListener()`可选的第三个参数是一个布尔值或对象。如果传入true，函数就会被注册为捕获事件处理程序，从而在事件派发的另一个阶段调用它。如果注册监听器是第三个参数传了true，那么移除事件时，第三个参数也要传true。

可以给第三个参数传一个对象，显示指定选项：

~~~js
document.querySelector("#btn").addEventListener("click",btnClickListener,{
    capture: true,
    once: true,
    passive : true
})
~~~

如果capture属性为true，那么函数就会被注册为捕获处理程序，和第三个参数直接传true一样。默认为false

如果once属性为true，那么事件监听器被触发依次后自动移除。默认为false

如果passive属性为true，则表示事件处理程序永远不调用`preventDefault()`取消默认动作，这对于移动设备上的触摸事件很重要

## 调用事件处理程序

注册事件处理程序后，浏览器会在指定对象发生指定事件时自动调用它。接下来介绍事件处理程序的细节，如监听器函数的参数，上席文和返回值的含义

### 事件监听器的参数

事件处理器被调用时接收一个Event对象作为唯一的参数。这个Event对象的属性提供了事件的详细信息：

* `type`：发生事件的类型
* `target`：发生事件的对象
* `currentTarget`：对于传播的事件，这个属性是注册当前事件处理程序的对象
* `timeStamp`表示事件发生时间的时间戳(ms),不是绝对时间
* `isTrusted`，如果这个事件由浏览器派发，则这个属性为true，如果事件由JS代码派发，这个属性为false

### 事件监听器的上下文

事件监听器在被调用时，以注册事件监听器的目标对象作为上下文this值的。不论通过`addEventListener()`注册，还是通过事件监听属性`onxxx`注册。

但是，这不适用于箭头函数。对于箭头函数形式的事件监听器，其`this`值始终等于定义它的作用域的this值。

### 事件监听器的返回值

在现代JS中，事件处理程序不应该由返回值。但在比较老的代码中，事件监听器可能会有返回值，这个返回的值通常用于告诉浏览器不要执行于事件相关的默认动作。比如，如果一个表单submit按钮的onclick监听器返回false，浏览器将不会提交表单。

而阻止浏览器执行默认动作的标准且推荐的方式，是调用`Event`对象的`preventDefault()`方法，后续会介绍。

### 调用顺序

一个事件目标上注册多个监听器时。当事件发生时，浏览器会按照它们的注册顺序调用它。即使混合使用`addEventListener()`注册和对象属性的`onxxx`注册，结果同样如此。

## 事件传播

如果事件的目标是Window或者其他独立对象，浏览器对这个事件的响应就是简单地调用该对象上对应的监听器。但如果事件目标是Document或者其他文档元素，就没有那么简单了。

注册在目标元素上的事件监听器在被调用后，多数事件会沿DOM树向上”冒泡“。目标父元素的事件监听器会被调用。这样一直往上到Document对象，然后到Window对象。

有了事件冒泡，我们就可以不用给个别文档元素注册很多事件处理程序，只需要在它们公共祖父元素上注册一个时间处理程序。

多数文档元素上发生的事件都会冒泡。明显的例外是"focus" "blur" 和"scroll"事件。文档元素的"load"事件冒泡，但是到Document对象就会停止，不会传播到Window对象。

在目标监听器被调用之前，事件可以被捕获。当`addEventListener()`的第三个可选参数为true或者其option对象的capture为true时，这个监听器就会被注册为捕获监听器。

而捕获的顺序和冒泡相反，最先被调用的捕获监听器是`Window`对象上的，然后时Document对象的，然后沿着DOM树一直往下，直到事件目标父元素的捕获监听器被调用。注册在事件目标本身的捕获事件监听器并不会被调用。

也就是说，在一个事件发生，被处理之前，会从DOM树的根开始被其目标的父元素注册的捕获事件监听器捕获。

## 事件取消

浏览器默认对很对用户事件都会做出响应，无论是否在代码中指定。比如

* 用户在一个链接上单击鼠标，浏览器就会跟随该链接
* 如果一个HTML文本输入元素获得了键盘焦点，而且用户按了某个键，就浏览器就会打出用户的输入
* 如果用户在触摸屏上滑动手指，浏览器就会滚动

我们可以阻止浏览器执行这样的默认响应。方法时在目标上注册事件处理程序，在处理程序中调用事件对象的`preeventDefault()`方法，就可以阻止浏览器执行默认响应(除非监听器的passive属性为true)

取消于事件关联的默认动作时事件取消的一种情况。除此之外，还可以调用事件对象的`stopPropagation()`方法，取消事件传播。

`stopPropagation()`可以在捕获阶段，以及在冒泡阶段起作用。但不会阻止同一对象上的其他监听器的调用

`stopImmediatePropagation()`于`stopPropgation()`类似，但它也会阻止在同一个对象上注册的后续事件处理程序的执行。

## 派发自定义事件

JS事件API能够定义和派发自己的事件。

如果一个目标对象除了`addEventListener()`、`removeEventListener()`方法，还有`dispatchEvent()`方法，它接收一个事件对象，表示目标派发了这个事件。我们可以通过`CustomEvent()`构造方法创建事件对象。这样，我们就可以派发自定义事件了。

我们在Document上注册一个自定义的监听器，首先为自定义的事件注册监听器：

~~~js
document.addEventListener("selfDefinitionEvent",listener)
~~~

然后手动调用`dispatchEvent()`派发这个事件，触发监听器：

~~~js
document.dispatchEvent(new CustomEvent("selfDefinitionEvent",{detail:true}))
~~~

# 操作DOM

通过脚本操作网页时JS的核心目标。 而DOM API为这个目标提供支持

每个Window对象都有一个document属性，引用一个Document对象，这个Document对象代表窗口的内容，它时DOM中表示和操作文档内容的核心内容

## 选择Document元素

客户端JS程序经常要操作文档中的一个或者对各元素。全局document属性引用Document对象，而Document对象向下延申出以Element对象为节点的树形结构对应文档的嵌套元素。首先必须通过某种方式获取或者选择表示文档元素的Element对象。

### `querySelector()`

DOM方法`querySelector()`和`querySelectorAll()`可以通过CSS选择语法来在文档中找到匹配的元素

`querySelector()`方法接收一个CSS选择符字符串作为参数，返回它在文档中找到的第一个匹配的元素，如果没有找打，则返回null：

~~~js
document.querySelector("#myId")
~~~

`querySelectorAll()`方法类似，但是它返回文档中匹配的所有元素，而不是只返回第一个：

~~~js
let divs = document.querySelector(".div");
~~~

`querySelectorAll()`的返回值不是Element对象的数组，而是一个类似数组的NodeList对象，可以像数组一样通过索引访问，所以可以用传统的for循环遍历。NodeList也是可迭代对象，因此也可以用`for/of`循环中使用。

如果文档中没有与指定选择符匹配的元素，则`querySelectorAll()`返回的NodeList的length属性为0

Element类和Document类都实现了`querySelector()`和`querySelectorAll()`当在元素上调用时，这两个方法只查找返回该元素后代中的元素。

注意，用CSS的伪类选择器调用这两个方法将什么也得不到，既不支持伪类选择器。

### `closest()`

`closest()`方法也是基于CSS选择器的，这个方法时Element类定义的，以一个选择符作为唯一参数。如果选择符匹配那个调用它的元素，则返回该元素，否则就返回与选择符匹配的最近祖先元素，如果没有匹配，则返回null。

所以`closest()`可以看成`querySelector()`的逆向操作：`closest()`从当前元素开始，沿DOM树向上匹配，而`querySelector()`则从当前元素开始，沿DOM树向下匹配。

### 其他选择元素的方法

除了`querySelector()`和`querySelectorAll()`，DOM也定义了一些老式的元素选择方法：

* `getElementById()`
* `getElementsByClassName()`
* `getElementsByName()`
* `getElementsByTagName()`

通过匹配标签的id/class/name/tagName获取元素

## 文档结构

从Document中选择一个Element之后，常常还需要查找文档结构中相关的部分(父节点、兄弟节点、孩子节点)

Element对象提供一组属性。这些属性引用当前元素的相关节点：

* `parentNode`,引用元素的父节点
* `children`是HTMLCollection，包含元素的所有子元素，不含非Element节点，如Text节点
* `childElementCount`元素的所有子元素的个数，与`children.length`返回的值相同
* `firstElementChild`、`lastElementChild`，分别引用元素的第一个子元素和最后一个子元素，如果没有子元素，它们的值为null
* `previousElementSibling`、`nextElementsibling`这两个属性分别引用元素前一个和后一个兄弟元素，如果没有同辈元素则为null

这样我们可是使用一些常规的深度优先、广度优先遍历算法来遍历整个DOM树

如果在遍历文档或文档中某些部分时不想忽略Text节点，可以使用另一组在所有Node对象上都有定义的属性。通过这些属性可以看到Element、Text节点，甚至Comment节点(表示文档上的HTML注释)

所有Node对象都定义了一下属性：

~~~js
parentNode: ParentNode | null; //当前节点的父节点
childNodes: NodeListOf<ChildNode>; //只读的NodeList对象，包含节点的所有子节点
firstChild: ChildNode | null; //节点的第一个孩子节点
lastChild: ChildNode | null; //节点的最后一个孩子节点
nextSibling: ChildNode | null; // 节点的后一个兄弟节点
previousSibling: ChildNode ; //节点的前一个兄弟节点
nodeType: number; //表示当前节点类型的数值，Document节点值为9，Element节点值为1，Text节点值为3，Comment节点的值为8
nodeValue: string | null; //Text或Comment节点的文本内容
nodeName: string; //Element节点的HTML标签名，会转换为全部大写
~~~

## 属性

HTML元素由标签名和一组称为属性的名/值对构成。

Element类定义了通用的`getAttribute()`、`setAttribute()`、`hasAttribute()`和`removeAttribute()`方法用于访问和操作元素的属性。

但HTML元素的属性(标准HTML元素的标准属性)同时也表示在这些元素的HTMLElement对象上具有相应的属性。通过JS属性来获取它们，通常要比调用`getAttribute()`和其他方法更便捷：

~~~js
let img = document.querySelector("#img");
img.src = "www.xxx.com/xxx/.."
~~~

对于某些属性，例如`<input>`，有的HTML属性会映射到不同的JS属性。比如，`<input>`元素在HTML中的value属性对应到JS中是`defaultValue`属性。而JS中的value属性包含的是用户当前在`<input>`元素中输入的值。

有些HTML属性名是JS中的保留字，对于这些属性，通用规则是在对应的JS属性包含前缀`html`，比如`<label>`元素在HTML中的for元素，对应JS中的`htmlFor`属性。`class`也是JS的保留字，但这个HTML class 属性比较特殊，它在JS代码中会变成className

### class属性

HTML元素的class属性特别重要。它的值是空格分隔的CSS类命的列表，用于给元素应用CSS样式。由于class在JS中是保留字，所以这个HTML属性是通过Element对象上的className属性反映的。className值是一个字符串。但是我们通常把HTML class 当成一个列表，在这个列表中添加和删除某个类名是很常见的，而不是仅仅把它看作整个字符串。

为此，Element对象定义了classList属性，支持将class属性作为一个列表来操作。classList属性引用一个可迭代的类数组对象。定义了`add()`、`contains()`、`contains()`和`toggle()`方法

### dataset属性

有时候会需要在HTML元素上附加一些信息。这样JS代码在选择并操作相应的元素是可以使用这些信息。

在HTML中，任何以前缀`date-`开头的小写属性都被认为是有效的，可以将它们用于任何目的。这些数据集(dataset)属性不影响它们所在的元素的展示，在确保文档正确性的前提下定义了一种附加额外数据的标准方式。

在DOM中，Element对象有一个dataset属性，该属性引用的对象包含于HTML中的`date-`对应的属性，但不带这个前缀。也就是说dataset.x中保存的是HTML中data-x属性的值。而连字符份额的属性将映射为驼峰式属性名：HTML中的data-section-number会变成JS中的dataset.sectionNumber

如果文档中有如下元素：

~~~html
<h2 id="title" data-section-number="15.1">Attributes</h2>
~~~

那么可以通过如下方式访问：

~~~js
document.querySelector("#title").dataset.sectionNumber;
~~~

## 元素内容

接下来介绍如何擦偶哦元素内容的HTML表示和纯文本表示

### 作为HTML的内容

Element的innerHTML属性会返回该元素内容的标记字符串。在元素上设置这个属性会调用浏览器的解析器，并以新字符串解析后的表示替换元素当前内容。

设置innerHTML通常效率很高。不过使用`+=`操作符给innerHTML追加文本内容的效率不高。因为这个操作既涉及序列化操作，也会涉及解析操作：先把元素转换为字符串，然后再把新字符串转换为元素内容

注意：最好不要使用用户输入或者其他外部来源的内容设置innerHTML

Element的outerHTML属性于innerHTML属性类似，只是返回的值包含元素自身。在读取outerHTML是，该值包含元素的开始和结束标签。在设置元素的outerHTML时，新内容会取代元素自身。

Element提供`insertAdjacentHTML()`用于插入别调用的元素相邻的任意HTML字符串。这个方法接收两个参数，

* 第一个参数指定要插入的位置，有四个可选的字符串值：`beforebegin`、`afterbegin`、`beforeend`、`afterend`
* 第二个参数指定要插入的HTML内容

这四个可选的值具体的位置示意如下：

![image-20231229155543522](https://gitee.com/wangziming707/note-pic/raw/master/img/ElementinsertAdjacentHTMLPosition.png)

### 作为纯文本的内容

有时候需要得到元素的纯文本内容，或者向文档中插入纯文本。这样做的标准方法是使用textContent属性：

~~~js
let title = document.querySelector("#title");
let text = title.textContent;
title.textContent = "Hello World!";
~~~

这个textContent属性由Node类定义，所有在Textr节点和Element节点上都可以使用。对于Element节点，它会找到并返回元素所有后代中的文本

Element类定义了一个innerText属性，于textContent类似。但是innerText有一些少见和复杂的行为，如试图阻止表格格式化。这个属性的定义不严谨，浏览器间的实现也存在兼容性问题，因此不应该再使用了。

## 创建、插入和删除节点

Document类定义了创建Element对象的方法，而Element和Text对象拥有在树种插入、删除和替换节点的方法。

使用Document类的`createElement()`方法可以创建一个新元素。并通过Element自己的`append()`和`prepend()`方法为元素自己添加文本或者其他子元素。

注意：`createElement()`创建的仅仅是JS元素对象，不会同步在HTML文档中创建，如果要将创建的元素插入到HTML文档上，需要调用已有元素的`append()`或者`prepend()`方法：

~~~js
let p = document.createElement("a");
p.append("1234132")
document.body.append(p)
~~~

`append()`和`prepend()`接收任意多个参数，这些参数可以是Node对象或者字符串。字符串参数会自动转换为Text节点(也可以使用document.createTextNode()来创建Text节点，但很少需要这样做)。`append()`把参数添加到孩子列表的末尾。`prepend()`把参数添加到孩子列表的开头

如果想要在同辈位置插入节点，可以使用`befor()`和`after()`插入。

`before()`和`after()`同样接收任意个数的字符串和Node对象参数，在将字符串转换为Text节点后把它们全部插入文档中。

`append()`和`prepend()`只在`Element`对象上有定义，而`after()`和`before()`同时存在于Element和Text节点上。

注意，一个JS Element对象对应的HTML 元素表示只能被插入到文档中的一个地方，如果这个对应HTML元素已经在文档中了，把它插入其他地方时，它会转移到新位置，而不是复制一个新的过去。

如果确实需要创建一个元素的副本，可以使用`cloneNode()`方法，传入`true`以复制其全部内容

~~~js
greetings.after(paragraph.cloneNode(true));//创建paragraph的一个副本，再把它插入到greetings元素后面
~~~

一个节点调用`remove()`方法可以把自己从文档中删除，或者可以调用`replaceWith()`替换自己

`relpace()`方法不接受参数,`replaceWith()`和`before()`和`after()`一样，接收任意多个字符串和元素。

# 操作CSS

