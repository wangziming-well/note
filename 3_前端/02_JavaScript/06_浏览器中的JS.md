# Web编程基础

我们需要了解如何编写Web应用中的JS程序，如何将这些程序加载到浏览器，以及如何获取输入、产生输出，如何运行响应事件的异步代码。在浏览器上运行的JS我们一般称为客户客户端JS程序。

## `<script>`标签中的JS

浏览器显示HTML文档，需要在HTML文档中包含后者引用JS代码，才能执行它。这就需要HTML`script`标签

JS可以通过`<sript>`标签嵌入html文档中，例如：

~~~html
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <script >
        alert(1)
    </script>
</head>
~~~

但是更常见的方式是使用`<script>`标签的src属性引用JS代码：

~~~html
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <script src="demo.js" type="text/javascript"></script>
</head>
~~~

使用src引用js文件有如下优点：

* 简化HTML文件，实现JS和页面的分离
* 可以实现JS文件代码的共享：让多个页面共享同一份JS代码
* 在浏览器中，当多个页面共享一份JS文件代码时，这个JS文件只需被下载一次
* src以任意URL为值，即可以是本地服务器的URL，也可以是其他服务商暴露的地址

如果要以模块方式引用JS文件，需要使用带`type="module"`属性的`<script>`标签来加载

### 脚本运行时机

在浏览器引入JS语言之初，还没有任何API可以遍历和操作已经渲染号的文档的结构和内容。JS代码唯一能够影响文档内容的方式，就是在浏览器加载文档的过程中动态生成内容。为此，JS使用`document.write()`方式在脚本所在位置向HTML中注入文本

现在已经不提倡使用`document.write()`生成内容了，但是由于还存在这种可能，所以浏览器在解析`<script>`的脚本的默认行为是必须要加载并运行脚本，就是为了确保不漏掉脚本可能输出的HTML内容，然后才能再继续解析和渲染文档。这有可能严重拖慢网页的解析和渲染过程。

这种默认行为可以通过`<script>`的`defer`和`async`属性来改变，这两个属性是布尔值。

* `defer`属性为true时，会让浏览器把脚本的执行推迟到文档完全加载和解析之后
* `async`属性会让浏览器异步加载脚本，这样不会阻塞文档解析。`async`必须在有`defer`属性时才起作用

带有`type="module"`属性的脚本默认会在文档加载完毕后执行。

如果不使用async和defer属性，可以选择把`<script>`标签放在HTML文件的末尾，这样就可以解析操作所有的文档内容了。

另外如果不是通过`src`引用的外部脚本，而是直接通过`<script>`内嵌的脚本，则`defer`属性无效

## 文档对象模型

客户端JS编程中最重要的一个对象就是Document对象，它代表浏览器窗口或标签页中显示的HTML文档。

用于操作HTML文档的API被称为文档对象模型(Document Object Model,DOM)

DOM API于HTML文档的树形结构一一对应。文档中的每个HTML标签都有一个对应的JavaScript Element对象，而文档中的每一行文本都有一个与之对应的Text对象。Element和Text类，以及Document类本身，都是一个更通用的Node类的子类。各种Node对象组合形成一个树形结构，JS可以使用DOM API对其进行查询和遍历。

DOM API包含创建新Element和Text结点的方法，也包含把它们作为其他Element对象的孩子插入文档的方法。还有用来在文档中移动元素的方法，以及把它们从文档中删除的方法。

每个HTML标签类型都有一个与之对应的JS类，文档中出现的每个标签在JS中都有对应类的一个实例表示。

例如`<body>`标签由`HTMLBodyElement`的实例表示。`<table>`标签由`HTMLTableElement`的实例表示。

这些元素对象都有于HTML标签属性对应的属性。在JS中修改属性的值，也会改变HTML属性的值。

有些元素也定义了额外的方法。比如，`HTMLAudioElement`和`HTMLVideoElement`类都定义了`play()`和`pause()`方法用于控制音频和视频文件的回放。

## 浏览器中的全局对象

每个浏览器窗口或标签页都有一个全局对象。在一个窗口中运行的所有JS代码(不包括在工作线程中运行的代码)都共享一个全局对象。

所以文档中所有脚本和模块共享一个全局对象，如果有脚本在全局对象上定义了一个属性，则改属性对其他所有脚本可见。

全局对象定义了JS标准库，比如`Math`对象，`Set`类，`parseInt()`函数等。

在浏览器中，全局对象页包含各种Web API的主入口，比如：document属性表示当前显示的文档，`fetch()`方法用于发送HTTP网络请求，`Audio()`构造函数允许JS程序播放声音。

在浏览器中，全局对象具有双重角色。它既时定义JS语言内置类型和函数的地方，也代表当前浏览器窗口定义了`history`和`innerWidth`等Web API的属性。

全局对象的属性中有一个属性叫`window`，它的值就是全局对象本身。所以我们可以直接通过`window`引用全局对象。

在使用窗口特定的功能时，最好加上window前缀。比如写`window.innerWidth`比只写`innerWidth`更明确。

## 脚本命名空间

在模块中，定义在模块顶级的常量、变量、函数和类时模块私有的，除非它们被明确地导出。

但在非模块脚本中，如果在顶级脚本中定义了一个常量、变量、函数或类，则改声明将对同一文档中的所有脚本可见。既它们共享一个命名空间

这种特性在大型程序中会有命名冲突的麻烦，特别是在某些脚本还是第三方库的情况下。

这个共享的命名空间在运行时有一些历史遗留问题。比如，顶级的`var`和`function`声明会在共享的全局对象上创建属性。而使用ES6中`const`、`let`和`class`的顶级声明则不会在全局对象上创建属性。

## JS程序的执行

客户端JS中没有程序的正式定义，但我们可以说JS程序由文档中包含和引用的所有JS代码组成。这些分开的代码共享一个全局Window对象，访问同一个底层Document对象。不是模块的脚本还额外共享同一个顶级命名空间。

如果网页中有嵌入的窗口(`<iframe>`元素),被嵌入文档和嵌入它的文档中的JS代码拥有不同的全局对象和Document对象，可以看成两个不同的JS程序。

但是关于JS程序的边界是没有正式定义的。如果包含文档和被包含文档是从同一个服务器加载的，则一个文档中的代码就能和另一个文档中的代码交互。

我们可以将JS程序的执行想象成发生了两个阶段：

* 第一阶段，加载阶段:文档内容加载完成，`<script>`元素指定的JS代码运行。脚本通常按照它们在文档中出现的顺序依次执行(但可以通过`async`和`defer`改变这一行为).任何一个脚本中的JS代码都自上而下运行
* 第二阶段，事件驱动阶段：当文档加载完毕且所有脚本都运行后，JS执行进入第二阶段。这个阶段是异步的、事件驱动的。如果脚本要在第二阶段执行，那么它在第一阶段必须至少注册一个将被异步调用的事件处理程序或者其他回调函数。第二阶段代码通常是为响应用户操作(鼠标点击，敲击键盘等)而被调用。

事件驱动阶段发生的第一次事件主要由`DOMContentLoaded`和`load`。

`DOMContentLoaded`在HTML文档被完全加载和解析后触发。而`load`事件在所有文档的外部资源(如图片)都完全加载后触发。

JS程序经常使用这两个事件作为触发器或启动信息。

JS的加载阶段相对较短，一般少于1s。文档加载一完成，事件驱动阶段将在浏览器文档的过程中一直持续。

### 客户端JS的线程模型

JS是单线程语言，这意味着浏览器会在脚本和事件处理程序执行期间停止响应用户输入。所有我们需要保证JS脚本和事件处理程序不会长时间运行。否则，可能导致文档加载延迟，浏览器没有响应，导致用户以为程序已经崩溃。

Web平台定义了受控的编程模型，既Web工作线程。工作线程是一个后台线程，可以执行计算密集型任务而不冻结用户界面。工作线程中运行的代码无权访问文档内容，不会于主线程和其他工作线程共享任何状态，只能通过异步消息事件于主线程或其他工作线程通信。所有这种多线程不会有线程安全的问题

### 客户端JS时间线

前面介绍了JS程序加载和执行的处理阶段。具体可以细分为下列步骤：

* 浏览器创建Document对象并开始解析网页，随着解析，不断向文档中添加Element对象和Text节点。此时,`document.readyState`属性的值是`loading`

* HTML解析器在碰到一个没有`async`、`defer`或`type="module"`属性的`<script>`标签时，会把该标签添加到文档中，然后加载并执行其中的脚本。脚本的加载和执行是同步的，在脚本下载和运行期间，HTML解析器会暂停。

  类似这样的脚本可以使用`document.write()`向输入流中插入文本，该文本在解析器恢复时将会称为文档的一部分。

  这样的脚本只能看到它自己的`<script>`标签以及该标签之前的内容

* 解析器在碰到一个有`async`属性的`<script>`元素时，会异步下载该脚本的代码，并继续解析文档(既加载脚本不阻塞文档解析)。脚本在下载完成后会尽快执行，但计息期不会停下来等待它下载。

  这样的异步脚本必须不能使用`document.write()`方法。

* 在文档解析完成后，`document.readState`属性变为`interactive`
* 任何有`defer`属性的脚本都会在按照它们在文档中出现的顺序依次执行
* 浏览器在`Document`对象派发`DOMContentLoaded`事件。标志着程序执行从同步脚本执行阶段过渡到异步的事件驱动阶段。但要注意，此时仍然可能存在尚未执行的async脚本
* 文档已经完全解析，但浏览器可能仍然在等待其他内容(如图片)加载。当所有外部资源都加载完成，且所有async脚本都加载并执行完成时，`document.readyState`变为`complete`，浏览器在Window对象上派发`load`事件
* 接下来，浏览器开始异步调用事件处理阶段。

## 程序输入和输出

和其他程序一样，客户端JS程序也处理输入数据，产生输出数据。输入的来源有很多：

* 文档的内容本身，和附带的其他信息(如文档的URL和Cookie)可以通过DOM API来访问
* 事件形式的用户输入，如点击鼠标和输入文本
* 全局`navigator`属性暴露了关于浏览器、操作系统以及它们能力的信息。

客户端JS通常以借助DOM API 操作HTML文档的形式产生输出。或者使用`console.log()`及相关方法产生输出。

## 程序错误

与直接运行在操作系统上的应用程序不同，在浏览器中运行的JS程序不会真正”崩溃“。如果JS程序在运行期间出现异常，且没有catch语句处理它，开发者控制台将会显示一条错误消息，但任何已经注册的事件处理程序照样会继续运行和响应事件。

如果想要处理全局的所有未捕获异常，可以把Window对象的onerror属性设置为一个错误处理函数。当未捕获异常沿调用栈一路向上传播，最终`window.onerror`函数会以三个字符串参数被调用。

* 第一个参数描述错误的消息
* 第二个参数包含导致错误的JS代码的URL
* 第三个参数是文档中发生错误的行号

如果`onerror`处理程序返回true。则表示这个错误已经处理了，不会显示在控制台。

如果期约被拒绝而没有`.catch()`函数处理它，那么可以通过定义`window.onunhandledrejection`函数或者使用`window.addEventListener()`为`unhandledrejection`事件注册一个处理程序来发现它。这个监听器回调接收一个对象

传给这个处理程序的事件对象有promise属性，值为被拒绝的Promise对象，有reason属性，值为本来要传给`.catch()`函数的拒绝理由。如果调用对象的`preventDefault()`则浏览器认为错误已经处理，不会再控制台显示错误。

如果想要知道用户在使用时发生了哪些错误，可以使用这两种方式在回调中把错误上报给服务器

## Web安全模型

由于网页可以在客户的设备上执行任意JS代码，因此存在明显的安全隐患。所以浏览器厂商需要对JS做安全处理：防止恶意代码读取或者修改用户数据、侵犯用户隐私、欺诈用户或者浪费用户时间。

下面简单介绍Web平台的安全限制和已知问题

### JS代码不能做

浏览器对恶意代码的第一道防线就是不支持某些能力。例如，客户端JS不能向客户端计算机中写入或删除任何文件。

客户端JS没有通用的网络能力，虽然可以发送HTTP请求和WebSocket，但是只能和特定的服务器通信

### 同源策略

同源策略指的是对JS代码能够访问和操作什么Web内容的一整套限制。通常在页面中包含`<iframe>`元素时会涉及同源策略。同源策略控制一个窗口的JS和另一个窗口的JS的交互。比如，脚本只能读取和包含它的文档同源的Window和Document对象。

文档的源就是文档URL的协议、主机和端口。必须协议、主机和端口都相同的文档URL，文档才算是同源。

注意同源策略指的是脚本所在文档的源。而不是脚本自身的源。

同源策略也会应用到脚本发起的HTTP请求中。JS代码可以向托管其包含文档的服务器发起任意HTTP请求，但不能和其他服务器通信(除非浏览器开启了CORS)

同源策略对使用多子域的大型网站造成了麻烦。为了支持多子域名网站，脚本可以通过把`document.domain`设置为一个域名后缀来修改自己的源。

第二种缓解同源策略的技术是跨源资源共享(Cross-Origin Resource Sharing,CORS),它允许服务器决定对哪些源提供服务。

CORS扩展了HTTP协议，增加了新的`Origin:`响应头和`Access-Control-Allow-Origin`响应头。

服务器可以使用这个头部明确列出哪些源提供服务，或者使用痛批恶妇表示可以接收任何网站的请求。

浏览器通过这些CORS头部的有无决定是否放松同源限制

### 跨站点脚本

跨站点脚本(Cross-Site Scripting,XSS)是一种攻击方式，指攻击者向目标网站注入HTML标签和脚本。

如果网页的内容是动态生成的，比如说根据用户的提交生成内容，但没有对用户提交的数据进行任何审查。就有可能称为跨站点脚本的攻击目标。比如说用户输入的不是常规字符串，而是一串包含脚本调用的标签:`<img src="x.png" onload="unkownScript()">`

如果将这样的用户输入未经处理地加载到自己的页面上，在图片加载完成后，就会运行一段未知的恶意脚本。

之所以称为跨站点脚本攻击，是因为涉及不止一个网站：

网站B包含一个特殊编制的链接(带有标签和脚本的)，指向网站A。

如果网站B能够说服用户点击这个链接，用户就会导航到网站A，网站A就会运行来自网站B的代码。该代码可能会破环网站A的页面，或者读取A存储的cookie，并将该数据发送给网站B。

一般来说，防止XSS攻击的办法是从不可信数据中删除HTML标签，然后再使用。或者将不可信能够只能展示在`<iframe>`中，并将这个`<iframe>`的`sandbox`设置为禁用脚本和其他功能。

# 事件
