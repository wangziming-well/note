# 对象

对象是JS最基本的数据类型。对象是一种复合值，它汇聚多个值(原始值或其他对象)并按名字存储和获取这些值。

对象是一个属性的无序集合，每个属性都有名字和值。属性名通常是字符串，因此可以说对象把字符串映射为值。

JS对象也可以从其他对象继承属性，这个其他对象成为“原型”。

JS对象是动态的，即可以动态添加和删除属性

在JS中，任何不是字符串、数值、符号或true、false、null、undefined的值都是对象。

对对象相关的最常见的操作包括创建对象，设置、查询、删除、测试和枚举它们的值。

属性有一个名字和一个值，属性名可以是任意字符串，包括空字符串，但对象不能包含两个同名的属性。值可以是任意值，或者是设置函数或获取函数(或两个函数同时存在)

区分直接定义在对象上的属性和那些从原型对象上继承的属性很重要，JS使用术语“自有属性”指代继承属性。

除了名字和值外，每个属性还有三个属性特性：

* writable 可写特性指定是否可以设置属性的值
* enumerable 可枚举特性指定是否可以在for/in循环中返回属性的名字
* configurable 可配置特性指定是否可以删除属性，以及是否可修改其特性

很多JS内置对象拥有只读、不可枚举和不可配置的属性。默认情况下，我们所创建的对象的所有属性都是可写、可枚举和可配置的。

## 创建对象

对象可以通过对象字面量、`new`关键字和`Object.create()`函数来创建

### 对象字面量

创建对象最简单的方式是在JS代码中直接包含对象字面量。

对象字面量最简单的形式是包含在一对花括号中的一组逗号分隔的`名:值`对。

属性名是JS标识符或者字符串字面量。属性值是任何JS表达式，例如：

~~~js
let empty = {};
let point = {x:0,y:0};
~~~

对象字面量最后一个属性后面的逗号是合法的。

对象字面量是一个表达式，每次求值都会创建并初始化一个新的、不一样的对象。字面量每次被求值的时候，它的每个属性的值也会被求值。这意味着同一个对象字面量如果出现在循环体中，或出现在重复调用的函数体内，可以创建很多新对象，并且这些对象属性的值可能不同。

### 使用`new`创建对象

`new`操作符用于创建和初始化一个新对象。`new`关键字后面必须跟一个构造函数的函数调用。

JS为内置的类型提供了构造函数：

~~~js
let o = new Object();
let a = new Array();
let d = new Date();
let r = new Map();
~~~

除了内置的构造函数，我们也可以自定义构造函数来创建新的对象，后续会介绍。

### 原型

几乎每个JS对象都有另一个与之关联的对象。这另一个对象被称之为原型(prototype)，第一个对象从这个原型继承属性。

通过对象字面量出啊关键的所有对象都有相同的原型对象，可以通过`Object.prototype`引用这个原型对象。

使用`new`关键字和构造函数创建的对象，使用构造函数`prototype`属性的值作为它们的原型。

`Object.prototype`是为数不多的没有原型的对象，因为它不继承任何属性。

### `Object.create()`

`Object.create()`用于创建一个新对象，使用第一个参数作为新对象的原型：

~~~js
let o1 = Object.create({x:1,y:2});
~~~

传入`null`可以创建一个没有原型的对象。不过这样的新对象不会继承任何东西，

如果想创建一个普通的空队形，可以传入`Object.prototype`

~~~js
let o2= Object.create(Object.prototype);
~~~

## 对象属性

### 查询和设置属性

要获取一个属性的值，可以使用之前介绍的`.`和`[]`操作符：

~~~js
let author = book.author;
let title = book["main tite"];
~~~

如果访问的属性不存在，则返回undefiend

要创建和设置属性，同样使用点或方括号，只是要把它们放到赋值表达式的左边：

~~~js
book.edition = 7;
book["main tite"] ="ECMAScript";
~~~

### 删除属性

delete操作符用于从对象中移除属性:

~~~js
delete book.author;
~~~

delete操作符只删除自有属性，不删除继承属性。

delete不会删除configurable特性为false的属性。

### 测试属性

实际开发中，常常需要测试对象是否有一个给定名字的属性。

为此，可以使用`in`操作符，或者`hasOWnProperty()`、`prepertyIsEnumberable()`方法，或者直接查询相应属性：

~~~js
let o = {x:1};
"x" in o // true
"toString" in o // true
"y" in o // false
~~~

对象的`hasOwnProperty()`方法测试对象是否有给定名字的属性，对继承的属性返回false：

~~~js
let o ={x:1};
o.hasOwnProperty("x"); //true
o.hasOwnProperty("y");//false
o.hasOwnProperty("toString"); //false
~~~

而`propertyIsEnumerable()`方法测试对象属性是否是可枚举的

### 枚举属性

有时候需要遍历和获取对象的所有属性。有几种不同的实现方式：

`for/in`循环对指定对象的内阁可枚举(自有或继承)属性都会运行一次循环体。

对象继承的内置方法是不可枚举的，但自定义添加给对象的属性默认是可枚举的：

~~~js
let o ={
    name : "Alice",
    move : function (){
        console.log("move");
    }
}

for (let p in o){
    console.log(p)
}
~~~

也可以先获取对象所有属性名的数组，然后再通过`for/of`循环遍历该数组。以下函数可以取得属性名数组：

* `Object.keys()`返回对象可枚举自有属性名的数组。
* `Object.getOwnPropertyNames()`返回对象自有属性名的数组。包括不可枚举的属性
* `Object.getOwnPropertySymbols()`返回名字是符号的自由属性，无论是否可枚举
* `Reflect.ownKeys()`返回所有属性名

#### 属性枚举顺序

ES6正式定义了枚举对象自有属性的顺序。`Object.keys()`、`Object.getOwnPropertyNames()`、`Object.getOwnPropertySymbols()`、`Reflect.ownKeys()`、`JSON.stringify()`等相关方法都按照下面的顺序列出属性：

* 先列出名字为非负整数的字符串属性，按照数值从最小到最大。
* 然后再列除所有剩下的字符串名字。这些属性按照它们添加到对象的先后顺序列出。
* 最后，列出名字为符号对象的属性，按照它们添加到对象的先后顺序。

## 扩展对象

在JS中，将一个对象的属性复制到另一个对象上是很常见的，可以使用下面的代码做到：

~~~js
let target = {x: 1};
let source = {y:2 , z:3};
for (let key of Object.keys(source)) {
    target[key] = source[key];
}
target //  {"x": 1,"y": 2,"z": 3}
~~~

在ES6， 这个功能以`Object.assign()`的方式封装进入了JS语句中

`Object.assign()`接受两个或多个对象作为其参数。它会修改并返回第一个参数，第一个参数是目标对象，但不会修改第二个及后续参数，这些都是来源对象。对于每个来源对象，它会把该对象的可枚举自有属性复制到目标对象。

第一个来源对象的属性会覆盖目标对象的同名属性，第二个来源对象的属性会覆盖第一个来源对象的同名属性。以此类推。

~~~js
let target = {x:1,y:2}
let source1 = { y:3,z:4}
let source2 = { z:5 , l:6}
Object.assign(target,source1,source2);
target //{"x": 1, "y": 3,"z": 5,"l": 6}
~~~

## 序列化对象

对象序列化是把对象的状态转换为字符串的过程，这个过程的逆过程称为逆序列化。

函数`JSON.stringify()`和`JSON.parse()`用于序列化和反序列化。这两个函数使用JSON数据交互格式。

JSON表示`JavaScript Object Notation`（JS对象表示法）,语法和JS对象和数组字面量很相似：

~~~js
let o = {x:1,y:{z:[false,null,""]}};
let s = JSON.stringify(o); // {"x":1,"y":{"z":[false,null,""]}}'
let p = JSON.parse(s); //{"x":1,"y":{"z":[false,null,""]}}
~~~

JSON语法时JS语法的子集，不能表示所有的JS的值。可以序列化和反序列化的值包括：对象、数组、字符串、有限数值、布尔值和null。

而`NaN`、`Infinity`和`-Infinity`会被序列化为`null`。函数、RegExp和Error对象以及`undefined`值不能被序列化和反序列化。

`JSON.stringify()`只序列化对象的可枚举自有属性。

后续还会继续介绍这两个方法。

## 对象方法

如前所述，除了那些显示创建为没有原型的对象，其他所有JS对象都从`Object.prototype`继承属性。这些继承的属性主要是方法。

我们之前已经介绍过了`hasOwnProperty()`和`propertyIsEnumerable()`方法了，接下来继续介绍`Object.prototype`定义的几个通用方法

### `toString()`

返回表示调用它的对象的值的字符串。

默认的`toString()`方法并不能提供太多信息。例如：

~~~js
let s = {x:1,y:1}.toString(); //[object Object]
~~~

所以很多类会重新定义自己的`toString()`方法：

~~~js
let o = {
    x:1,
    y:1,
    toString: function () {
        return `(${this.x},${this.y})`
    }
}
let s = o.toString(); //  (1,1)
~~~

### `toLocaleString()`

这个方法的用途是返回对象的本地化字符串表示。

`Object`定义的默认`toLocaleString()`方法本身没有实现任何本地化，而是简单地调用`toString()`并返回该值。

`Number`和`Date`定义了自己的`toLocaleString()`方法。

后续介绍的国际化类可以用于实现`toLocaleString()`方法

### `valueOf()`

JS在需要把对象转换为某些非字符串原始值(通常是数值)时被调用。默认的`valueOf()`放啊发并没有做什么，一些内置类定义了自己的`valueOf()`方法：

~~~js
let o = {
    x:1,
    y:1,
    valueOf : function (){
        return Math.sqrt(this.x*this.x+this.y*this.y)
    }
}
let n = o + 0; // 1.4142135623730951
~~~

### `toJSON()`

`Object.prototype`实际上并没有定义`toJSON()`方法，但是`JSON.stringify()`方法会从要序列化的对象上寻找`toJSON()`方法。如果存在这个方法，就调用它，然后序列化该方法的返回值，而不是原始对象。

~~~js
let o = {
    x:1,
    y:1,
    toString: function () {
        return `(${this.x},${this.y})`;
    },
    toJSON: function (){
        return this.toString();
    }
}
let s = JSON.stringify(o); // "(1,1)"
~~~

## 对象字面量扩展语法

### 简写属性

假设变量x和y中保存着值，如果想创建一个具有属性`x`和`y`且值分别为相应变量值的对象。按照普通的方式，需要把每个标识符重复两次：

~~~js
let x = 1, y = 2;
let o = {
    x: x,
    y: y
}
~~~

在ES6后，可以删除其中的分号和一份标识符，使用简洁的代码达到同样的效果：

~~~js
let x = 1, y = 2;
let o = {x, y}
~~~

### 计算的属性名

有时候，我们需要创建一个具有特定属性的对象，但该属性的名字不是在编译时确定的，无法直接写在源代码中，所以需要将这个属性名保存在一个变量中，或者调用某个函数的返回值。所以，必须先创建一个对象，然后再为它添加想要的属性：

~~~js
let propertyName = "p1" 
function getPropertyName(){
    return "p" +2;
}
//实际可能来自于网络或者用户输入等
let o ={};
o[propertyName] = 1;
o[getPropertyName()] = 2;
~~~

ES6新增了计算属性的特性，可以更简单地创建类似对象,只需要把变量或者函数放在属性名的位置并用中括号括起来：

~~~js
let propertyName = "p1"
function getPropertyName(){
    return "p" +2;
}
//实际可能来自于网络或者用户输入等
let o ={
    [propertyName] : 1,
    [getPropertyName()] : 2
};
~~~

### 扩展操作符

在ES2018及以后，可以在对象字面量中使用“扩展操作符”`...`把已有对象的属性复制到新对象中：

~~~js
let position = {x: 0, y: 0};
let dimensions = {width: 100, height: 75};
let rect = { ...position, ...dimensions}; //{"x": 0, "y": 0, "width": 100, "height": 75}
~~~

和`Object.create()`一样，复制对象到新对象会覆盖原属性

### 简写方法

在把函数定义为对象属性时，我们称该函数为方法。在ES6以前，需要像定义对象的其他属性一样，通过函数定义表达式在独享字面量中定义一个方法：

~~~js
let square = {
    area : function() {return this.side * this.side},
    side : 10
}
~~~

在ES6中，允许一种省略`function`关键字和冒号的简写方法：

~~~js
let square = {
    area() {return this.side * this.side},
    side : 10
}
~~~

### 属性的获取方法和设置方法

JS支持为对象定义访问器属性，这种属性是获取方法和设置方法。

当程序查询一个访问器属性的值时,JS会调用获取方法。这个方法的返回值就是属性访问表达式的值。

当程序设置一个访问器属性的值时，JS会调用设置方法，传入赋值语句右边的值。

如果一个属性既有获取方法也有设置方法，则该属性是一个可读写属性。

如果只有获取方法，那它就是只读属性。如果只有一个设置方法，那它就是只写属性。读取这属性只能得到`undefiend`

~~~js
let o  = {
    x : 1,
    get getX(){
        return this.x;
    },
    set getX(x){
        this.x = x;
    }
}
o.getX;
~~~

下面例子中可以通过获取方法和设置方法 以极坐标的形式访问和设置笛卡尔坐标系下的坐标：

~~~js
let p = {
    x: 1.0,
    y: 1.0,
    get r() {
        return Math.hypot(this.x,this.y);
    },
    set r(newValue){
        let oldValue = this.r;
        let ratio = newValue / oldValue;
        this.x *= ratio;
        this.y *= ratio;
    },

    get theta(){return Math.atan2(this.y,this.x)}
}
p.r;
p.theta;
~~~

和数据属性一样，访问器属性也可以继承。

# 数组

JS数组是一种特殊的JS对象。

数组是值的有序集合，其中的值叫做元素，每个元素都有一个数值表示的位置，叫做索引。

数组中的元素可以是任意类型，同一数组的不同元素也可以是不同类型。

JS中数组是动态的，会按需增大或缩小。

JS中数组可以是稀疏的，即元素不一定具有连续的索引，中间可以有间隙。

每个数组都有`length`。对于非稀疏数组，这个属性保存数组中元素的个数。对于稀疏数组，length大于所有元素的最高索引。

## 创建数组

创建数组有几种方式。接下来会分别介绍：

* 数组字面量
* 对可迭代对象使用`...`操作符
* `Array()`构造函数
* 工厂方法`Array.of()`和`Array.from()`

### 数组字面量

数组字面量是一对方括号中逗号分隔的数组元素的列表：

~~~js
let empty = [];
let misc = [1.1,true,"a",];
~~~

数组字面量中的值不需要是常量，可以是任意表达式：

~~~js
let base = 1024;
let table = [base,base+1,base+2,base+3];
~~~

如果数组字面量中连续包含多个逗号，且逗号之间没有值，则这个数组就是稀疏的，这些省略了值的元组不存在，按照索引查询它们时会返回`undefined`

### 扩展操作符

在ES6以及以后的版本，可以使用扩展操作符`...`在一个数组字面量中包含另一个数组的元素：

~~~js
let a = [1,2,3];
let b = [0,...a,4]; //[0,1,2,3,4]
~~~

扩展操作符适用于任何可迭代对象。字符串是可迭代对象，因此可以使用扩展操作符将任意字符串转换为单个字符的数组：

~~~js
let digits = [..."123"] // ["1","2","3"]
~~~

### `Array()`构造函数

可以使用`Array()`构造函数来创建数组，有三种方式：

* 空参调用`new Array()`，相当于字面量`[]`，创建一个空数组
* 传入一个整数，指定数组长度`new Array(10)`
* 传入两个或者任意多个任意类型的参数，或者1个非数值的参数；这些参数将成为新数组的元组

### `Array.of()`

使用`Array()`构造函数无法创建只包含一个数值元组的数组。

在ES6中，`Array.of()`函数可以解决这个问题。这个工厂方法会将其所有的参数值作为数组元组来创建并返回新数组：

~~~js
Array.of() // []
Array.of(10) // [10]
Array.of(1,2,3) // [1,2,3]
~~~

### `Array.from()`

`Array.from()`是ES6新增的另一个工厂方法。这个方法期待一个可迭代对象或类数组独享作为其第一个参数，并返回包含该对象元素的新数组。

它定义了一种给类数组对象创建真正的数组副本的机制。

`Array.from()`接受第二个可选的参数，如果第二个参数传入了一个函数，那么在构建新数组时，源对象的内阁元素都会传入这个函数，这个函数的返回值将替代原始值成为新数组的元组

~~~js
let a = Array.from("123",function(x){return x *2;}) ; // [2,4,6]
~~~

## 读写数组元素

可以使用`[]`操作符访问数组元组，方括号左侧是对数组的引用，方括号内应该是一个具有非负整数的表达式：

~~~js
let a = ["world"];
let value = a[0];
a[1] = 3.14;
a.length //2
~~~

只要使用小于$2^{32}-1$的非负整数作为数组属性名，这个值会成为数组的索引

如果使用任何不是 小于$2^{32}-1$的非负整数 的数值作为数组属性名。此时值会转换为字符串，这个字符串会成为数组对象的属性。

如果使用了非负整数的字符串来索引数组，这个值也会成为数组索引，而不是对象属性。使用了与整数相等的浮点值也是如此：

~~~js 
a[-1.23] = true  // 创建一个属性 "-1.23"
a["1000"] = 0; // 相当于 a[1000] = 0
a[1.000] = 1 ; //  相当于 a[1] = 1
~~~

对于越加的查询，JS数组只会返回`undefined`不会报错

## 数组长度

对于稠密数组，`length`属性是数组中元素的个数。这个值比数组的最高索引大1

如果给一个索引为i的数组元素赋值，而i大于等于数组当前的`lenght`，则数组的`length`会被设置为`i+1`

~~~js
let a = [1,2,3]
a.length //3
a[100] = 1;
a.length // 101
~~~

如果将length设置为一个小于当前值的非负整数n，则任何索引大于或等于n的数组元素会被从数组中删除

~~~js
let a = [1,2,3]
a.length = 1
a // [1]
~~~

## 添加和删除数组元组

添加一个元素最简单的方式，就是给它的一个新索引赋值:

~~~js
let a =[];
a[0] ="zero"; //添加一个元素
~~~

也可以使用`push()`方法在数组末尾添加一个或多个元素：

~~~js
a.push("zero");
a.push("one","two");
~~~

`a.push(x)`相当于`a[a.lenght] = x`

可以使用delete 操作符删除数组元素：

~~~js
let a = [1,2,3];
delete a[2];
2 in a // false
a.length // 3
~~~

删除数组元素类似于(但不完全等同于)给该元素赋`undefined`值。对数组元素使用`delete`操作符不会修改`length`属性，从数组中删除元素后，数组会变稀疏。

## 数组方法

接下来介绍相关的数组方法：

* 迭代器方法用于遍历数组元素
* 栈和队列方法用于在开头或末尾向数组添加元素或从数组中删除元素
* 子数组方法用于提取、删除、插入、填充和复制更大数组的连续区域
* 搜索和排序方法用于在数组中查找元组和是对数组元素排序

### 数组迭代器方法

接下来介绍用于迭代数组元素的方法，它们会按照顺序把数组的每个元素传给我们提供的函数，可用于对数组进行迭代、映射、过滤、测试和归并。

接下来要介绍的所有这些方法都接受一个函数作为第一个参数，并且对数组的每个元组都调用一次这个函数。如果数组是稀疏的，则不会对不存在的数组元素调用传入的这个函数。

多数情况下，我们提供的这个函数被调用时会收到3个参数，分别是数组元素的值，数组元素的索引和数组本身。通常，我们只需要这几个参数中的第一个，可以忽略第二个和第三个值。

多数迭代器方法都接受可选的第二个参数。如果指定这个参数，该参数会作为第一个参数传入的函数内部的`this`值，即被载入的函数的上下文变量环境中。

#### `forEach()`

`forEach()`方法迭代数组的每个元素，并对每个元素都调用一次指定的函数：

~~~js
let data = [1,2,3,4,5],sum =0 ;
data.forEach(value => {sum += value;}) ; // sum == 15
data.forEach(function(v,i,a){a[i] = v+1;}) // data = [2,3,4,5,6]
~~~

#### `map()`

`map()`方法把调用它的数组的每个元素分别传给我们指定的函数，返回这个函数的返回值构成的数组

~~~js
let a = [1,2,3]; 
let b = a.map(x => x*x); // b = [1,4,9]
~~~

注意，`map()`返回一个新数组，并不修改调用它的数组。

如果数组是稀疏的，则缺失元素不会调用函数，但返回的数组也会与原始数组一样稀疏；长度相同，缺失的元素也想通

#### `filter()`

`filter()`方法返回一个数组，该数组包含 调用它的数组的子数组。传给这个方法的函数需要是断言函数，即返回布尔值的函数。如果这个函数返回`true`，则传给这个函数的元素就是`filter()`最终返回的子数组的成员：

~~~js
let a = [5,4,3,2,1];
let b = a.filter(x => x%2 ==0); // b = [4,2];
~~~

注意,`filter()`会跳过稀疏数组中缺失的元素。其返回的数组始终是稠密的。

#### `find()&findIndex()`

这两个 方法遍历数组，寻找断言函数返回真值的元素，这两个方法会在断言函数找到第一个元素时停止迭代。`find()`返回匹配的元素，`findIndex()`返回匹配元素的索引。

如果没有找到匹配的元素，`find()`返回`undefined`，而`findIndex()`返回-1

~~~js
let a = [1,2,3,4,5];
a.findIndex(x=> x ===3) // 2
a.findIndex(x=> x < 0) // -1
a.find(x=> x%5 === 0)  //5
a.find(x=> x%7 ===0) // undefined
~~~

#### `every()和some()`

这两个方法都期望一个断言函数的参数

对`every()`如果所有的数组元素对传入的断言函数都返回true，则`every()`返回true，否则返回false

对`some()`如果有一个数组元素对传入的断言函数返回true，则`some()`返回true，否则返回false

~~~js
let a = [1,2,3,4,5];
a.every(x => x<10); //true
a.some(x => x%2 ===0) //true
~~~

`every()`在某次迭代中，若断言函数返回false，则停止迭代，直接返回false

`some()`在某次迭代中，若断言函数返回true，则停止迭代，直接返回true

#### `reduce()&reduceRight()`

`reduce()`将所有元素归并，并最终产生一个值。它接受一个二元函数和一个值，`a.redue(f,v0)`相当于：

~~~js
let a = v0;
for(let e of a){
    a = f(a,e);
}
return a ;
~~~

例如:

~~~js
let a = [1,2,3,4,5];
a.reduce((x,y)=> x+y,0); //15 所有值之和
a.reduce((x,y)=>x*y,1); // 120 所有值之积
a.reduce((x,y)=>(x > y) ? x : y)  // 5 数组最大值
~~~

`reduce()`的第二个参数是可选的，如果不传第二个参数，那么归并将从数组的第一个元素开始。

`reduceRigth()`和`reduce()`类型，不过是从右到左处理数组。

### 打平数组

`flat()`方法用于创建并返回一个新数组，这个数组会将原数组中的嵌套数组打平一层：

~~~js
[1,[2,3]].flat(); // [1,2,3]
[1,[2,[3]]].flat() // [1,2,[3]]
~~~

如果不传参数，`flat()`默认打平一层嵌套。如果想打平更多层级，可以传入一个数值参数指定要打平的层数：

~~~js
let a = [1,[2,[3,[4]]]];
let b = a.flat(2); // b == [1,2,3,[4]]
~~~

`flatMap()`和`map()`类似，只不过返回的数组会自动被打平：

调用`a.flatMap(f)`相当于`a.map(f).flat()`，不过效率会更高。

### 添加合并数组

`concat()`方法创建并返回一个新数组，新数组包含调用`concat()`方法的数组的元素，以及传给`concat()`的参数。

如果这些参数中有数组，则拼接的是它们的元素而非数组本身。

但是注意，`concat()`不会递归打平数组的数组。`concat()`并不修改调用它的数组：

~~~js
let a = [1,2,3];
let b = a.concat([4,5],[6,[7]]) // Array(7) [1,2,3,4,5,6,[7]]
~~~

### 数组的堆栈操作

`push()`和`pop()`方法可以把数组当作栈来操作，这两个方法会修改原数组：

`push()`在数组末尾添加一个或多个新元素，并返回数组的新长度

`pop()`方法删除数组最后面的元素，并减少数组长度，并返回删除的值。

~~~js
let stack =[];
stack.push(1,2); // stack == [1,2]
stack.pop(); // stack == [1] ,返回2
~~~

`unshift()`和`shift()`方法与`push()`和`pop()`类似，只不过它们是从数组开头而非末尾插入和删除元素。

`unshift()`用于在数组开头添加一个或多个元素，已有元素的索引会相应向更高索引移动，并返回数组的新长度。

`shift()`删除并返回数组的第一元素，所有后续元素都会向下移动一个位置。

### 处理数组切片

数组定义了几个处理连续区域的方法。下面介绍提取、替换、填充和赋值切片的方法

#### `slice()`

`slice()`方法返回一个数组的切片/子数组。这个方法接受两个参数，用于指定子数组在原数组中的开始位置和结束位置(左闭右开)

如果只指定一个参数，返回的数组元素将包含从起始位置开始到数组末尾的所有元素。

如果任意一个参数是负值，则这个值相对于数组长度指定数组元素。例如参数`-1`指定数组的最后一个元素，参数`-2`指定倒数第二个元素。

~~~js
let a = [1,2,3,4,5];
a.slice(0,3); // [1,2,3]
a.slice(3) ; // [4,5]
a.slice(1,-1) // [2,3,4]
~~~

#### `splice()`

`splice()`可以从数组中删除元素，也可以插入新元素，也可以同时执行插入和删除。

`splice()`第一个参数指定插入和删除操作的起点位置。第二个参数指定要从数组中删除的元素个数。剩下可以继续传入参数，作为要添加进数组的元素。

如果省略第二个参数，从起点元素开始的所有元素都会被删除。

方法的返回值是被删除的数组切片。

~~~js
let a = [1,2,3,4,5,6,7,8];
let b = a.splice(4); // a == [1,2,3,4] b == [5,6,7,8]
let c = a.splice(1,2); // a == [1,4] c == [2,3]
let d = a.splice(2,0,0); // a == [1,4,0] d=[]
~~~

#### `fill()`

`fill()`方法将数组的元素或切片填充设置为指定的值。它会修改原数组，也返回修改后的数组：

它的第一个参数指定要填充的值，第二第三个参数指定要填充的位置，如果省略第二三个参数，默认填充整个数组。

~~~js
let a = Array();
a.fill(0); // [0,0,0,0,0]
a.fill(9,1); // [0,9,9,9,9]
a.fill(8,2,-1) // [0,9,8,8,9]
~~~

#### `copyWithin()`

`copyWithin()`方法将数组切片复制到数组中的新位置。会改变原数组。

第一个参数指定要复制到的目的索引。第二个参数指定要复制的第一个元素的索引，第三个参数指定要复制的最后一个元素的索引。

如果省略第2、3个参数，默认复制整个数组，如果省略第3个参数，则使用开始索引到数组结尾。

~~~js
let a = [1,2,3,4,5];
a.copyWithin(1) ;// [1,1,2,3,4] 
a.copyWithin(2,3,5) // [1,1,3,4,4]
a.copyWithin(0,-2) // [4,4,3,4,4,]
~~~

### 数组索引和排序方法

#### `indexOf()`和`lastIndexOf()`

`indexOf()`和`lastIndexOf()`从数组中搜索指定的值并返回第一个找到(通过`===`操作符)的元素的索引，如果没有找到则返回-1。但`indexOf()`从前到后搜索，`lastIndexOf()`从后向前搜索数组：

~~~js
let a = [0,1,2,1,0];
a.indexOf(1) // 1
a.lastIndeOf(1) //3
a.indexOf(3) // -1
~~~

这两个方法接受第二个可选的参数，指定从哪个位置开始搜索。

~~~js
let a = [0,1,2,1,0];
a.indexOf(2) // 2
a.indexOf(2,3) // -1
~~~

注意，因为`NaN === NaN`返回`false`，所以这两个方法无法找到`NaN`的位置

#### `includes()`

ES2016新增的`includes()`方法接受以恶参数，如果数组包含这个参数，如果数组包含该值则返回true，否则返回false。

`includes()`使用稍微不同的全等测试，认为`NaN`与自身相等。

~~~js
let a = [1,true,3,NaN];
a.includes(true) // true
a.includes(NaN)  // true
a.indexOf(NaN) // -1
~~~

#### `sort()`

`sort()`对数组元素进行升序排序，并返回排序后的数组。如果不传入参数，`sort()`按照字母顺序对数组元素排序。

也可以提供一个比较器函数

~~~js
let a = [33,4,1111,222];
a.sort(); // [1111,222,3,4]
a.sort((a,b) => a-b); //[4,33,222,1111]
~~~

#### `reverse()`

`reverse()`方法反转数组元素的排序。

~~~js
let a = [1,2,3];
a.reverse() // a == [3,2,1]
~~~

### 数组转换为字符串

`join()`方法将数组元素拼接成一个字符串,默认的分隔符为`,`

~~~js
[1,2,3].join() // "1,2,3"
~~~

也可以指定分隔符：

~~~js
[1,2,3].join(" ") // "1 2 3"
~~~

### 静态方法

之前已经介绍了`Array.of()`和`Array.from()`这两个创建新数组的工厂方法。

还有一个`Array.isArray()`方法，用于确定一个参数是否是数组：

~~~js
Array.isArray({}) // false
~~~

# 函数

函数是一个JS代码块，定义之后，可以被重复执行或调用。

JS函数定义可以包含一组标识符，成为参数或者形参。这些形参类似函数体内定义的局部变量。函数调用会为这些形参提供值或实参。

除此之外，每个函数调用还会有另外一个值，即调用上下文，`this`关键字。

函数可以有一个返回值，这个返回值会成为函数调用表达式的值。

如果把函数赋值给一个对象的属性，则可以称其为该对象的方法。如果函数是在一个对象上被调用或者通过一个对象被调用，这个对象就是函数的调用上下文或`this`值。

JS中函数是独享，可以把函数赋值给变量，然后再传递给其他函数。可以在函数上设置属性，甚至调用函数的方法。

JS函数可以嵌套在其他函数中，内嵌的函数可以访问定在外层函数的变量。即函数是闭包。

## 定义函数

`function`关键字可以声明函数

ES6定义了新的方式定义函数，就是"箭头函数"

也可以使用`Function()`构造函数定义新函数

### 函数声明

函数声明由`function`关键字和如下组件构成：

* 命名函数的标识符
* 参数列表
* 函数体

例如：

~~~js
function printprops(o){
    for(let p in o){
        console.log(`${p}:${o[p]}`);
    }
}
~~~

函数声明将将函数的名字变成了一个变量，这个变量的值就是函数本身。函数声明语句会被提升到脚本、函或代码块的顶部。所有可以在定义这个函数的代码位置之前调用它。

函数体内可以包含也可以不包含`return`语句，如果包含，调用函数表达式会求值`return`的求值。如果不包含，则返回`undefined`

在ES6以前，函数声明只能出现在JS文件或者其他函数的顶部。严格来说在循环体、条件或者其他语句块中定义函数都不合法。

在ES6严格模式下，函数声明可以出现在语句块中。在语句块中定义的函数只在该块中有定义，对块的外部不可见。

### 函数表达式

函数表达式看起来像函数声明，但它们出现在复杂表达式或语句的上下文中，而且函数名是可选的。

函数表达式可以赋值给变量:

~~~js
const square =function (x) {return x*x ;};
square(10); //100
~~~

在需要递归时，函数表达式可以包含名字：

~~~js
const f =function fact (x) {
    if(x <=1)
        return 1;
    else
        return x*fact(x-1);
};
f(3) //6
~~~

函数声明实际上会声明一个变量，然后把函数对象赋值给它。

而函数表达式不会声明变量，至于要把新定义的函数赋值给一个常量还是变量都可以。

###  箭头函数

ES6中，我们可以使用箭头函数来定义函数。箭头函数时表达式而不是语句，不必使用`function`关键字，也不需要函数名。

箭头函数的一般形式时圆括号中逗号分隔的参数列表，后跟箭头`=>`，再跟包含在花括号中的函数体：

~~~js
const sum =(x,y) => {return x+y;};
~~~

如果只有一个`return`语句，可以省略`return`关键字，分号以及花括号：

~~~js
const sum = (x,y) => x+y;
~~~

如果只有一个参数，也可以省略圆括号：

~~~js
const polynomial = x => x*x +2*x +3;
~~~

注意，写箭头函数时，不能在函数参数和箭头之间放换行符。

## 调用函数

构成函数体的JS代码不在定义函数的时候执行，在调用函数的时候执行。JS函数可以通过5中方式来调用：

* 作为函数
* 作为方法
* 作为构造函数
* 通过`call()`和`apply()`方法间接调用
* 通过JS语言特性隐形调用

### 函数调用

调用表达式包括求值为函数对象的表达式后跟一对圆括号，圆括号是实参表达式列表。

~~~js
let s = sum(x,10);
~~~

在一次调用中，位于括号中的每个实参表达式都会被求值，求值结果会变成函数的实参。在函数体内，对形参的引用会求值为对应的实参值。

对常规函数调用来说，函数的返回值会变成调用表达式的值。如果函数由于到达末尾而返回，则返回值是`undefined`，如果函数由于执行到`return`语句而返回，则返回值是`return`后面表达式的值;如果`return`语句没有值也返回`undefined`

在非严格模式下的函数调用，调用上下文(this值)是全局对象。在严格模式下，调用上下文是`undefined`。而箭头语法稍有不同：它们总是继承自身定义所在环境的`this`值。

### 方法调用

如果一个函数作为对象的属性，那么它就是方法。如果函数调用表达式的求值的表达式是属性方法表达式，那么这就是一个方法调用：

~~~js
o.m();
~~~

方法调用的参数和返回值与常规函数调用相同。但方法调用和函数调用有一个重要区别：调用上下文。在方法调用中，上面例子中的`o`会成为调用上下文。

### 构造函数调用

在函数或方法调用前加一个关键字`new`，那么它就是构造函数调用。

构造函数调用与常规函数和方法调用区别在于参数处理，调用上下文和返回值。

如果没有参数列表，构造函数调用时可以省略圆括号,下面两行代码是等价的：

~~~js
o = new Object();
o = new Object;
~~~

构造函数会创建一个新的空对象，这个对象继承构造函数的`prototype`属性指定的对象。构造函数就是为初始化对象设计的。

在构造函数中调用上下文是这个新创建的对象。

构造函数正常情况下不会使用`return`关键字。而是在初始化新对象并在到达函数体末尾时隐式返回这个对象。

### 间接调用

JS函数是对象。它有两个方法`call()`和`apply()`可以用来间接调用函数。这两个方法允许我们指定调用时的`this`值

后续会详细介绍这两个方法。

### 隐式函数调用

一些JS语言特性可能会导致函数被调用：

* 如果对象有获取方法和设置方法，则查询或设置其属性值会导致这些方法的调用
* 当对象需要转换为字符串时，会调用对象的`toString()`方阿飞，当对象用于数值上下文时，会调用它的`valueOf()`方法
* 遍历可迭代对象的元素时，设计迭代器的一系列方法调用。
* 标签模板字面量时一种伪装的函数调用
* 代理对象上的任何操作，会导致函数被调用

## 函数实参和形参

JS韩式定义不指定形参类型，函数调用不检查实参类型，甚至JS函数调用也不检查传入实参的个数。

### 可选形参和默认值

当调用函数时传入的实参少于声明的形参时，额外的形参会获得默认值，通常时`undefined`：

在ES6及更高的版本中，可以在函数形参列表中为每个参数定义默认值。语法时在形参后面加上等号和默认值，这样如果没有给该形参传值时就会使用这个默认值：

~~~js
function getPropertyNames(o,a =[]){
    for(let p in o)
        a.push(p);
    return a;
}
~~~

如果有多个形参，可以使用前面参数的值来定义后面参数的默认值，例如：

~~~js
function areas(width,height = width*2){
    return width * width;
}
~~~

### 剩余形参与可变长度实参列表

剩余形参能让我们在调用时传入比形参多任意数量的实参的函数。

在形参列表的最后一个参数前加上`...`表示该形参是剩余形参， 在函数体内可以将其当作数组来调用。在调用时，如果其他形参都有传值，那么剩下的所有的实参都将作为一个数组传递给剩余形参：

~~~js
function max ( first = -Infinity,...rest){
    let maxValue = first;
    for(let n of rest)
        if(n > maxValue)
            maxValue = n;
    return maxValue;
}
max(1,2,5,6,3) // 6
~~~

像这样可以接受任意数量实参的函数称为可变参数哈桑农户或变长函数。

### `Arguments`对象

剩余形参时ES6引入JS的。在ES6之前，变长函数是基于`Arguments`对象实现的。

在任何函数体内，标识符`arguments`引用该次调用的`Arguments`对象。

`Arguments`对象是一个类数组对象，它允许通过数值获取传给函数的参数值

~~~js
function max ( ){
    let maxValue = -Infinity;
    for(let i = 0;i<arguments.length;i++)
        if (arguments[i] > maxValue)
            maxValue = arguments[i];
    return maxValue;
}
max(1,2,5,6,3) // 6
~~~

`arguments`效率低下且难以优化，在新写的代码中应该尽量避免使用它。

### 在函数调用中使用扩展操作符

在期待单个值的上下文环境中，扩展操作符`...`用于展开或扩展数组(或任意可迭代对象).例如：

~~~js
let numbers = [5,3,6,0,-2,6];
max(...numbers) // 6
~~~

### 在函数调用中使用解构赋值

我们可以使用解构赋值来简化赋值：

~~~js
let [x,y] = [1,2];  //相等于 let x = 1, y =2;
let transparent = {
    r: 0.0,
    g: 0.0,
    b: 0.0,
    a: 1.0
}
let {r,g,b} = transparent; // r == 0.0 ; g == 0.0 ; b == 0.0
~~~

在调用函数给形参赋值时，可以使用类似的技术：

~~~js
function vectorAdd([x1,y1],[x2,y2]){
    return [x1+x2,y1+y2];
}
vectorAdd([1,2],[3,4]) // [4,6]
~~~

## 函数作为值

函数定义和调用时JS和大多数语言的语法特性。但在JS中，函数不仅时语法，也是值。在JS中函数是特殊的对象
