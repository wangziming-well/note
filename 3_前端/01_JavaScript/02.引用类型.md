# 对象

对象是JS最基本的数据类型。对象是一种复合值，它汇聚多个值(原始值或其他对象)并按名字存储和获取这些值。

对象是一个属性的无序集合，每个属性都有名字和值。属性名通常是字符串，因此可以说对象把字符串映射为值。

JS对象也可以从其他对象继承属性，这个其他对象成为“原型”。

JS对象是动态的，即可以动态添加和删除属性

在JS中，任何不是字符串、数值、符号或true、false、null、undefined的值都是对象。

对对象相关的最常见的操作包括创建对象，设置、查询、删除、测试和枚举它们的值。

属性有一个名字和一个值，属性名可以是任意字符串，包括空字符串，但对象不能包含两个同名的属性。值可以是任意值，或者是设置函数或获取函数(或两个函数同时存在)

区分直接定义在对象上的属性和那些从原型对象上继承的属性很重要，JS使用术语“自有属性”指代继承属性。

除了名字和值外，每个属性还有三个属性特性：

* writable 可写特性指定是否可以设置属性的值
* enumerable 可枚举特性指定是否可以在for/in循环中返回属性的名字
* configurable 可配置特性指定是否可以删除属性，以及是否可修改其特性

很多JS内置对象拥有只读、不可枚举和不可配置的属性。默认情况下，我们所创建的对象的所有属性都是可写、可枚举和可配置的。

## 创建对象

对象可以通过对象字面量、`new`关键字和`Object.create()`函数来创建

### 对象字面量

创建对象最简单的方式是在JS代码中直接包含对象字面量。

对象字面量最简单的形式是包含在一对花括号中的一组逗号分隔的`名:值`对。

属性名是JS标识符或者字符串字面量。属性值是任何JS表达式，例如：

~~~js
let empty = {};
let point = {x:0,y:0};
~~~

对象字面量最后一个属性后面的逗号是合法的。

对象字面量是一个表达式，每次求值都会创建并初始化一个新的、不一样的对象。字面量每次被求值的时候，它的每个属性的值也会被求值。这意味着同一个对象字面量如果出现在循环体中，或出现在重复调用的函数体内，可以创建很多新对象，并且这些对象属性的值可能不同。

### 使用`new`创建对象

`new`操作符用于创建和初始化一个新对象。`new`关键字后面必须跟一个构造函数的函数调用。

JS为内置的类型提供了构造函数：

~~~js
let o = new Object();
let a = new Array();
let d = new Date();
let r = new Map();
~~~

除了内置的构造函数，我们也可以自定义构造函数来创建新的对象，后续会介绍。

### 原型

几乎每个JS对象都有另一个与之关联的对象。这另一个对象被称之为原型(prototype)，第一个对象从这个原型继承属性。

通过对象字面量出啊关键的所有对象都有相同的原型对象，可以通过`Object.prototype`引用这个原型对象。

使用`new`关键字和构造函数创建的对象，使用构造函数`prototype`属性的值作为它们的原型。

`Object.prototype`是为数不多的没有原型的对象，因为它不继承任何属性。

### `Object.create()`

`Object.create()`用于创建一个新对象，使用第一个参数作为新对象的原型：

~~~js
let o1 = Object.create({x:1,y:2});
~~~

传入`null`可以创建一个没有原型的对象。不过这样的新对象不会继承任何东西，

如果想创建一个普通的空队形，可以传入`Object.prototype`

~~~js
let o2= Object.create(Object.prototype);
~~~

## 对象属性

### 查询和设置属性

要获取一个属性的值，可以使用之前介绍的`.`和`[]`操作符：

~~~js
let author = book.author;
let title = book["main tite"];
~~~

如果访问的属性不存在，则返回undefiend

要创建和设置属性，同样使用点或方括号，只是要把它们放到赋值表达式的左边：

~~~js
book.edition = 7;
book["main tite"] ="ECMAScript";
~~~

### 删除属性

delete操作符用于从对象中移除属性:

~~~js
delete book.author;
~~~

delete操作符只删除自有属性，不删除继承属性。

delete不会删除configurable特性为false的属性。

### 测试属性

实际开发中，常常需要测试对象是否有一个给定名字的属性。

为此，可以使用`in`操作符，或者`hasOWnProperty()`、`prepertyIsEnumberable()`方法，或者直接查询相应属性：

~~~js
let o = {x:1};
"x" in o // true
"toString" in o // true
"y" in o // false
~~~

对象的`hasOwnProperty()`方法测试对象是否有给定名字的属性，对继承的属性返回false：

~~~js
let o ={x:1};
o.hasOwnProperty("x"); //true
o.hasOwnProperty("y");//false
o.hasOwnProperty("toString"); //false
~~~

而`propertyIsEnumerable()`方法测试对象属性是否是可枚举的

### 枚举属性

有时候需要遍历和获取对象的所有属性。有几种不同的实现方式：

`for/in`循环对指定对象的内阁可枚举(自有或继承)属性都会运行一次循环体。

对象继承的内置方法是不可枚举的，但自定义添加给对象的属性默认是可枚举的：

~~~js
let o ={
    name : "Alice",
    move : function (){
        console.log("move");
    }
}

for (let p in o){
    console.log(p)
}
~~~

也可以先获取对象所有属性名的数组，然后再通过`for/of`循环遍历该数组。以下函数可以取得属性名数组：

* `Object.keys()`返回对象可枚举自有属性名的数组。
* `Object.getOwnPropertyNames()`返回对象自有属性名的数组。包括不可枚举的属性
* `Object.getOwnPropertySymbols()`返回名字是符号的自由属性，无论是否可枚举
* `Reflect.ownKeys()`返回所有属性名

### 属性枚举顺序

ES6正式定义了枚举对象自有属性的顺序。`Object.keys()`、`Object.getOwnPropertyNames()`、`Object.getOwnPropertySymbols()`、`Reflect.ownKeys()`、`JSON.stringify()`等相关方法都按照下面的顺序列出属性：

* 先列出名字为非负整数的字符串属性，按照数值从最小到最大。
* 然后再列除所有剩下的字符串名字。这些属性按照它们添加到对象的先后顺序列出。
* 最后，列出名字为符号对象的属性，按照它们添加到对象的先后顺序。

