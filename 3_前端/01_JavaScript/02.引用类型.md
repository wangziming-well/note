# 对象

对象是JS最基本的数据类型。对象是一种复合值，它汇聚多个值(原始值或其他对象)并按名字存储和获取这些值。

对象是一个属性的无序集合，每个属性都有名字和值。属性名通常是字符串，因此可以说对象把字符串映射为值。

JS对象也可以从其他对象继承属性，这个其他对象成为“原型”。

JS对象是动态的，即可以动态添加和删除属性

在JS中，任何不是字符串、数值、符号或true、false、null、undefined的值都是对象。

对对象相关的最常见的操作包括创建对象，设置、查询、删除、测试和枚举它们的值。

属性有一个名字和一个值，属性名可以是任意字符串，包括空字符串，但对象不能包含两个同名的属性。值可以是任意值，或者是设置函数或获取函数(或两个函数同时存在)

区分直接定义在对象上的属性和那些从原型对象上继承的属性很重要，JS使用术语“自有属性”指代继承属性。

除了名字和值外，每个属性还有三个属性特性：

* writable 可写特性指定是否可以设置属性的值
* enumerable 可枚举特性指定是否可以在for/in循环中返回属性的名字
* configurable 可配置特性指定是否可以删除属性，以及是否可修改其特性

很多JS内置对象拥有只读、不可枚举和不可配置的属性。默认情况下，我们所创建的对象的所有属性都是可写、可枚举和可配置的。

## 创建对象

对象可以通过对象字面量、`new`关键字和`Object.create()`函数来创建

### 对象字面量

创建对象最简单的方式是在JS代码中直接包含对象字面量。

对象字面量最简单的形式是包含在一对花括号中的一组逗号分隔的`名:值`对。

属性名是JS标识符或者字符串字面量。属性值是任何JS表达式，例如：

~~~js
let empty = {};
let point = {x:0,y:0};
~~~

对象字面量最后一个属性后面的逗号是合法的。

对象字面量是一个表达式，每次求值都会创建并初始化一个新的、不一样的对象。字面量每次被求值的时候，它的每个属性的值也会被求值。这意味着同一个对象字面量如果出现在循环体中，或出现在重复调用的函数体内，可以创建很多新对象，并且这些对象属性的值可能不同。

### 使用`new`创建对象

`new`操作符用于创建和初始化一个新对象。`new`关键字后面必须跟一个构造函数的函数调用。

JS为内置的类型提供了构造函数：

~~~js
let o = new Object();
let a = new Array();
let d = new Date();
let r = new Map();
~~~

除了内置的构造函数，我们也可以自定义构造函数来创建新的对象，后续会介绍。

### 原型

几乎每个JS对象都有另一个与之关联的对象。这另一个对象被称之为原型(prototype)，第一个对象从这个原型继承属性。

通过对象字面量出啊关键的所有对象都有相同的原型对象，可以通过`Object.prototype`引用这个原型对象。

使用`new`关键字和构造函数创建的对象，使用构造函数`prototype`属性的值作为它们的原型。

`Object.prototype`是为数不多的没有原型的对象，因为它不继承任何属性。

### `Object.create()`

`Object.create()`用于创建一个新对象，使用第一个参数作为新对象的原型：

~~~js
let o1 = Object.create({x:1,y:2});
~~~

传入`null`可以创建一个没有原型的对象。不过这样的新对象不会继承任何东西，

如果想创建一个普通的空队形，可以传入`Object.prototype`

~~~js
let o2= Object.create(Object.prototype);
~~~

## 对象属性

### 查询和设置属性

要获取一个属性的值，可以使用之前介绍的`.`和`[]`操作符：

~~~js
let author = book.author;
let title = book["main tite"];
~~~

如果访问的属性不存在，则返回undefiend

要创建和设置属性，同样使用点或方括号，只是要把它们放到赋值表达式的左边：

~~~js
book.edition = 7;
book["main tite"] ="ECMAScript";
~~~

### 删除属性

delete操作符用于从对象中移除属性:

~~~js
delete book.author;
~~~

delete操作符只删除自有属性，不删除继承属性。

delete不会删除configurable特性为false的属性。

### 测试属性

实际开发中，常常需要测试对象是否有一个给定名字的属性。

为此，可以使用`in`操作符，或者`hasOWnProperty()`、`prepertyIsEnumberable()`方法，或者直接查询相应属性：

~~~js
let o = {x:1};
"x" in o // true
"toString" in o // true
"y" in o // false
~~~

对象的`hasOwnProperty()`方法测试对象是否有给定名字的属性，对继承的属性返回false：

~~~js
let o ={x:1};
o.hasOwnProperty("x"); //true
o.hasOwnProperty("y");//false
o.hasOwnProperty("toString"); //false
~~~

而`propertyIsEnumerable()`方法测试对象属性是否是可枚举的

### 枚举属性

有时候需要遍历和获取对象的所有属性。有几种不同的实现方式：

`for/in`循环对指定对象的内阁可枚举(自有或继承)属性都会运行一次循环体。

对象继承的内置方法是不可枚举的，但自定义添加给对象的属性默认是可枚举的：

~~~js
let o ={
    name : "Alice",
    move : function (){
        console.log("move");
    }
}

for (let p in o){
    console.log(p)
}
~~~

也可以先获取对象所有属性名的数组，然后再通过`for/of`循环遍历该数组。以下函数可以取得属性名数组：

* `Object.keys()`返回对象可枚举自有属性名的数组。
* `Object.getOwnPropertyNames()`返回对象自有属性名的数组。包括不可枚举的属性
* `Object.getOwnPropertySymbols()`返回名字是符号的自由属性，无论是否可枚举
* `Reflect.ownKeys()`返回所有属性名

#### 属性枚举顺序

ES6正式定义了枚举对象自有属性的顺序。`Object.keys()`、`Object.getOwnPropertyNames()`、`Object.getOwnPropertySymbols()`、`Reflect.ownKeys()`、`JSON.stringify()`等相关方法都按照下面的顺序列出属性：

* 先列出名字为非负整数的字符串属性，按照数值从最小到最大。
* 然后再列除所有剩下的字符串名字。这些属性按照它们添加到对象的先后顺序列出。
* 最后，列出名字为符号对象的属性，按照它们添加到对象的先后顺序。

## 扩展对象

在JS中，将一个对象的属性复制到另一个对象上是很常见的，可以使用下面的代码做到：

~~~js
let target = {x: 1};
let source = {y:2 , z:3};
for (let key of Object.keys(source)) {
    target[key] = source[key];
}
target //  {"x": 1,"y": 2,"z": 3}
~~~

在ES6， 这个功能以`Object.assign()`的方式封装进入了JS语句中

`Object.assign()`接受两个或多个对象作为其参数。它会修改并返回第一个参数，第一个参数是目标对象，但不会修改第二个及后续参数，这些都是来源对象。对于每个来源对象，它会把该对象的可枚举自有属性复制到目标对象。

第一个来源对象的属性会覆盖目标对象的同名属性，第二个来源对象的属性会覆盖第一个来源对象的同名属性。以此类推。

~~~js
let target = {x:1,y:2}
let source1 = { y:3,z:4}
let source2 = { z:5 , l:6}
Object.assign(target,source1,source2);
target //{"x": 1, "y": 3,"z": 5,"l": 6}
~~~

## 序列化对象

对象序列化是把对象的状态转换为字符串的过程，这个过程的逆过程称为逆序列化。

函数`JSON.stringify()`和`JSON.parse()`用于序列化和反序列化。这两个函数使用JSON数据交互格式。

JSON表示`JavaScript Object Notation`（JS对象表示法）,语法和JS对象和数组字面量很相似：

~~~js
let o = {x:1,y:{z:[false,null,""]}};
let s = JSON.stringify(o); // {"x":1,"y":{"z":[false,null,""]}}'
let p = JSON.parse(s); //{"x":1,"y":{"z":[false,null,""]}}
~~~

JSON语法时JS语法的子集，不能表示所有的JS的值。可以序列化和反序列化的值包括：对象、数组、字符串、有限数值、布尔值和null。

而`NaN`、`Infinity`和`-Infinity`会被序列化为`null`。函数、RegExp和Error对象以及`undefined`值不能被序列化和反序列化。

`JSON.stringify()`只序列化对象的可枚举自有属性。

后续还会继续介绍这两个方法。

## 对象方法

如前所述，除了那些显示创建为没有原型的对象，其他所有JS对象都从`Object.prototype`继承属性。这些继承的属性主要是方法。

我们之前已经介绍过了`hasOwnProperty()`和`propertyIsEnumerable()`方法了，接下来继续介绍`Object.prototype`定义的几个通用方法

### `toString()`

返回表示调用它的对象的值的字符串。

默认的`toString()`方法并不能提供太多信息。例如：

~~~js
let s = {x:1,y:1}.toString(); //[object Object]
~~~

所以很多类会重新定义自己的`toString()`方法：

~~~js
let o = {
    x:1,
    y:1,
    toString: function () {
        return `(${this.x},${this.y})`
    }
}
let s = o.toString(); //  (1,1)
~~~

### `toLocaleString()`

这个方法的用途是返回对象的本地化字符串表示。

`Object`定义的默认`toLocaleString()`方法本身没有实现任何本地化，而是简单地调用`toString()`并返回该值。

`Number`和`Date`定义了自己的`toLocaleString()`方法。

后续介绍的国际化类可以用于实现`toLocaleString()`方法

### `valueOf()`

JS在需要把对象转换为某些非字符串原始值(通常是数值)时被调用。默认的`valueOf()`放啊发并没有做什么，一些内置类定义了自己的`valueOf()`方法：

~~~js
let o = {
    x:1,
    y:1,
    valueOf : function (){
        return Math.sqrt(this.x*this.x+this.y*this.y)
    }
}
let n = o + 0; // 1.4142135623730951
~~~

### `toJSON()`

`Object.prototype`实际上并没有定义`toJSON()`方法，但是`JSON.stringify()`方法会从要序列化的对象上寻找`toJSON()`方法。如果存在这个方法，就调用它，然后序列化该方法的返回值，而不是原始对象。

~~~js
let o = {
    x:1,
    y:1,
    toString: function () {
        return `(${this.x},${this.y})`;
    },
    toJSON: function (){
        return this.toString();
    }
}
let s = JSON.stringify(o); // "(1,1)"
~~~

## 对象字面量扩展语法

### 简写属性

假设变量x和y中保存着值，如果想创建一个具有属性`x`和`y`且值分别为相应变量值的对象。按照普通的方式，需要把每个标识符重复两次：

~~~js
let x = 1, y = 2;
let o = {
    x: x,
    y: y
}
~~~

在ES6后，可以删除其中的分号和一份标识符，使用简洁的代码达到同样的效果：

~~~js
let x = 1, y = 2;
let o = {x, y}
~~~

### 计算的属性名

有时候，我们需要创建一个具有特定属性的对象，但该属性的名字不是在编译时确定的，无法直接写在源代码中，所以需要将这个属性名保存在一个变量中，或者调用某个函数的返回值。所以，必须先创建一个对象，然后再为它添加想要的属性：

~~~js
let propertyName = "p1" 
function getPropertyName(){
    return "p" +2;
}
//实际可能来自于网络或者用户输入等
let o ={};
o[propertyName] = 1;
o[getPropertyName()] = 2;
~~~

ES6新增了计算属性的特性，可以更简单地创建类似对象,只需要把变量或者函数放在属性名的位置并用中括号括起来：

~~~js
let propertyName = "p1"
function getPropertyName(){
    return "p" +2;
}
//实际可能来自于网络或者用户输入等
let o ={
    [propertyName] : 1,
    [getPropertyName()] : 2
};
~~~

### 扩展操作符

在ES2018及以后，可以在对象字面量中使用“扩展操作符”`...`把已有对象的属性复制到新对象中：

~~~js
let position = {x: 0, y: 0};
let dimensions = {width: 100, height: 75};
let rect = { ...position, ...dimensions}; //{"x": 0, "y": 0, "width": 100, "height": 75}
~~~

和`Object.create()`一样，复制对象到新对象会覆盖原属性

### 简写方法

在把函数定义为对象属性时，我们称该函数为方法。在ES6以前，需要像定义对象的其他属性一样，通过函数定义表达式在独享字面量中定义一个方法：

~~~js
let square = {
    area : function() {return this.side * this.side},
    side : 10
}
~~~

在ES6中，允许一种省略`function`关键字和冒号的简写方法：

~~~js
let square = {
    area() {return this.side * this.side},
    side : 10
}
~~~

### 属性的获取方法和设置方法

JS支持为对象定义访问器属性，这种属性是获取方法和设置方法。

当程序查询一个访问器属性的值时,JS会调用获取方法。这个方法的返回值就是属性访问表达式的值。

当程序设置一个访问器属性的值时，JS会调用设置方法，传入赋值语句右边的值。

如果一个属性既有获取方法也有设置方法，则该属性是一个可读写属性。

如果只有获取方法，那它就是只读属性。如果只有一个设置方法，那它就是只写属性。读取这属性只能得到`undefiend`

~~~js
let o  = {
    x : 1,
    get getX(){
        return this.x;
    },
    set getX(x){
        this.x = x;
    }
}
o.getX;
~~~

下面例子中可以通过获取方法和设置方法 以极坐标的形式访问和设置笛卡尔坐标系下的坐标：

~~~js
let p = {
    x: 1.0,
    y: 1.0,
    get r() {
        return Math.hypot(this.x,this.y);
    },
    set r(newValue){
        let oldValue = this.r;
        let ratio = newValue / oldValue;
        this.x *= ratio;
        this.y *= ratio;
    },

    get theta(){return Math.atan2(this.y,this.x)}
}
p.r;
p.theta;
~~~

和数据属性一样，访问器属性也可以继承。

# 数组

JS数组是一种特殊的JS对象。

数组是值的有序集合，其中的值叫做元素，每个元素都有一个数值表示的位置，叫做索引。

数组中的元素可以是任意类型，同一数组的不同元素也可以是不同类型。

JS中数组是动态的，会按需增大或缩小。

JS中数组可以是稀疏的，即元素不一定具有连续的索引，中间可以有间隙。

每个数组都有`length`。对于非稀疏数组，这个属性保存数组中元素的个数。对于稀疏数组，length大于所有元素的最高索引。

## 创建数组

创建数组有几种方式。接下来会分别介绍：

* 数组字面量
* 对可迭代对象使用`...`操作符
* `Array()`构造函数
* 工厂方法`Array.of()`和`Array.from()`

### 数组字面量

数组字面量是一对方括号中逗号分隔的数组元素的列表：

~~~js
let empty = [];
let misc = [1.1,true,"a",];
~~~

数组字面量中的值不需要是常量，可以是任意表达式：

~~~js
let base = 1024;
let table = [base,base+1,base+2,base+3];
~~~

如果数组字面量中连续包含多个逗号，且逗号之间没有值，则这个数组就是稀疏的，这些省略了值的元组不存在，按照索引查询它们时会返回`undefined`

### 扩展操作符

在ES6以及以后的版本，可以使用扩展操作符`...`在一个数组字面量中包含另一个数组的元素：

~~~js
let a = [1,2,3];
let b = [0,...a,4]; //[0,1,2,3,4]
~~~

扩展操作符适用于任何可迭代对象。字符串是可迭代对象，因此可以使用扩展操作符将任意字符串转换为单个字符的数组：

~~~js
let digits = [..."123"] // ["1","2","3"]
~~~

### `Array()`构造函数

可以使用`Array()`构造函数来创建数组，有三种方式：

* 空参调用`new Array()`，相当于字面量`[]`，创建一个空数组
* 传入一个整数，指定数组长度`new Array(10)`
* 传入两个或者任意多个任意类型的参数，或者1个非数值的参数；这些参数将成为新数组的元组

### `Array.of()`

使用`Array()`构造函数无法创建只包含一个数值元组的数组。

在ES6中，`Array.of()`函数可以解决这个问题。这个工厂方法会将其所有的参数值作为数组元组来创建并返回新数组：

~~~js
Array.of() // []
Array.of(10) // [10]
Array.of(1,2,3) // [1,2,3]
~~~

### `Array.from()`

`Array.from()`是ES6新增的另一个工厂方法。这个方法期待一个可迭代对象或类数组独享作为其第一个参数，并返回包含该对象元素的新数组。

它定义了一种给类数组对象创建真正的数组副本的机制。

`Array.from()`接受第二个可选的参数，如果第二个参数传入了一个函数，那么在构建新数组时，源对象的内阁元素都会传入这个函数，这个函数的返回值将替代原始值成为新数组的元组

~~~js
let a = Array.from("123",function(x){return x *2;}) ; // [2,4,6]
~~~

## 读写数组元素

可以使用`[]`操作符访问数组元组，方括号左侧是对数组的引用，方括号内应该是一个具有非负整数的表达式：

~~~js
let a = ["world"];
let value = a[0];
a[1] = 3.14;
a.length //2
~~~

只要使用小于$2^{32}-1$的非负整数作为数组属性名，这个值会成为数组的索引

如果使用任何不是 小于$2^{32}-1$的非负整数 的数值作为数组属性名。此时值会转换为字符串，这个字符串会成为数组对象的属性。

如果使用了非负整数的字符串来索引数组，这个值也会成为数组索引，而不是对象属性。使用了与整数相等的浮点值也是如此：

~~~js 
a[-1.23] = true  // 创建一个属性 "-1.23"
a["1000"] = 0; // 相当于 a[1000] = 0
a[1.000] = 1 ; //  相当于 a[1] = 1
~~~

对于越加的查询，JS数组只会返回`undefined`不会报错

## 数组长度

对于稠密数组，`length`属性是数组中元素的个数。这个值比数组的最高索引大1

如果给一个索引为i的数组元素赋值，而i大于等于数组当前的`lenght`，则数组的`length`会被设置为`i+1`

~~~js
let a = [1,2,3]
a.length //3
a[100] = 1;
a.length // 101
~~~

如果将length设置为一个小于当前值的非负整数n，则任何索引大于或等于n的数组元素会被从数组中删除

~~~js
let a = [1,2,3]
a.length = 1
a // [1]
~~~

## 添加和删除数组元组

添加一个元素最简单的方式，就是给它的一个新索引赋值:

~~~js
let a =[];
a[0] ="zero"; //添加一个元素
~~~

也可以使用`push()`方法在数组末尾添加一个或多个元素：

~~~js
a.push("zero");
a.push("one","two");
~~~

`a.push(x)`相当于`a[a.lenght] = x`

可以使用delete 操作符删除数组元素：

~~~js
let a = [1,2,3];
delete a[2];
2 in a // false
a.length // 3
~~~

删除数组元素类似于(但不完全等同于)给该元素赋`undefined`值。对数组元素使用`delete`操作符不会修改`length`属性，从数组中删除元素后，数组会变稀疏。

## 数组方法



