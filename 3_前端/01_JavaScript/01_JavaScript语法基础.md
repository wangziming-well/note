# JS简介概述

JavaScript是Web编程语言，绝大多数网站都使用JavaScript。所有现代Web浏览器都包含JavaScript解释器。

而过去十年，Node.js让浏览器外的JavaScript编程称为可能。

JavaScript是一门高级、动态、解释型编程语言，适合面向对象和函数式编程风格。同时它的变量是无类型的。

核心JavaScript语言定义了最小限度的API，可以操作数值、文本、数组、集合、映射等，但不包含任何输入和输出功能。输出和输入以及更复杂的特性是由内嵌了JavaScript的宿主环境负责的

浏览器是JavaScript最早的宿主环境，也是JavaScript代码最常见的运行环境。浏览器环境允许JavaScript代码从用户的鼠标或者键盘或者HTTP请求获取输入，允许JavaScript通过HTML和CSS向用户显示输出.

2010年后，JavaScript代码又有了另一个宿主环境，Node给予了JavaScript访问整个操作系统的权限，运行其读写文件、通过网络发送和接受数据。

# JS词法结构

编程语言的词法结构是一套基本规则，规定了如何使用这门语言，词法结构是一门语言最低级的语法，规定了变量如何命名、注释的定界符、如何分隔语句等。

## JS文本

JS区分大小写，也就是说它的关键字、变量、函数名和其他标识符必须保持大小写一直的形式。

JS忽略程序记号之间的空格。大多数情况下，JS也忽略换行符。因此可以在程序中随意使用空格和换行。

除了常规空格(`\u0020`)，JS也将制表符，各种ASCII控制符和Unicode间隔识别为空格。

JS将换行符、回车符和换行/回车序列识别为终止符。

## 注释

JS支持单行注释和多行注释：

~~~js
// 这是单行注释
/*
这个是多行注释
*/
~~~

## 字面量

字面量是一种直接出现在程序中的数据值，下面都是字面量：

~~~js
12 //数值12
1.2 //数值1.2
"Hello world"//字符串
'hi' //字符串
true false //布尔值
null //无对象
~~~

## 标识符和保留字

标识符就是名字，在JS中标识符用于命名变量、常量、属性、函数和类，以及循环标记(label)

JS的标识符必须以字母、下划线(`_`)和美元符号(`$`)开头,后续字符可以是字母、数字、下划线或美元符号。

JS为语言自身使用而保留了某些标识符，这些保留字不能作为常规的标识符使用，

## 可选的分号

JS使用分号`;`作为分隔语句。

但是如果两条语句分别写在两行，通常可以省略它们之间的分号

例如：

~~~js
a = 3 ; b = 4 ;
~~~

中，分号是必要的，但是

~~~js
a = 3 ;
b = 4 ;
~~~

的分号可以省略

另外JS只在下一个空格符无法被解释为当前语句的一部分时才会将其当做分号，例如：

~~~js
let a 
a 
=
3
console.log(a)
~~~

js将其解释为：

~~~js
let a ; a = 3 ; console.log(a);
~~~

# 类型、值和变量

JS类型可以分为两类：原始类型和对象类型。

JavaScript的原始类型包括数值、字符串、布尔值。特殊值null和undefined也是原始值，这两个值通常被认为是各自特殊类型的唯一成员。

除上述原始类型外，JS中的其他值都是对象。对象是属性的集合，其中每个属性都有一个名字和一个值(原始值或者其他对象)。

接下来介绍的类型为JS中的原始类型。

## 数值

Number类型用于表示整数和小数。Number可以表示$[-2^{53},2^{53}]$之间的所有整数。如果超出了这个范围就会损失精度。

JS程序中出现的数值称为数值字面量。

### 整数字面量

JS中支持10进制和16进制的字面量,10进制是直接表示的，16进制需在开头用0X或者0x表示：

~~~js
53 //10进制 53
0xff // 16进制 255
~~~

在ES6及以后的版本，也支持二进制和八进制的字面量，分别用前缀0b 和 0o表示：

~~~js
0b10101 //二进制 21
0o377 //八进制 255 
~~~

### 浮点字面量

浮点字面量可以包含小数点。可以表示实数，实数值由数值的整数部分、小数部分和小数点组成。

浮点字面量也可以使用指数计数法,形式为：

~~~js
[digits][.digits][(E|e)[(+|-)digits]]
~~~

如：

~~~js
3.14
.3333
6.02e23 // 6.02* 10^23
~~~

## 文本

JS中表示文本的类型是String，即字符串。字符串是16位值的不可修改的有序序列，每个值都表示一个Unicode字符。字符串的length属性是它包含的16位值的个数。JavaScript的字符串使用基于0的索引。

### 字符串的字面量

字符串的字面量可以把字符串放到一对单引号、栓引号或者反引号中。

双引号和反引号可以出现在由单引号界定的字符串中，同理由双引号和反引号界定的字符串也可以包含另外两种引号：

~~~js
"" //空
'test'
"Don't like you"
` “She said 'hi'",he said.`
~~~

使用反引号定界字符串是ES6的特性，允许字符串字面量中插入JS表达式。后续会再介绍。

JS最早的版本要求字符串字面量必须写在一行，对于长字符串需要使用+操作符将单行字符串拼接。

ES5版本可以在行末尾加一个反斜杠从而把字符串字面量写到多行上。

如果要在字符串字面量中表示换行，需要使用字符序列`\n`，也可以使用反引号，ES6的反引号支持跨行的字符串

~~~js
"two\nlines" //写在一行表示两行的字符串
"one\
 long\
 line" //写在三行但只表示一行的字符串
`one
 two` //写在两行实际也表示两行的字符串
~~~

### 转义序列

反斜杠`\`在JS字符串中有特殊的作用：它与后面的字符组合在一起，可以在字符串中表示一个无法直接表示的字符。如`\n`Z表示换行符的转义序列

又如在单引号表示的字符串中，`\'`表示单引号：

~~~js
'don\'t like' //表示 don't like
~~~

下表列出JS中转移序列以及表示的字符：

| 序列     | 表示的字符                                                   |
| :------- | :----------------------------------------------------------- |
| `\0`     | NUL字符(\u0000)                                              |
| `\b`     | 退格符(\u0008)                                               |
| `\t`     | 水平制表符Tab(\u0009)                                        |
| `\n`     | 换行符(\u000A)                                               |
| `\v`     | 垂直制表符(\u000B)                                           |
| `\f`     | 换页(\u000C)                                                 |
| `\r`     | 回车符(\u000D)                                               |
| `\"`     | 双引号 (\u0022)                                              |
| `\'`     | 单引号 (\u0027)                                              |
| `\\`     | 反斜杠 (\u005C)                                              |
| `\xnn`   | 由2位16进制nn指定的Unicode字符                               |
| `\xnnnn` | 由4位16进制nn指定的Unicode字符                               |
| `\u{n}`  | 由码点n指定的Unicode字符，n是介于0到10FFFF之间的1到6位16进制数字(ES6) |

### 使用字符串

可以用`+`操作符拼接字符串，例如：

~~~js
let msg = "Hello," + "world";
~~~

可以使用全等`===`和不全等`!==`操作符来比较字符串。

可以通过字符串的`length`属性来获取字符串的长度

除此之外，JS还提供了操作字符串的丰富API，这里不做赘述

### 模板字面量

在ES6及以后的版本中，字符串字面量可以用反引号来定界：

~~~js
let s = `hello world`;
~~~

不过，这不仅仅是一种新的字符串字面量语法，因为模板字面量可以包含任何JS表达式。反引号中字符串字面量最终值的计算，涉及对其中包含的所有表达式求值，并将表达式的值转换为字符串，再把这些字符串 与反引号中的字面量组合：

~~~js
let name = "Bill";
let greeting = `Hello ${ name }.` // greeting = "Hello Bill."
~~~

位于`${}`之间的内容会被当做JS表达式来解释。

## 布尔值

布尔类型表示真和假，这个类型只有两个值`true`和`false`

布尔值在JS通常用于控制结构。

JS中任何值都可以转换为布尔值。

## null和undefined

`null`是一个关键字，通常用于表示某个值不存在。对`null`用`typeof`返回字符串`object`.表明可以将null看成一种特殊对象，表示“没有对象”。

在实践中，`null`通常被当做它自己类型的唯一对象，可以用来表示数值、字符串以及对象“没有值”

`undefined`也表示值不存在，但是`undefined`表示一种更深层次的不存在。

更具体的说：

* 变量的值未初始化时就是`undefined`
* 查询不存在的对象属性或者数组元素时会得到`undefined`
* 没有明确返回值的函数返回的值是`undefined`
* 没有传值的函数参数的值也是`undefined`。

`undefined`是一个预定义的全局常量，这个常量的初始化值就是`undefined`（而非null这样的语言关键字）

对`undefined`应用`typeof`会返回`“undefined”`，表示这个值是该特殊类型的唯一对象。

`null`和`undefined`都可以表示某个值不存在,经常被混用。相等操作符`==`人为它们相等，只有全等操作符`===`可以区分它们。因为它们都是假性值，在需要布尔值的情况下，它们都可以当做false使用。

## 全局对象

全局对象的属性是全局性定义的标识符，可以在JS程序的任何地方使用。JS解释器启动后(或者浏览器加载新页面时)，都会创建一个新的全局对象并为其添加一组初始的属性，定义了：

* `undefined`、`Infinity`和`NaN`这样的全局常量

* `isNaN()`，`parseInt()`、和`eval()`这样的全局函数
* `Data()`、`RegExp()`、`String`、`Object()`和`Array()`这样的构造函数

* `Math`和`JSON`这样的全局对象

全局对象的初始属性并不是保留字，但是它们都应该被当做保留字 。

在Node中，全局对象有一个名为global的属性，其值为全局对象本身，因此Node程序中始终可以通过global来引用全局对象

在浏览器中，Window对象对浏览器窗口中的所有JavaScript代码而言，充当了全局对象的角色。这个全局的Window对象有一个自引用的window属性，可以引用全局对象。Window对象定义了核心全局属性，也定义了其他一些特定于浏览器和客户端JavaScript的全局只。

ES2020最终定义了globalThis作为在任何上下文中引用全局对象的标准方式。

## 类型转换

JS对自己所需要的类型非常灵活。

如果需要某个类型A，那么即使提供的是类型B，JS也会尝试将B转换为类型A使用：

如果JS需要一个布尔值，JS会将提供的任何值转换为布尔值

如果JS需要字符串，JS会将提供的任何值转换为字符串

如果JS需要数值，JS会尝试将提供的值转换为一个数值(如果无法进行有意义的转换就转换为NaN)

例如:

~~~js
10 + "objects" // "10 obejcts"
"7" * "3" //21
1 - "x" // NaN
1 - "x" + "objects" // "NaN objects"
~~~

JavaScript中常见的类型转换如下：

| 值                        | 转换为字符串     | 转换为数值 | 转换为布尔值 |
| ------------------------- | ---------------- | ---------- | ------------ |
| `undefined`               | `"undefined"`    | `NaN`      | `false`      |
| `null`                    | `"null"`         | `0`        | `false`      |
| `true`                    | `"true"`         | `1`        |              |
| `false`                   | `"false"`        | `0`        |              |
| `""`                      |                  | `0`        | `false`      |
| `"1.2"`                   |                  | `1.2`      | `true`       |
| `"one"`                   |                  | `NaN`      | `true`       |
| `0`                       | `"0"`            |            | `false`      |
| `-0`                      | `"0"`            |            | `false`      |
| `1`                       | `"1"`            |            | `true`       |
| `Infinity`                | `"Infinity"`     |            | `true`       |
| `-Infinity`               | `"-Infinity"`    |            | `true`       |
| `NaN`                     | `"NaN"`          |            | `false`      |
| `{}`(任何对象)            | 后续讨论         | 后续讨论   | `true`       |
| `[]`(空数组)              | `""`             | `0`        | `true`       |
| `[9]`(一个数值元素)       | `"9"`            | `9`        | `true`       |
| `['a']`(任何其他数组)     | 使用`join()`方法 | `NaN`      | `true`       |
| `function (){}`(任何函数) | 后续讨论         | `NaN`      | `true`       |

## 相等

JS有两个操作符用于测试两个值是否相等

* 严格相等操作符`===`，必须两个值的类型和实际值都相等，才会判定相等
* 相等操作符`==`，只需要两个值经过类型转换后的值相等，就判定相等

如：

~~~js
null == undefined // true
"0" == 0 //true
~~~

## 显示转换

尽管JS会自动执行很多类型的转换，但有时候我们也需要进行显示转换，或者有意进行显示转换以保证代码清晰

执行类型转换最简单的方式是使用以下函数：

~~~js
Number("3") // 3
String(false) // "false"
Boolean([]) // true
~~~

除`null`和`undefined`之外所有的值都有`toString()`方法，以获取值对应的字符串值。

Number类定义的`toString()`方法有一个可选的参数，用于指定一个进制数，表示将值转换为指定的进制字符串：

~~~js
let n = 17;
let binary = "0b" + n.toString(2); // binary = "0b10001"
~~~

## 变量声明与赋值

在JS中使用变量或常量前，必须先声明它。在ES6及之后的版本，是通过`let`和`const`关键字来完成的，在ES6之前，变量是通过`var`声明的

### 使用`let`和`const`声明

在ES6及之后，JS中变量是通过`let`关键字声明的：

~~~js
let i ;
let sum;
~~~

也可以使用一条`let`语句声明多个变量：

~~~js
let i, sum;
~~~

在声明变量的同时，如果可能，为其赋予一个初始值是一个好的习惯：

~~~js
let message = "hello";
let i = 0 , j = 0 , k = 0;
~~~

如果`let`语句中不为变量指定初始值，那么在赋值之前它的值为`undefined`

使用`const`声明常量。`const`与`let`类似，但`cosnt`在声明时必须初始化常量：

~~~js
const C = 299792.458
~~~

常量值不可改变，尝试给常量重新赋值会抛出`TypeError`

常量名约定俗成地全部使用大写字母以区别于变量。

### 作用域

JS中代码块有类和函数的函数体，if/else语句的语句体、while和for循环的循环体。

变量的作用域时程序源代码中的一个区域，在这个区域内变量有定义。

通过`let`和`const`声明的变量和常量具有块作用域。这意味着它们只在`let`和`const`语句所在的代码块中有定义。

如果声明位于顶级，在任何代码块外部，则称为全局变量和常量，具有全局作用域。

### 使用`var`声明

在ES6之前的JS中，声明变量的唯一方式是使用`var`关键字，无法声明常量。

`var`的语法和`let`的语法相同：

~~~js
var x; 
var data  =[],a =3;
~~~

虽然`var`和`let`有相同的语法，但它们也有重要的区别：

* 使用`var`声明的变量不具有块作用域。这种变量的作用域仅限于包含函数的函数体，无论它们在函数中嵌套的层次有多深。(即var变量的作用域就是它们所在的函数体)
* 如果在函数体外部使用`var`，则会声明一个全局变量。但`var`声明的全局变量和`let`声明的全局变量有重要区别：
  * `var`声明的全局变量被实现为全局对象的属性。可以通过`globalThis`来引用该变量。
  * `let`声明的全局变量不是全局对象的属性

* 和`let`不同，使用`var`多次声明同名变量是合法的。
* `var`有作用域提升的特性。在使用`var`声明变量时，在编译时该声明会被提高到函数的顶部。所以我们可以在代码中声明这个变量的位置之前使用这个变量

### 解构赋值

ES6实现了一种复合声明和赋值语法，叫做解构赋值。

在解构赋值中，等号右边时数组或对象(结构化的值)，左边通过模拟数组或对象字面量语法指定一个或者多个各变量：

~~~~js
let [x,y] = [1,2];  //相等于 let x = 1, y =2;
[x,y] = [x+1,y+1];
~~~~

这种解构赋值也可能作为函数的返回值：

~~~js
function toPolar(x,y){
    return [Math.sqrt(x*x+y*y),Math.atan2(y,x)];
}

let [r,theta] = toPolar(1,1);
~~~

解构赋值左侧变量个数不一定和右侧数组中元素个数相同。左侧多余的变量会被设置为`undefined`，而右侧多余的值会被忽略。左侧的变量列表可以包含额外的逗号，以跳过右侧的某些值：

~~~js
let [x,y] = [1]; //x == 1 ; y == undefined
[x,y] = [1,2,3]; //x == 1 ; y == 2
[,x,y] = [1,2,3,4]; // x == 2 ; y == 4
~~~

在解构赋值时，如果想要把所有未使用或者剩余的值收集到一个变量中，可以在左侧最后一个变量名前加上三个点(`...`):

~~~js
let[x,...y] = [1,2,3,4] ; // y == [2,3,4]
~~~

解构赋值可用于嵌套数组。此时，赋值的左侧看起来也应该像一个嵌套的数组字面量：

~~~js
let[a,[b,c]] = [1,[2,2.5],3] ; // a == 1 ; b == 2 ; c == 2.5
~~~

解构赋值不要求必须时数组，事实上，赋值的右侧可以是任何可迭代对象：

~~~js
let [first,...rest] = "Hello"; // first == "H" ; rest == ["e","l","l","o"]
~~~

解构赋值在右侧是对象值的情况下也可以执行。此时，赋值的左侧看起来像一个对象字面量：

~~~js
let transparent = {
    r: 0.0,
    g: 0.0,
    b: 0.0,
    a: 1.0
}
let {r,g,b} = transparent; // r == 0.0 ; g == 0.0 ; b == 0.0
~~~

# 表达式和操作符

表达式是一个可以被求值并产生一个值的JavaScript短语。

直接嵌入在程序中的常量是最简单的表达式。变量名也是简单的表达式。

复杂表达式由简单表达式构成。基于简单表达式构建复杂表达式最常见的方式是使用操作符。

## 主表达式

最简单的表达式称为主表达式，即那些独立存在，不再包含更简单表达式的表达式。JS中的主表达式包括常量或字面量值、某些语言关键字和变量引用

字面量是可以直接嵌入到程序中的常量值:

~~~js
1.23
"hello"
/pattern/
~~~

JS中一些保留字也是主表达式：

~~~js
true
false
null
this
~~~

变量、常量或全局对象属性的引用也是主表达式：

~~~js
i 
sum
undefined
~~~

## 对象和数组初始化程序

对象和数组初始化程序也是一种表达式，其值为新创建的对象或数组。这些初始化程序表达式有时候也被称为对象字面量和数组字面量。但和真正的字面量不同，它们不是主表达式。

数组初始化程序是一个包含在方括号内的逗号分隔的表达式列表。其值为新创建的数组：

~~~js
[] //空数组
[3+1,5+5]
~~~

数组初始化程序中的元素表达式本身也可以是数组初始化程序，即嵌套数组：

~~~js
let matrix = [[1,2,3],[4,5,6],[7,8,9]];
~~~

在数组字面量中省略逗号间的值可以包含未定义的元素：

~~~js
let sparseArray = [1,,,,5];
~~~

对象初始化程序表达式与数组初始化程序表达式类似，但是由花括号界定，并且内阁子表达式前多了一个属性名和冒号：

~~~js
let p = {
    x:2.4
    y:-1,2
};
let q = {} //空对象
~~~

## 函数定义表达式

函数定义表达式定义JavaScript函数，其值为新定义的函数。某种意义上说，函数表达式也是函数字面量。

函数定义表达式通常由关键字`function`、参数列表和函数体构成,例如：

~~~js
let square = function(x){
    return x *x;
} //返回一个计算平方的函数
~~~

函数定义表达式也可以包含函数的名字。函数也可以使用函数语句而非函数表达式来定义

## 属性访问表达式

属性访问表达式求值为对象属性或者数组元素的值：

~~~js
expression.identifier
expression[expression]
~~~

第一种属性访问语法是表达式后跟一个句点和一个标识符：表达式指定对象，标识符指定属性名

第二种属性访问语句是表达式后跟另一个位于方括号中的表达式。第二个表达式指定属性名或者数组元素的索引：

~~~js
let o = {x:1, y:{z:3}};
let a = [o,4,[5,6]];
o.x // 1
o["x"]  //1 
o.y.z //3
a[1] // 4
a[0].x // 1
~~~

如果`.`或`[`前的表达式结果为`null`或者`undefined`，那么表达式会抛出`TypeError`。

如果指定名字的属性不存在，则结果为`undefined`

### 条件式属性访问

ES2020新增两个新的属性访问表达式：

~~~js
expression?.identifier
expression?.[expression]
~~~

之前已经提到，如果左侧的表达式的结果是null或者undefined，属性访问表达式会报TypeError。那么可以使用上述表达式避免错误发生。

如果左侧的表达式的结果是null或者undefined，带问号`?`的求值结果就是`undefined`而不会报错。

~~~js
let a = {b:{}};
a.b?.c // undefined
~~~

## 调用表达式

调用表达式时JS中调用(执行)函数或方法的一种语法。表达式开头是结果为函数的表达式，后面跟着一对圆括号，括号中间是一列可选的函数表达式：

~~~js
f(0);
Math.max(x,y,z)
a.sort()
~~~

求值调用表达式时，首先求值函数表达式，然后求值参数表达式以产生参数值的列表。

如果函数表达式的值不是函数，会抛出TypeError.然后，按照函数定义时参数的顺序给参数赋值，之后执行函数体。

如果函数使用了return语句返回一个值，则该值就成为调用这个表达式的值。否则调用表达式的值就是`undefined`。

## 操作符概述

操作符在JavaScript中用于算数表达式、比较表达式、逻辑表达式、赋值表达式等

JavaScript中所有的操作符

| 操作符                                                  | 操作                         | 结合性 | 操作数 | 类型                  |
| ------------------------------------------------------- | ---------------------------- | ------ | ------ | --------------------- |
| `++`                                                    | 递增                         | 右     | 1      | $lval\to num$         |
| `--`                                                    | 递减                         | 右     | 1      | $lval\to num$         |
| `-`                                                     | 负值                         | 右     | 1      | $num\to num$          |
| `+`                                                     | 转换为数值                   | 右     | 1      | $any\to num$          |
| `~`                                                     | 二进制取反                   | 右     | 1      | $int\to int$          |
| `!`                                                     | 布尔值取反                   | 右     | 1      | $bool\to bool$        |
| `delete`                                                | 删除属性                     | 右     | 1      | $lval\to bool$        |
| `typeof`                                                | 确定操作数类型               | 右     | 1      | $any \to str$         |
| `void`                                                  | 返回undefined                | 右     | 1      | $any\to undef$        |
| `**`                                                    | 幂                           | 右     | 2      | $num,num\to num$      |
| `* / %`                                                 | 乘、除、取余                 | 左     | 2      | $num,num\to num$      |
| `+ -`                                                   | 加、减                       | 左     | 2      | $num,num\to num$      |
| `+`                                                     | 拼接字符串                   | 左     | 2      | $str,str\to str$      |
| `<<`                                                    | 左移位                       | 左     | 2      | $int,int \to int$     |
| `>>`                                                    | 右移位以符号填充             | 左     | 2      | $int,int \to int$     |
| `>>>`                                                   | 右移位以零填充               | 左     | 2      | $int,int \to int$     |
| `< <= > >=`                                             | 按数值顺序比较               | 左     | 2      | $num,num\to bool $    |
| `instanceof`                                            | 测试对象类                   | 左     | 2      | $obj,func\to bool$    |
| `in`                                                    | 测试属性是否存在             | 左     | 2      | $any,obj\to bool$     |
| `==`                                                    | 非严格相等测试               | 左     | 2      | $any,any\to bool$     |
| `!=`                                                    | 非严格不相等测试             | 左     | 2      | $any,any\to bool$     |
| `===`                                                   | 严格相等测试                 | 左     | 2      | $any,any\to bool$     |
| `!==`                                                   | 严格不相等测试               | 左     | 2      | $any,any\to bool$     |
| `&`                                                     | 按位与                       | 左     | 2      | $int,int\to int$      |
| `^`                                                     | 按位异或                     | 左     | 2      | $int,int\to int$      |
| `|`                                                     | 按位或                       | 左     | 2      | $int,int\to int$      |
| `&&`                                                    | 逻辑与                       | 左     | 2      | $any,any\to any$      |
| `||`                                                    | 逻辑或                       | 左     | 2      | $any,any\to any$      |
| `??`                                                    | 选择                         | 左     | 2      | $any,any\to any$      |
| `?:`                                                    | 选择第二或第三个操作数       | 右     | 3      | $bool,any,any\to any$ |
| `=`                                                     | 为变量或属性赋值             | 右     | 2      | $lval,any\to any$     |
| `ope=<br />`<br />其中ope为二元操作符<br />如：` *=,+=` | 操作并赋值                   | 右     | 2      | $lval,any\to any$     |
| `,`                                                     | 丢弃第一个操作数，返回第二个 | 左     | 2      | $any,any\to any$      |

其中`lval`为`lvalue`左值，意思时“一个可以合法地出现在赋值表达式左边的表达式”，在JS中，变量，对象属性和数组元素都是左值。

## 算术表达式

基本的算数操作符是`** * / % + -`

除了`+`，其他的操作符都会对自己的操作数进行求值，必要时将操作数转换为数值，然后进行计算。无法转换为数值的非数值操作数则转换为`NaN`。如有右操作数为`NaN`，则算数操作符的结果是`NaN`

### `+`操作符

二元`+`操作符用于计算数值操作数的和或者拼接字符串操作数：

~~~js
1 +2  // 3
"hello" +" there" //"hello there"
~~~

如果两个操作数都是数值或者都是字符串，`+`操作符执行结果当然也是数值或者字符串，但是除了这两种情况，都会涉及类型转换

严格来讲，`+`操作符的行为如下：

* 首先，如果操作数中有对象，则首先将对象转换为原始值(通过`valueOf()`方法，如果没有，则用`toString()`转换)
* 然后，如果有操作数是字符串，另一个操作数也会被转换为字符串进行拼接
* 否则，两个操作数都会被转换为数值(或NaN)，计算加法

### 一元算术操作符

一元操作符修改一个操作数的值以产生一个新值。JS中一元操作符具有高优先级和右结合性。

* 一元加`+`

  将操作数转换为数值(或NaN)并返回转换后的值。如果操作数是数值，则它什么也不做。

* 一元减`-`

  将操作数转换为数值，然后改变结果的符号

* 递增`++`

  递增其操作数，操作数必须是一个左值，`++`操作符的返回值取决于它与操作数的相对位置
  
  * 如果`++`位于操作数前面，则称为前递增操作符，返回的是递增后的值
  * 如果`++`位于操作数后面，则称为后递增操作符，返回的是递增前的值
  
  例如：
  
  ~~~js
  let i = 1,j == ++i ; // j == 2
  let n = 1,m == n++ ; // m == 1 
  ~~~
  
* 递减`--`

  递减其操作数，操作数同样是一个左值，`--`操作符的返回值同样取决于它和操作数的相对位置

  * 如果`--`位于操作数前面，则称为前递减操作符，返回的是递减后的值
  * 如果`--`位于操作数后面，则称为后递递减作符，返回的是递减前的值

### 位操作符

位操作符对数值的二进制表示执行位操作。

位操作符首先将操作数转换位数值，再将得到的数值转换位32位整数。

`NaN infinity -infinity`再作为位操作符的操作数时会转换位0.

* 按位与`&`

  对其整数参数的每一位执行布尔与操作，只有两个操作数对应的位都为1，结果中的对应的位才为1

* 按位或`|`

  对其整数参数的每一位执行布尔或操作，只要两个操作数对应的位至少有一个是1，结果中对应的位就为1

* 按位异或`^`

  对其整数参数的每一位执行布尔异或操作，只有两个操作数对应的位一个为0一个为1时，结果中对应的位才为1

* 按位非`~`

  是一元操作符，反转操作数中的所有位

* 左移`<<`

  将第一个操作数的所有位向左移动第二个操作数指定的位数，第二个操作数应该是介于0~31之间的整数

  在移动时，新的低位会填充为0，高于32位的部分被丢弃

* 有符号右移`>>`

  将第一个操作数的所有位向右移动第二个操作数指定的位数(0~31)。移出右边的位会被丢弃。

  填充到左边的位取决于原始操作数的符号，以便和结果保持相同的符号。

* 无符号右移`>>>`

  与`>>`类似，只是左侧移动的位始终填充0

## 关系表达式

关系操作符测试两个值之间的关系，并根据相应关系是否存在返回布尔值。

### 相等和不相等操作符

`==`和`===`检查两个值是否相同。但`===`被称为严格相等操作符，它根据严格相同的定义检查两个操作数是否完全相同。

`==`根据更宽松的相同定义检查两个操作数是否相等

`!=`和`!==`返回的结果和`==`和`===`相反

**严格相等**

`===`按照以下标准比较两个值，不做类型转换：

* 如果两个值类型不同，则不相等
* 如果两个值都是`null`或者都是`undefined`，则相等
* 如果两个值都是布尔值，并且都是`true`或者都是`false`则相等
* 如果一个或者两个值是`NaN`，则不相等(所以，要检查一个值是不是NaN,需要使用`x!==x`或者全局`isNaN()`函数)
* 如果两个值都是数值且值相同，则相等
* 如果两个值都是字符串并且相同位置的值相同，则相等。
* 如果两个值引用同一个对象、数组或者函数，则相等。如果它们引用不同的对象，即使两个对象有完全相同的属性，也不相等。

**非严格相等**

对于`==`操作符，如果两个操作数的值类型不同，它会尝试做类型转换，然后再比较：

* 如果两个值类型相同，则按照严格相等的规则测试，如果严格相等则相等，否则不相等
* 如果两个值类型不同，它会使用以下规则，基于类型转换来判定相等关系
  * 如果一个值为`null`一个值为`undefined`则相等
  * 如果一个值为数值，一个值为字符串，把字符串转换为数值，再比较转换后的值
  * 如果有一个值为`true`把它转换为1再比较。如果有一个值为`false`则把它转换为0再比较
  * 如果一个值是对象，另一个值是数值或者字符串，则先把对象转换为原始值，再进行比较
  * 其他任何类型的组合都不相等

### 比较操作符

 比较操作符测试操作数的相等顺序(数值或字母表顺序)，比较操作符有`< > <= >=`四个

这几个操作符的操作数可以是任何类型，但比较只针对数值和字符串，因此其他类型的操作数会先进行类型转换

比较和转换规则如下：

* 如果有操作数求值为对象，对象首先会转换为原始值
* 对象类型转换后，如果两个操作数都是字符串，按照字母顺序表比较两个字符串，即16位Unicode值的数值顺序
* 对象类型转换后，如果有1个或者2个操作数不是字符串，则两个操作数都会被转换为数值
  * 0和-0被认为是相等
  * `Infinity`比它本身之外的任何数都打
  * `-Infinity`比它本身之外的任何数都下
  * 如果任意一个操作数是`NaN`，则返回值为false

### `in`操作符

in操作符左侧操作数是字符串、符号或者可以转换为字符串的值，右侧操作数是对象。

如果左侧的值是右侧的对象的属性名，则in返回true

例如：

~~~js
let point = {
    x : 1,
    y : 1
};
"x" in point //true
"toString" in point //true 对象继承了toString方法
let data = [7,8,9];
"0" in data //true
1 in data //true
~~~

### `instanceof`操作符

`instanceof`操作符左侧操作数是对象，右侧操作数是对象类的标识。

这个操作符的左侧对象是右侧类的实例时求值为true：

~~~js
let d = new Data();
d instanceof Date //true
d instanceof Object //true
d instanceof Number // false
let a = [1,2,3];
a instanceof Array //true
a instanceof Object // true
a instanceof RegExp //false
~~~

### 逻辑表达式

逻辑操作符`&& || !`执行布尔代数操作。如果操作数不是布尔值，那么逻辑操作符会先将操作数转换为布尔值之后再进行操作。

* `&&`一假即假，短路操作
* `||`一真即真，短路操作
* `!`取反

`!`的优先级比`&& ||`高

## 赋值表达式

JS使用`=`操作符为变量胡总和属性赋值：

~~~js
i = 0;
o.x = 1;
~~~

`=`操作符左侧操作数是左值，即变量，对象属性或则和数组元素。右侧操作数是任意类型的任意值。

赋值表达式的值是右侧操作数的值。

可以通过如下代码将一个值赋给多个变量：

~~~js
i = j = k = 0;
~~~

### 操作赋值

JS提供形如` a op= b`的赋值操作符，这些操作符通过组合其他二元操作符提供了快捷操作。实际相当于`a = a op b`

例如`a += 2` 即为`a = a + 2`

## 求值表达式











## 其他操作符





# 语句

