# 简介

在web服务器中，高可用是指服务器可以正常访问的时间，衡量的标准是在多长时间内可以提供正常服务。但是在Redis语境中，高可用的含义似乎要宽泛一些，除了保证提供正常服务( 如主从分离、快速容灾技术)，还需要考虑数据容量的扩展、数据安全不会丢失等。

在Redis中，实现高可用的技术主要包括持久化、主从复制、哨兵和cluster集群：

* 持久化： 持久化是最简单的高可用方法（有时甚至不被归为高可用的手段），主要作用是数据备份，即将数据存储在硬盘，保证数据不会因进程退出而丢失。
* 主从复制： 主从复制是高可用Redis的基础，哨兵和集群都是在主从复制基础上实现高可用的。主从复制主要实现了数据的多机备份（和同步），以及对于读操作的负载均衡和简单的故障恢复。缺陷：故障恢复无法自动化；写操作无法负载均衡；存储能力受到单机的限制。
* 哨兵： 在主从复制的基础上，哨兵实现了自动化的故障恢复。（主挂了，找一个从成为新的主，哨兵节点进行监控）缺陷：写操作无法负载均衡；存储能力受到单机的限制。
* Cluster集群： 通过集群，Redis解决了写操作无法负载均衡，以及存储能力受到单机限制的问题，实现了较为完善的高可用方案。（6台起步，3主3从）

# 持久化

Redis支持RDB和AOF两种持久化机制， 持久化功能有效地避免因进程退出造成的数据丢失问题， 当下次重启时利用之前持久化的文件即可实现数据恢复。  

## RDB

RDB(Redis Database)持久化是当前进程数据生成快照保存到硬盘的过程，触发RDB持久化过程分为手动触发和自动触发

### 触发机制

可以使用save和bgsave命令设置手动触发

* save命令：阻塞当前Redis服务器，直到RDB过程完成。当Redis实例内存很大时，会造成长时间阻塞，线上环境不建议使用
* bgsave命令：Redis进程执行fork操作创建子进程，RDB持久化过程由子进程负责，完成后自动结束。阻塞只发生再fork阶段，一般时间很短。

除了手动触发外，Redis内部还存在自动触发RDB持久化的机制，如下场景会自动触发bgsave：

* 配置文件中使用`save`配置，如`save m n`表示m秒内数据集存在n次修改时
* 如果从节点执行全量复制操作，主节点自动执行bgsave生成RDB文件并发送给从节点
* 执行debug reload命令重新加载Redis时
* 默认情况下执行shutdown命令时，如果没有开启AOF持久化功能则自动执行bgsave

### bgsave流程

bgsave是主流的触发RDB持久化方式，它的工作流程如下：

* 执行bgsave命令， Redis父进程判断当前是否存在正在执行的子进程， 如RDB/AOF子进程， 如果存在bgsave命令直接返回

* 父进程执行fork操作创建子进程， fork操作过程中父进程会阻塞；通过info stats命令查看latest_fork_usec选项， 可以获取最近一个fork操作的时，单位为微秒 
* 父进程fork完成后，bgsave命令返回“Background saving started”信息并不再阻塞父进程， 可以继续响应其他命令
* 子进程创建RDB文件， 根据父进程内存生成临时快照文件， 完成后对原有文件进行原子替换 ；执行lastsave命令可以获取最后一次生成RDB的时间， 对应info统计的rdb_last_save_time选项  
* 进程发送信号给父进程表示完成， 父进程更新统计信息， 具体见info Persistence下的rdb_*相关选项  

### RDB文件的处理

RDB文件保存在`dir`配置指定的目录下，默认为`./`，文件名通过`dbfilename`配置指定

可以通过执行`config set dir newDir`和`config set dbfilename fileName`运行时动态更改配置。当遇到坏盘或者磁盘写满等情况时，可以通过上述命令修改文件路径到可用的磁盘路径。

Redis默认采用LZF算法对生成的RDB文件做压缩处理，压缩后的文件远远小于内存大小，默认开启。可以通过`rdbcompression {yes|no}`配置，也可以通过`config`命令动态修改。

虽然压缩RDB会消耗CPU，但是可以大幅降低文件的体积，方便保存到硬盘和通过网络发送到从节点，因此线上建议开启。

### 优缺点

优点：

* RDB是紧凑压缩的二进制文件，是Redis某个时间点上的数据快照，非常适合用于进行备份、灾备和全量复制的场景。
* Redis加载RDB回复数据远快于AOF的方式

* 是由子进程来处理生成RDB文件的工作的，主进程不进行任何的IO操作，不会影响redis的读写性能

缺点：

* 没有办法做到实时持久化，因为bgsave每次运行fock操作创建子进程属于重量级操作，不能频繁执行；所以最后一次持久化后的数据可能丢失，有一定的数据安全风险
* RDB使用特定二进制格式保存，新老版本Redis之间可能不兼容

## AOF

(Append-only File）AOF持久化：以独立日志的形式来记录每次写命令，重启时再重新执行AOF文件中的命令以达到恢复数据的目的。









持久化过程：

* 客户端的请求写命令会被append追加到AOF缓冲区内
* AOF缓冲区根据AOF持久化策略将操作sync同步到磁盘的AOF文件中
* AOF文件大小超过重写策略或手动重写时，会对AOF文件rewrite重写，压缩AOF文件容量
* Redis服务重启时，会重新load加载AOF文件中的写操作达到数据恢复的目的

配置redis.conf:

* `appendonly`是否开启aof持久化，默认为no，改为yes开启

* `appendfilename`指定AOF文件名，默认文件名为appendonly.aof

* `dir`指定RDB和AOF文件存放的目录，默认是./

* `appendfsync`配置aof文件写命令数据的策略：

  * `no`不主动进行同步操作，完全交由操作系统来做(每30s一次)
  * `always`每次执行写入修改都会执行同步
  * `everysec`每秒执行一次同步操作

* `auto-aof-rewrite-min-size`允许重写的最小AOF文件大小，默认为64M

  当aof文件大于64M时，开始整理aop文件，去掉无用的操作命令(只保存对key的最后一次修改操作)

优点：

* 备份机制更稳健，丢失数据概率更低

* 可读的日志文本，通过操作AOF文件，可以处理误操作

缺点：

* 比起RDB占用更多的磁盘空间
* 恢复备份速度要慢
* 每次读写都同步的话，有一定的性能压力。

