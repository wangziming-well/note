# 基础命令

Redis提供了5种数据结构，在正式介绍之前，我们先了解一下Redis的一些全局命令、数据结构和内部编码、单线程命令处理机制。

## 全局命令

下面是一些对不同键来说都通用的命令(key表示键名)

* `keys *`查看所有键
* `dbsize`键总数。

* `exists key`检查键是否存在，存在返回1，不存在返回0
* `del key [key ...]`删除键，返回结果为成功删除键的个数，如果删除一个不存在的键，则返回0

* `expire key seconds`设置键过期时间，当键超过过期时间时，会自动删除键
* `ttl key`：查询键的过期时间
  * 返回大于0的整数，表示键剩余的过期时间
  * 返回-1表示键没有设置过期时间
  * 返回-2表示键不存在
* `type key`查看键的数据类型，如果键不存在，则返回null

**注意1：**dbsize命令在计算键总数时不会遍历所有键，而是直接获取Redis内置的键总数变量，所以其时间复杂度为`O(1)`，而keys命令会遍历所有键，其时间复杂度是`O(n)`，所有当Redis保存大量键时，线上环境应该禁止使用keys命令

## 数据类型和全局编码

`type`命令实际返回的就是当前键的数据结构类型，它们分别是string、hash、list、set、zset

但这知识Redis对外的数据结构，实际上每种数据结构都有自己底层的内部编码实现，而且是多种实现，这样Redis会在合适的场景选择合适的内部编码

如图：

![Redis内部编码示意图](https://gitee.com/wangziming707/note-pic/raw/master/img/Redis%E5%86%85%E9%83%A8%E7%BC%96%E7%A0%81%E7%A4%BA%E6%84%8F%E5%9B%BE.png)

可以看到每种数据结构都有两种以上的内部编码实现，例如list数据结构博阿寒了linkedlist和ziplist两种内部编码。同时有些内部编码，例如ziplist，可以作为多种外部数据结构的内部实现，可以通过`object encoding`命令查看其内部：

~~~bash
127.0.0.1:6379> object encoding Hello
"embstr"
~~~

Redis这样设计外部数据结构和内部编码有两个好处:

* 可以改进内部编码，但对外部数据结构和命令没有影响
* 多种内部编码实现可以在不同场景下发挥各自的优势

## 单线程架构

Redis使用单线程架构和I/O多路复用模型来实现高性能的内存数据库服务。

首先看Redis客户端和服务端的交互模型：每次客户端调用都经历了发送命令、执行命令、返回结果三个过程。因为Redis是单线程来处理命令的，的所以一条命令从客户端到达服务端不会立刻被执行，所有命令会进入一个队列中，然后逐个被执行。当然实际的实现会更复杂些，Redis使用I/O多路复用技术来解决I/O问题

### 单线程依然快

通常来说，单线程处理能力要比多线程差，但是Redis使用单线程模型能达到每秒万级的处理能力，这是因为：

* 纯内存访问，内存的响应时间大约是100纳秒左右，这是Redis速度快的重要基础
* 非阻塞I/O,Redis使用epoll作为I/O多路复用技术的实现，再加上Redis本身的事件处理模型将epoll中的连接、读写、关闭都转换为事件，没有在网络I/O上浪费过多的时间
* 单线程避免了线程切换和竞态产生的消耗

既然单线程就能达到如此高的性能，那么使用单线程也是一种不错的选择，因为单线程可以带来几个好处：

* 单线程简化数据结构和算法的实现。并发的数据结构不仅实现困难而且难以开发测试
* 单线程避免了线程切换和竞态产生的消耗，这对服务端开发来说通常是性能杀手

但是单线程有一个问题，如果某个命令执行过长，会造成其他命令的阻塞，所有Redis是面向快速执行场景的数据库。



# 字符串

字符串类型是Redis最基础的数据结构。 首先键都是字符串类型， 而且其他几种数据结构都是在字符串类型基础上构建的。

字符串类型的值实际可以是字符串 、 数字（整数、浮点数） ， 甚至是二进制（图片、音频、 视频） ， 但是值最大不能超过512MB

对字符串的大部分命令的时间复杂度都是`O(1)`的

## 命令

### 设置值

~~~bash
set key value [ex seconds] [px milliseconds] [nx|xx]
~~~

返回结果OK表示设置成功，例如：

~~~bash
127.0.0.1:6379> set a 1
OK
~~~

set命令有几个选项：

* ex seconds： 为键设置秒级过期时间。
* px milliseconds： 为键设置毫秒级过期时间。
* nx： 键必须不存在， 才可以设置成功， 用于添加。
* xx： 与nx相反， 键必须存在， 才可以设置成功， 用于更新。

除了set选项，Redis还提供了setex和setnx两个命令:

~~~bash
setex key seconds value # 为键设置一个过期时间
setnx key value # 键必须不存在才能设置成功，设置成功返回1，失败返回0
~~~

由于Redis单线程命令处理机制，如果有多个客户端同时执行`setnx key value`根据setnx特性，只有一个客户端能够设置成功，你们setnx就可以作为分布式锁的一种实现方案。

### 获取值

~~~bash
get key
~~~

例如：

~~~bash
127.0.0.1:6379> get Hello
"World"
~~~

如果键不存在，则返回nil(空)

### 批量设置/获取值

批量设置值：

~~~bash
mset key value [key value ...]
~~~

例如:

~~~bash
127.0.0.1:6379> mset a 1 b 2 c 3 d 4
OK
~~~

批量获取值：

~~~bash
mget key [key ...]
~~~

例如：

~~~bash
127.0.0.1:6379> mget a b c d
1) "1"
2) "2"
3) "3"
4) "4"
~~~

批量获取值和设置值节省了发送命令和返回结果的网络通信时间。

### 计数

~~~bash
incr key
~~~

incr命令堵值做自增操作，返回结果有三种情况：

* 值不是整数， 返回错误。
* 值是整数， 返回自增后的结果。
* 键不存在， 按照值为0自增， 返回结果为1  

除了incr命令，Redis还提供了以下命令：

~~~bash
decr key # 自减
incrby key increment # 自增指定数字
decrby key decrement # 自减指定数字
incrbyfloat key increment #  自增浮点数
~~~

一般编程语言内部通常使用CAS机制实现计数功能，会有一定的CPU开销，但是在Redis中完全不存在这个问题，因为它是单线程的。

### 其他命令

* `append key value`向字符串末尾追加值
* `strlen key`字符串长度
* `getset key value`设置并返回原值
* `setrange key offset value`设置指定位置的字符
* `getrange key start end`获取部分字符串

## 内部编码

字符串类型的内部编码有三种：

* int:8字节长整型
* embstr：小于等于39个字节的字符串
* raw：大于39个字节的字符串

Redis会根据当前值的类型和长度决定使用哪种内部编码实现。

# 哈希

几乎所有的编程语言都提供了哈希类型，它们可能叫哈希、字典、关联数组。哈希一般指键值对的集合。因为Redis本身就是键值对存储服务器，所有Redis的哈希类型就是指键值本身又是一个键值对结构，形如`value={{field1,value1},...,{fieldN,valueN}}`

## 命令

### 设置值

~~~sh
hset key field value
~~~

如果设置成功会返回1，否则返回0.例如：

~~~bash
127.0.0.1:6379> hset user1 name wangziming
(integer) 1
127.0.0.1:6379> hset user1 age 26
(integer) 1
~~~

### 获取值

~~~bash
hget key field
~~~

例如：

~~~bash
127.0.0.1:6379> hget user1 name
"wangziming"
127.0.0.1:6379> hget user2 name
(nil)
~~~

如果键或者哈希的field不存在，则返回nil

### 删除field

~~~bash
hdel key field [field ...]
~~~

返回成功删除的字典的个数，例如：

~~~bash
127.0.0.1:6379> hdel user1 name age
(integer) 2
~~~

### 计算field个数

~~~bash
hlen key
~~~

例如：

~~~bash
127.0.0.1:6379> hlen user1
(integer) 0
~~~

### 批量设置或获取field-value  

~~~bash
hmget key field [field ...]
hmset key field value [field value ...]
~~~

