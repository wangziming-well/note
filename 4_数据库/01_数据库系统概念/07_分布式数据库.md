# 概述

分布式数据库系统由低耦合的站点组成，这些站点不共享物理部件。并且运行在每个站点上的数据库系统可以由实质上的相互独立程度。

每个站点都可以参与到事务中，这些事务所访问的数据可以位于一个站点上也可以分布于几个不同的站点上。

在同构分布式数据库系统中，所有站点都使用相同的数据库管理系统软件，它们彼此了解，共同合作处理用户请求。在这样的系统中，本地站点放弃了部分自治性。为使事务处理能在多个站点之间进行，数据库管理系统软件必须和其他站点合作来交换于事务有关的信息。

而在异构分布式数据库中，不同站点可能使用不同的模式和不同的数据库管理系统软件，站点之间彼此并不了解，所以在合作处理事务中，它们可能仅提供有限的功能。

# 分布式数据存储

在分布式数据库中存储一个关系r，由两种方法：

* 复制：系统维护这个关系的几个相同的副本，并把这个副本存储在不同的站点上。
* 分片：系统把关系分为几个片，并把每个片存储在不同的站点上

分片和复制技术也可以组合。

## 数据复制

如果关系r被复制，则关系r的拷贝会存放在两个或者多个站点上。极端情况下，我们采用全复制，既拷贝会存放在系统中的每个站点上。

复制有如下优点：

* 可用性：数据存储在不同的服务器和站点上增加了关系r的可用性，即使其中的某个站点故障，系统仍然可以继续处理涉及关系r的查询
* 增加并行度：几个站点可以并行地处理涉及r的查询。r的副本越多，在事务执行的站点上发现所需数据的机会就越大。数据复制将站点之间的数据移动减少到最小。

但是，复制：

* 增加更新开销：系统必须保证关系r的所有副本是一致的。所以，只要r更新了，更新就必须传播到包含其副本的所有站点。所以增加了开销

复制数据提高了关系的可用性和并发度，但是增加了更新的开销。我们可以选择关系的副本之一作为r的主拷贝来简化关系r的副本管理

## 数据分片

如果关系r是分片的，那么r划分为多个分片r1,r2,...,rn。这些分片包含足够的信息能够重构出原始关系r。有两种不同的方案用于对关系分片：水平分片和垂直分片。

水平分片将r的每个元组分给一个或者多个分片来划分关系。垂直分片通过对关系r的模式R进行分解来划分关系。

在水平分片中，关系r划分为多个子集r1，r2,...,rn。关系r的每个元组必须至少属于其中一个分片，以使得在需要的时候可以重构出原始关系。

垂直分片最简单的形式和分解是一样的。r(R)的垂直分片涉及定义模式R的几个属性子集R1,R2,...,Rn。使得：
$$
R= R_1 \cup R_2 \cup ... \cup R_n
$$
r的每个分片$r_i$定义为：
$$
r_i = \prod_{R_i} (r)
$$
确保这样的分片能够让关系能重构的一种方法是在每个$R_i$中包含R的主码属性。也可以使用任意超码

## 透明性

分布式数据库系统用户不要求知道数据的物理位置在哪里或者在特定本地站点上的数据应如何访问。这种特性称为数据透明性，它有如下几种形式：

* 分片透明性：用户不需要知道关系是如何分片的
* 复制透明性：在用户看来，数据对象逻辑上是唯一的，虽然实际上数据复制在几个不同的站点上
* 位置透明性：用户无需知道数据的物理位置。只要用户事务体哦那个数据标识符，分布式数据库系统应能找到任何数据

数据项(关系、分片和副本)必须有唯一的名字，这在集中式数据库中很容易保证。但是，在分布式数据库中，必须采取一些技术才能确保任意两个站点之间没有对不同的数据项使用相同的名字。

解决这个问题的一种方式是要求所有名字都要在中央名字服务器中注册。名字服务器有助于确保同样的名字不会用于不同的数据项。也可以使用名字服务器来定位数据项。

但是这种方法有两个主要缺点：1、当数据项通过它们的名字来定位时，名字服务器容易称为性能瓶颈。2、如果只有一个名字服务器，当导致整个分布式系统的可用性下降：一旦名字服务器崩溃，所有的站点都不能正常运行

一种更广泛使用的方法时要求每个站点将其自身的站点标识符作为前缀加到它所产生的任何名字前面。但是，这个方法无法实现位置透明性，因为想要访问某个数据项就必须知道数据所在的站点名称。

为了解决这个问题，数据库系统可以为数据项创建别名。这样用户可以使用简单的名字来引用数据项，而简单的名字会被系统翻译为完整的名字。而别名和真实名字的映射可以存储在每个站点上。

# 分布式事务

在分布式系统中对各种数据项的访问通常通过事务来完成，事务必须保持ACID特性。而分布式系统中有两种事务：

局部事务：只在一个数据库中访问和更新的事务

全局事务：在多个数据库中访问和更新数据的事务

局部事务的ACID特性由单个数据库管理系统的事务管理器来保障。但对于全局事务来说，这项工作就复杂得多，因为多个站点参与一个事务的执行时，其中一个站点的故障，或者通信链路故障都可能导致错误的计算。

## 系统结构

每个站点都有自身的局部事务管理器，以保障本站点上执行的局部事务的ACID特性。而各个事务管理器相互协作以执行全局事务。

为了表述这样的管理器是实现，考虑一个事务系统的抽象模型，其中每个站点包括两个子系统

* 事务管理器：管理那些访问存储再一个局部站点中的数据的事务(或子事务)的执行。这样的事务既可以是局部事务，也可以是全局事务的一部分
* 事务协调器：协调再该站点上发起的各个事务(既有全局的也有局部的)的执行

该事务管理器的结构再许多方面通集中式系统的结构类似。每个事务管理器需要负责：

* 维护一个用于恢复目的的日志
* 参与到一个合适的并发控制方案，协调该站点上执行的事务的并发执行。

为了适应事务的分布性，需要修改恢复方案和并发方案，事务协调器负责协调该站点上发起的所有的事务的执行。对这样的事务，协调器负责：

* 启动事务的执行。
* 将事务分成一些子事务，将这些子事务分派到合适的站点去执行
* 协调事务的中止，这可能导致事务在所有站点上都提交或者在所有站点上都中止

## 系统故障模式

分布式系统可能会发生和集中式系统相同类型的故障,如软件错误，系统崩溃等，但分布式环境中有一些还有另外一些需要处理的故障类型：

* 站点故障
* 消息丢失
* 通信链路故障
* 网络划分

# 提交协议

要保证事务在分布式系统中的原子性，执行事务T的所有站点就必须在执行的最终结果上达成一致。T必须做到要么在所有站点上都提交，要么在所有站点上都中止。为了保证这个特性，T的事务协调器必须执行一个提交协议：

* 两阶段提交协议(Two-Phase Commit,2PC)是最简单且使用最广泛的提交协议之一
* 三阶段提交协议(Three-Phase Commit,3PC)谜面了2PC协议的某些缺点，但也增加了复杂性和开销

## 两阶段提交

接下来描述两阶段提交协议在一般操作、故障处理、恢复和并发控制中的行为

考虑一个从站点Si发起的事务T，设Si的事务协调器是Ci

### 提交协议

当T完成执行时(即执行T的所有站点都通值Ci已完成了T的执行),Ci启动2PC协议

* 阶段1：Ci将记录`<prepare T>`加入到日志中，并强制日志写入稳定存储器上。接着将一条prepare T消息发送到执行T的所有站点上。

  当收到这消息后，站点上的事务管理器确定它是否愿意提交T中属于它的那部分：

  * 如果答案是”不“，事务管理器就把记录`<abort T>`加入到日志中，然后通过向Ci发送一条 abort T 消息来作为响应
  * 如果回答是”是“，事务管理器就把记录`<ready T>`加入到日志中，并将日志(包括所有与T相关的日志记录)强制写入稳定存储器上。然后事务管理器通过向Ci回复一条ready T消息作为回答

* 阶段2：当Ci收到所有站点对prepare T消息的回答时，或者自prepare T消息发送后经过要一个预定的时间间隔时，Ci就可以确定是将事务T提交还是中止。

  * 如果Ci接受刀来自所有参与站点的ready T消息，那么事务T可以提交。然后将`<commit T>`加到日志
  * 否则，事务T必须中止。然后将记录`<abort T>`加入到日志中，并将日志强制写入到稳定存储器上

  这时，事务的最终结果就已经确定了。此后，协调器向所有参与站点发送消息commit T或者abort T。当站点收到此消息时，就将此消息记录到日志中。

在向协调器发送ready T消息之前，执行T的站点可以在任何时候无条件中止T。一旦发出ready T消息，站点上的事务就称为处于就绪状态。ready T消息是站点所做的承若：即按照协调器的命令来提交T或中止T。为了保证承诺，所需信息必须首先存储在稳定存储器中。否则，如果站点在发送ready T后崩溃，它可能就不能兑现承诺了。进而言之，事务拥有的锁必须继续保留直到事务结束。

由于提交事务需要全体一致，因此一旦有至少一个站点回答 abort T，事务T的最终结果就是abort 了。因此作为协调器的站点Si是执行T的站点之一 ，所以协调器可以单方面决定中止T。关于T的最后结论是在协调器将此结论写入日志并强制将其写入稳定存储器时确定的。

### 故障处理

2PC对不同类型的故障有不同方式的反应：

* 参与站点故障：如果协调器Ci检测到某个站点发生了故障，它将采取以下行为：

  * 如果站点在用ready T消息回答Ci前发生故障，则协调器假定该站点是用abort T消息来回答的
  * 如果站点在协调器接收到从该站点发来的ready T消息后发生了故障，则协调器就按照通常的方式执行提交协议的剩余部分，忽略该站点发生的故障

  当参与站点Sk从故障中恢复时，它必须检查它的日志来决定故障发生时正在执行中的事务的最终结果。设T是一个这样的事务。我们考虑所有可能的情况：

  * 若日志包含`<commit T>`记录，则该站点执行redo(T)
  * 若日志包含`<abort T>`记录，则该站点执行undo(T)
  * 若日志包含`<ready T>`记录，这种情况下，该站点必须询问Ci以决定T的最终结果
    * 若Ci正在工作，它就通知Sk关于T是否提交或终止的信息，Sk根据这个信息，执行redo(T)或者undo(T)
    * 如果Ci故障，Sk就必须试图从其他站点找到T的最终结果。它通过向系统中所有站点发送querystatus T消息来进行这一操作。其他站点收到这一消息后，会查阅其日志来判定T是否在该站点上执行过，如果是，要看T是否提交或中止，然后把结果告诉Sk。如果没有站点提供恰当的信息(即T是否提交或中止)，那么Sk既不能提交也不能中止T。关于T的决定将被推迟到Sk得到所需信息时为止。因此，Sk必须定期地向其他站点重发querystatus消息。直到包含所需信息的某个站点恢复为止(Ci所在的站点必然包含这样的信息)
  * 日志中没有包含关于T的控制记录(abort、commit、ready)，因此我们知道Sk在响应来自Ci的prepareT消息前发生了故障。因此Sk的故障排除了发送这样一个响应的可能性，Ci必须中止T。因此Sk必须执行undo(T)

* 协调器故障：如果协调器在为事务T执行提交协议的过程中发生了故障，就i必须由参与的那些站点来决定事务T的最终结果。

  * 如果活跃站点在其日志中包含`<commit T>`记录，则T必须提交
  * 如果活跃站点在其日志中包含`<abort T>`记录，则T必须中止
  * 如果某些活跃站点在其日志中没有包含`<ready T>`记录，则发生故障的协调器Ci不可能已经决定将T提交，因为在其日志中没有`<ready T>`记录的站点不会已经向Ci发送过 ready T消息。但是，协调器可能已经决定中止T而不是提交T。与等待Ci恢复相比，中止T更加可取
  * 不过不是上述所有情况，那么活跃站点在他们的日志中都有`<ready T>`记录，但没有别的控制记录(abort T或commit T)。由于协调器已经发生故障，因此不等到底协调器恢复，就不可能确定是否已经做出决定，就做已做了决定也不知道做出的决定时什么。因此，活跃站点必须等待Ci的恢复。但是如果Ci一直不回复，则活跃站点上的未结束的T可能还占有其他资源，比如锁，造成了阻塞。

* 网络划分：当网络被划分时，存在两种可能性：

  * 协调器和它的所有i参与者处于同一个分区中，这种情况下，故障对提交协议没有影响
  * 协调器和它的参与者属于几个分区。从其中一个分区的站点的角度来看，其他分区的站点就像发生了故障一样。不在协调器所在的分区中的站点只需要执行协议来处理协调器的故障。协调器以及与协调器在同一分区中的站点遵循平常的提交协议，并假设其他分区中的站点发生了故障

### 恢复与并发控制

当故障站点重新启动时，我们可以使用之前描述的恢复算法来执行恢复。为了处理分布式提交协议，恢复过程必须特殊对待疑问事务

疑问事务是发现由`<ready T>`日志记录，但没有`<commit T>`和`<abort T>`日志记录的事务。这样的事务必须通过和其他站点联系才能确认这种事务的提交-中止状态

但是，如果恢复像这样描述的执行，该站点上正常的事务处理就只有等所有疑问事务提交或回滚后才能开始。找出疑问事务的状态可能会很慢，因为可能不得不与多个站点进行联系。此外，如果协调器发生故障，并且别的站点都没有关于未完成事务的中止-提交状态信息，在使用2PC是就存在恢复被阻塞的潜在可能。那么执行重启恢复的站点在很长一段事件内都保持不可使用的状态。

为了防止这个问题，恢复算法通常提供对在日志中记载封锁信息的支持。该算法所写的日志记录不是`<ready T>`而是`<ready T,L>`日志记录，其中L是写入日志记录时事务T持有的所有写锁的列表。在恢复时，在执行局部恢复动作之后，对每个疑问事务T而言`<ready T,L>`日志记录中所记载的所有写锁都需要重新获取。

当所有疑问事务的锁重新获取完成后，即使在疑问事务的提交中止状态确认之前，站点上的其他事务处理就可以开始了。疑问事务的提交或回滚与新事务的执行是并发执行的。这样恢复就更快了，并且不再会阻塞。只有与疑问事务冲突的事务才会阻塞。

## 三阶段提交

三阶段提交(3PC)协议是对两阶段提交协议的扩展，它在特定假设下避免了阻塞问题。

它假设不发生网络划分，并且不超过k个站点发生故障，k是预先定义的数值。

在这些假设下，该协议通过引入一个额外的第三阶段来避免阻塞，在该阶段多个站点会涉及提交的决定。协调器不是在其持久存储中直接记录提交决定，而是首先保证至少由k个其他站点知道它打算提交事务。如果协调器出故障，剩下的站点首先选择一个新的协调器。这个新的协调器从剩下的站点中检查协议的状态；如果协调器已经决定提交，那么其他k个被通知的站点中至少有一个还在工作而且确保提交决定会考虑。如果一些站点知道旧的协调器打算提交事务，那么新的协调器重新开始协议的第三阶段。否则新的协调器中止该事务。

