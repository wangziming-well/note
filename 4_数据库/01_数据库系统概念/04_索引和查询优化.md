# 索引和散列

数据库系统中文件索引的工作方式类似于书本中的索引。在查找一个具体条目时可以先查找条目所在的索引。

有两种基本的索引类型：

* 顺序索引：基于知道顺序排序
* 散列索引：基于将值平均分布大宋若干散列桶中，通过哈希函数来确定具体值所在的桶编号

对索引的性能/效率可以通过以下层面进行评估：

* 访问类型
* 访问时间
* 插入时间
* 删除时间
* 空间开销

通常需要在一个文件上建立多个索引。

用于在文件中查找记录的属性或属性集称为**搜索码**。

## 顺序索引

为了快速随机访问文件中的记录，可以使用索引结构。每个索引结构于一个特定的搜索码相关联。

被索引文件中的记录自身也可以按照某种排序顺序存储。

一个文件可以有多个索引，分别基于不同的搜索码。如果包含记录的文件按照某个搜索码指定的顺序排序，那么该搜索码对应的索引称为**聚集索引**。聚集索引页称为**主索引**。注意主索引并不表示建立在主码上的索引。虽然聚集索引的搜索码常常是主码，尽管并非必须如此。

搜索码指定的顺序于文件中记录的物理顺序不同的索引称为**非聚集索引**或**辅助索引**。

在搜索码上有聚集索引的文件称作索引顺序文件

### 稠密索引和稀疏索引

**索引项**或**索引记录**由一个搜索码值(属性值)和指向具有该搜索码的一条或者多条记录(元组)的指针构成。

 我们可以使用的顺序索引有两类：

* 稠密索引：文件中的每个搜索码值都有一个索引项。

  在稠密索引中，索引包括搜索码值以及指向具有该搜索码值的第一条数据记录的指针。

  稠密索引可以是聚集或者非聚集索引，如果是非聚集索引，索引必须存储指向所有具有相同搜索码的记录的指针列表。

* 稀疏索引：只为搜索码的某些具体值建立索引项。

  只有索引是聚集索引时才能使用稀疏索引。每个索引项也包括一个搜索码值和指向具有该搜索码值的第一条数据记录的指针。

稠密索引通常可以比稀疏索引更快地定位一条记录。但是稀疏索引所占空间较小，并且插入和删除时维护索引的开销也较小。

### 多级索引

虽然索引项比具体的数据记录要小，但是当关系中元组相当大时，索引项也会占据大量的空间，甚至能达到GB级别。

如果索引比较小，那么就可以在内存中访问索引，查询速度能非常快。但是当索引非常大时，这样大的索引只能以顺序文件的当时存储在硬盘上。这样会大大降低搜索索引项的速度。

为了处理这个问题，我们像对待其他顺序文件那样对待索引文件，并且在原始的内层索引上构造一个稀疏的外层索引。

这样，为了定位一条记录，我们首先在外层索引上使用二分搜索找到其最大搜索码值小于或等于所需搜索码的记录。该记录的指针指向一个内层索引块(包含多个索引项)，然后扫描这个块，知道找到其最大搜索码值小于或者等于所需搜索码值的记录。这个记录的指针指向包含所查找记录的文件块。

具有两级或者两级以上的索引称为多级索引。利用多级索引搜索记录需要的I/O操作要少得多。

### 索引的更新

无论采用何种形式的索引，每当文件中有记录插入或删除时，索引都需要更新。此外，如果文件中的记录更新，任何搜索码属性受影响的索引页必须更新。

首先描述单级索引的更新算法：

* 插入，系统首先用出现在待插入记录中的搜索码值进行查找：

  * 对稠密索引：
    * 如果该搜索码不在索引中，系统就在索引中合适的位置插入具有该搜索码的索引项。
    * 否则：
      * 如果索引项存储的时指向具有相同搜索码值的所有记录的指针，系统就在索引项中增加一个指向新记录的指针
      * 如果索引项存储一个仅指向具有相同搜索码值的第一条记录的指针，系统把待插入的记录放到具有相同搜索码值的其他记录之后
  * 对稀疏索引：我们假设索引为每个块保存一个索引项。如果系统创建一个新的块，它会将新块中出现的第一个搜索码值插入到索引中。另一方面，如果这条新插入的记录含有最小搜索码值，那么系统就会更新指向该块的索引；否则，系统对索引不做任何变动。

* 删除：首先找到要删除的记录

  * 稠密索引：

    * 如果被删除的记录时具有这个特定搜索码值的唯一的一条记录，系统就从索引中删除相应的索引项
    * 否则：
      * 如果索引项存储的是指向所有具有相同搜索码值的记录的指针，系统就从索引项中删除指向被删除记录的指针
      * 如果索引项存储的是指向具有该搜索码值的第一条记录的指针。这种情况下，如果被删除的记录是具有该搜索码值的第一条记录，系统就更新索引项，使其指向下一条记录

  * 稀疏索引：

    * 如果索引不包含具有被删除记录搜索码值的索引项，索引不做任何修改

    * 否则：

      * 如果被删除的记录是具有该搜索码值的唯一记录，系统用下一个搜索码值的索引记录替换相应的索引记录。

        如果下一个搜索码值已经有一个索引项，则删除该索引项

      * 如果该搜索码值的索引记录指向被删除的记录，系统就更新索引项，使其指向具有相同搜索码值的下一条记录

多级索引的掺入和删除算法是对上述算法的一个简单扩展，先更新底层索引，然后按照底层索引的更新来更新第二次索引，依次类推。

### 多码上的索引

一般来说，一个搜索码可以有多个属性。一个包含多个属性的搜索码称为**复合搜索码**

对复合搜索码来说，搜索码值按照字典序排序。

## B^+^树索引文件

顺序索引随着文件的增大，索引查找性能和数据顺序扫描性能都会下降。

与之相比：B^+^树索引结构会增加文件插入和删除性能的性能开销，同时会增加空间的开销，但是会大大提高查询的效率，即使文件非常大。

### B^+^树结构

B^+^树所以是一种多级索引，但是其结构不同于多级索引顺序文件。是典型的树形结构

**叶节点:**

其叶子节点最多由n-1个搜索码值$K_1,K_2,...,K_{n-1}$和n个指针$P_1,P_2,...,P_n$构成。每个节点中的搜索码值排序存放。

即$若i<j,则K_i<K_j$

![BPlusTreeNodeStructure](https://gitee.com/wangziming707/note-pic/raw/master/img/BPlusTreeNodeStructure.png)

对$i=1,2,...,n-1$指针$P_i$指向具有搜索码值$K_i$的一条文件记录，而$P_n$指向下一个叶子节点

每个叶节点至多由n-1个值，我们允许叶节点包含的值的个数最少为$\lceil (n-1)/2 \rceil$

**非叶节点:**

B^+^树的非叶子节点(根节点和分支节点)形成叶子节点上的一个多级稀疏索引。其结构叶叶节点相同，只不过非叶节点中所有的指针都是指向树中下一级节点的指针。一个非叶节点最多可以容纳n个指针，同时必须至少容纳$\lceil n/2 \rceil$个指针。结点的指针数称为该节点的扇出。非叶节点叶称为内部节点。

对与包含m个指针的内部节点来说对$i=2,3,..,m-1$，指针$P_i$指向一个子树，该子树包含的搜索码值范围为$[K_{i-1},K_i)$,$P_m$指向的子树所含的搜索码值范围为$[K_m,+\infty)$，$P_1$指向的子树所含的搜索码值范围是$(-\infty,K_1)$。

跟节点和其他非叶节点不同，它包含的指针数可以小于$\lceil n/2 \rceil$，但是，除非整个树只有一个结点，否则根节点必须至少包含两个指针。

如下是n=3，深度也是3的一颗B^+^树：

![aBplusTree](https://gitee.com/wangziming707/note-pic/raw/master/img/aBplusTree.png)

B^+^树是平衡树，即从根到叶节点的每条路径长度都相同。这保证了它具有良好的查找、插入和修改性能。

### B^+^树的查询

我们需要考虑如何处理B^+^树上的查询。

首先考虑无重复搜索码的情况，可以通过下面算法查找元组：''
$$
\begin{flalign}
\begin{split}
&function\ find(value \ V) \\
&\qquad /*假设没有重复的搜索码，最终返回叶节点C和索引i使得C.P_i指向第一条搜索码值等于V的记录 */ \\
&\qquad 置 C = 根节点 \\
&\qquad while\ C不是叶节点 : \\
&\qquad\qquad 令i = 满足V
\end{split}&
\end{flalign}
$$


