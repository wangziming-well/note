# 索引和散列

数据库系统中文件索引的工作方式类似于书本中的索引。在查找一个具体条目时可以先查找条目所在的索引。

有两种基本的索引类型：

* 顺序索引：基于知道顺序排序
* 散列索引：基于将值平均分布大宋若干散列桶中，通过哈希函数来确定具体值所在的桶编号

对索引的性能/效率可以通过以下层面进行评估：

* 访问类型
* 访问时间
* 插入时间
* 删除时间
* 空间开销

通常需要在一个文件上建立多个索引。

用于在文件中查找记录的属性或属性集称为**搜索码**。

## 顺序索引

为了快速随机访问文件中的记录，可以使用索引结构。每个索引结构于一个特定的搜索码相关联。

被索引文件中的记录自身也可以按照某种排序顺序存储。

一个文件可以有多个索引，分别基于不同的搜索码。如果包含记录的文件按照某个搜索码指定的顺序排序，那么该搜索码对应的索引称为**聚集索引**。聚集索引页称为**主索引**。注意主索引并不表示建立在主码上的索引。虽然聚集索引的搜索码常常是主码，尽管并非必须如此。

搜索码指定的顺序于文件中记录的物理顺序不同的索引称为**非聚集索引**或**辅助索引**。

在搜索码上有聚集索引的文件称作索引顺序文件

### 稠密索引和稀疏索引

**索引项**或**索引记录**由一个搜索码值(属性值)和指向具有该搜索码的一条或者多条记录(元组)的指针构成。

 我们可以使用的顺序索引有两类：

* 稠密索引：文件中的每个搜索码值都有一个索引项。

  在稠密索引中，索引包括搜索码值以及指向具有该搜索码值的第一条数据记录的指针。

  稠密索引可以是聚集或者非聚集索引，如果是非聚集索引，索引必须存储指向所有具有相同搜索码的记录的指针列表。

* 稀疏索引：只为搜索码的某些具体值建立索引项。

  只有索引是聚集索引时才能使用稀疏索引。每个索引项也包括一个搜索码值和指向具有该搜索码值的第一条数据记录的指针。

稠密索引通常可以比稀疏索引更快地定位一条记录。但是稀疏索引所占空间较小，并且插入和删除时维护索引的开销也较小。

### 多级索引

虽然索引项比具体的数据记录要小，但是当关系中元组相当大时，索引项也会占据大量的空间，甚至能达到GB级别。

如果索引比较小，那么就可以在内存中访问索引，查询速度能非常快。但是当索引非常大时，这样大的索引只能以顺序文件的当时存储在硬盘上。这样会大大降低搜索索引项的速度。

为了处理这个问题，我们像对待其他顺序文件那样对待索引文件，并且在原始的内层索引上构造一个稀疏的外层索引。

这样，为了定位一条记录，我们首先在外层索引上使用二分搜索找到其最大搜索码值小于或等于所需搜索码的记录。该记录的指针指向一个内层索引块(包含多个索引项)，然后扫描这个块，知道找到其最大搜索码值小于或者等于所需搜索码值的记录。这个记录的指针指向包含所查找记录的文件块。

具有两级或者两级以上的索引称为多级索引。利用多级索引搜索记录需要的I/O操作要少得多。

### 索引的更新

无论采用何种形式的索引，每当文件中有记录插入或删除时，索引都需要更新。此外，如果文件中的记录更新，任何搜索码属性受影响的索引页必须更新。

首先描述单级索引的更新算法：

* 插入，系统首先用出现在待插入记录中的搜索码值进行查找：

  * 对稠密索引：
    * 如果该搜索码不在索引中，系统就在索引中合适的位置插入具有该搜索码的索引项。
    * 否则：
      * 如果索引项存储的时指向具有相同搜索码值的所有记录的指针，系统就在索引项中增加一个指向新记录的指针
      * 如果索引项存储一个仅指向具有相同搜索码值的第一条记录的指针，系统把待插入的记录放到具有相同搜索码值的其他记录之后
  * 对稀疏索引：我们假设索引为每个块保存一个索引项。如果系统创建一个新的块，它会将新块中出现的第一个搜索码值插入到索引中。另一方面，如果这条新插入的记录含有最小搜索码值，那么系统就会更新指向该块的索引；否则，系统对索引不做任何变动。

* 删除：首先找到要删除的记录

  * 稠密索引：

    * 如果被删除的记录时具有这个特定搜索码值的唯一的一条记录，系统就从索引中删除相应的索引项
    * 否则：
      * 如果索引项存储的是指向所有具有相同搜索码值的记录的指针，系统就从索引项中删除指向被删除记录的指针
      * 如果索引项存储的是指向具有该搜索码值的第一条记录的指针。这种情况下，如果被删除的记录是具有该搜索码值的第一条记录，系统就更新索引项，使其指向下一条记录

  * 稀疏索引：

    * 如果索引不包含具有被删除记录搜索码值的索引项，索引不做任何修改

    * 否则：

      * 如果被删除的记录是具有该搜索码值的唯一记录，系统用下一个搜索码值的索引记录替换相应的索引记录。

        如果下一个搜索码值已经有一个索引项，则删除该索引项

      * 如果该搜索码值的索引记录指向被删除的记录，系统就更新索引项，使其指向具有相同搜索码值的下一条记录

多级索引的掺入和删除算法是对上述算法的一个简单扩展，先更新底层索引，然后按照底层索引的更新来更新第二次索引，依次类推。

### 多码上的索引

一般来说，一个搜索码可以有多个属性。一个包含多个属性的搜索码称为**复合搜索码**

对复合搜索码来说，搜索码值按照字典序排序。

## B^+^树索引文件

顺序索引随着文件的增大，索引查找性能和数据顺序扫描性能都会下降。

与之相比：B^+^树索引结构会增加文件插入和删除性能的性能开销，同时会增加空间的开销，但是会大大提高查询的效率，即使文件非常大。

### B^+^树结构

B^+^树所以是一种多级索引，但是其结构不同于多级索引顺序文件。是典型的树形结构

**叶节点:**

其叶子节点最多由n-1个搜索码值$K_1,K_2,...,K_{n-1}$和n个指针$P_1,P_2,...,P_n$构成。每个节点中的搜索码值排序存放。

即$若i<j,则K_i<K_j$

![BPlusTreeNodeStructure](https://gitee.com/wangziming707/note-pic/raw/master/img/BPlusTreeNodeStructure.png)

对$i=1,2,...,n-1$指针$P_i$指向具有搜索码值$K_i$的一条文件记录，而$P_n$指向下一个叶子节点

每个叶节点至多由n-1个值，我们允许叶节点包含的值的个数最少为$\lceil (n-1)/2 \rceil$

**非叶节点:**

B^+^树的非叶子节点(根节点和分支节点)形成叶子节点上的一个多级稀疏索引。其结构叶叶节点相同，只不过非叶节点中所有的指针都是指向树中下一级节点的指针。一个非叶节点最多可以容纳n个指针，同时必须至少容纳$\lceil n/2 \rceil$个指针。结点的指针数称为该节点的扇出。非叶节点叶称为内部节点。

对与包含m个指针的内部节点来说对$i=2,3,..,m-1$，指针$P_i$指向一个子树，该子树包含的搜索码值范围为$[K_{i-1},K_i)$,$P_m$指向的子树所含的搜索码值范围为$[K_m,+\infty)$，$P_1$指向的子树所含的搜索码值范围是$(-\infty,K_1)$。

跟节点和其他非叶节点不同，它包含的指针数可以小于$\lceil n/2 \rceil$，但是，除非整个树只有一个结点，否则根节点必须至少包含两个指针。

如下是n=3，深度也是3的一颗B^+^树：

![BPlusTreeDemo](https://gitee.com/wangziming707/note-pic/raw/master/img/BPlusTreeDemo.png)



B^+^树是平衡树，即从根到叶节点的每条路径长度都相同。这保证了它具有良好的查找、插入和修改性能。

### B^+^树的查询

我们需要考虑如何处理B^+^树上的查询。

首先考虑无重复搜索码的情况，可以通过下面算法查找元组：
$$
\begin{flalign}
\begin{split}
&function\ find(value \ V) \\
&\qquad /*假设没有重复的搜索码，最终返回叶节点C和索引i使得C.P_i指向第一条搜索码值等于V的记录 */ \\
&\qquad 置 C = 根节点 \\
&\qquad while\ C不是叶节点 : \\
&\qquad\qquad 令i = 满足V \le C.K_i 的最小值 \\
&\qquad\qquad if\ 没有这样的i : \\
&\qquad\qquad\qquad 令P_m=结点中最后一个非空指针 \\
&\qquad\qquad\qquad 置C = C.P_m \\
&\qquad\qquad else\ if (V = C.K_i):\\
&\qquad\qquad\qquad 置C = C.P_i+1\\
&\qquad\qquad else : \\
&\qquad\qquad\qquad C=C.P_i \\
&\qquad /*现在C是叶子节点  */\\ 
&\qquad 设i是满足K_i=V的最小值 \\
&\qquad if 有这样的i存在: \\
&\qquad\qquad 返回(C,i) \\
&\qquad else \\
&\qquad\qquad 返回空
\end{split}&
\end{flalign}
$$

如果B^+^树中有重复的搜索码，那么情况就会发生变化，$P_i$指向的子树的范围不再是 $[K_{i-1},K_i)$而是$[K_{i-1},K_i]$,所以我们不止要搜索find()返回的最终的叶子节点C，还要搜索它的右兄弟节点。

这样能搜索有重复码值的算法如下，记为$findFirst()$：
$$
\begin{flalign}
\begin{split}
&function\ findFirst(value \ V) \\
&\qquad /*假设没有重复的搜索码，最终返回叶节点C和索引i使得C.P_i指向第一条搜索码值等于V的记录 */ \\
&\qquad 置 C = 根节点 \\
&\qquad while\ C不是叶节点 : \\
&\qquad\qquad 令i = 满足V \le C.K_i 的最小值 \\
&\qquad\qquad if\ 没有这样的i : \\
&\qquad\qquad\qquad 令P_m=结点中最后一个非空指针 \\
&\qquad\qquad\qquad 置C = C.P_m \\
&\qquad\qquad else\ if (V = C.K_i):\\
&\qquad\qquad\qquad 置C = C.P_i+1\\
&\qquad\qquad else : \\
&\qquad\qquad\qquad C=C.P_i \\
&\qquad /*现在C是叶子节点  */\\ 
&\qquad 令 C = C的右兄弟节点
&\qquad 设i是满足K_i=V的最小值 \\
&\qquad if\ 有这样的i存在: \\
&\qquad\qquad 返回(C,i) \\
&\qquad else \\
&\qquad\qquad 令C = C的左兄弟节点 \\
&\qquad\qquad 设i是满足K_i=V的最小值 \\
&\qquad\qquad if\ 有这样的i存在: \\
&\qquad\qquad\qquad 返回(C,i) \\
&\qquad\qquad else \\ 
&\qquad\qquad\qquad 返回空
\end{split}&
\end{flalign}
$$
以上是找出第一个搜索码值为V的元组的算法，如果想要找出所有的匹配元组，可以在$findFisrt()$的基础上进行,在找到第一个值后继续比较后续的值，直到不为V。

### B^+^树的更新

对B^+^树的更新会比查找更加复杂，因为节点可能因为插入而变得过大而需要分裂或者因为扇出而变得过小而需要合并。并且在分裂合并时，要保证B^+^树保持平衡。

为了方便讨论，我们先考虑节点没有分裂合并的情况下，插入和删除是按照怎样的方式进行的：

* 插入：通过$find()$方法中类似的方式，首先找到搜索码值将出现的叶子节点。然后在该叶节点中插入一条新记录(即一对搜索码值和指针),并保证插入后搜索码的有序性。
* 删除：通过$find()$方法找到待删除记录的搜索码值，找到包含待删除项的叶节点；如果多项含有相同的搜索码值，就遍历这些相同搜索码值的项，直到找到指向被删除记录的项，然后从叶节点中移除该项。该叶节点中已删除项的所有项左移一位。

现在我们通过处理节点分裂和节点合并，来考虑插入和删除的一般情况

#### 插入

现在考虑必须分裂的例子：

**叶子节点的分裂**

在找到需要插入项应该在的叶子节点后，如果该叶子节点已经满了，那么就必须分裂，考虑向下面树插入搜索码值为4的搜索项：

![](https://gitee.com/wangziming707/note-pic/raw/master/img/BPlusTreeDemo.png)

可以找出，4应该在最左边的叶子节点，但是该节点已经满了，所以需要分裂成下面两个节点：

![BPlusTreeInsert1](https://gitee.com/wangziming707/note-pic/raw/master/img/BPlusTreeInsert1.png)

分裂后的2个节点需要插入回树中，那么就需要接入原节点的父节点，因为原父节点还没有满，所以可以直接接入：

![BPlusTreeInsert2](https://gitee.com/wangziming707/note-pic/raw/master/img/BPlusTreeInsert2.png)

**非叶子节点的分裂**

但是如果要分裂节点的父节点(非叶节点)也满了，那么它也要进行分裂。

比如向上面插入4后的树继续插入15：

一个非叶节点的分裂与叶节点略有不同。其非叶节点的孩子指针分裂为两部分。在该例中，孩子指针分为了左边三个原节点和右边2个新节点。而原搜索码值的归属分为两部分：

* 在分配后的左孩子指针和右孩子指针之间的搜索码值，这里是13，要变为父节点的搜索码值
* 在分配后的指针之间之外的搜索码值，这里是4,7，要跟随分裂变动

分裂后没有搜索码值但需要搜索码值的位置按照子节点生成搜索码

所以分裂后的树如下：

![BPlusTreeInsert3](https://gitee.com/wangziming707/note-pic/raw/master/img/BPlusTreeInsert3.png)

**根节点的跟列**

如果跟节点也满了，那么原根节点就分裂成两个，并生成一个新的根节点。作为分裂后的节点的父节点。这样树的深度就增加1了。

例如向下面B^+^树插入3：

![BPlusTreeInsert4](https://gitee.com/wangziming707/note-pic/raw/master/img/BPlusTreeInsert4.png)

插入后树变为：

![BPlusTreeInsert5](https://gitee.com/wangziming707/note-pic/raw/master/img/BPlusTreeInsert5.png)

**总之**：往B^+^树中尽显插入的流程为确定插入发生的叶节点$l$，如果产生分裂，则将新节点插入节点$l$的父节点中。如果这一插入导致分裂，就沿着树向上递归处理，直到不再产生分裂或者创建一个新的根节点位置。

#### 删除

如果在删除索引项后，所在叶节点的个数小于了$\lceil (n-1)/2 \rceil$(n为指针数),那么要么将该节点同一个兄弟节点合并，要么在节点间重新分配项，以此来保证每个节点至少半满。

考虑删除如下树中的33：

![BPlusTreeInsert3](https://gitee.com/wangziming707/note-pic/raw/master/img/BPlusTreeInsert3.png)

删除后，最右边节点就只剩下 1个索引项28，小于$\lceil (n-1)/2 \rceil(n=4)$，所以需要考虑和兄弟节点重新分配项或者与兄弟节点合并。这里兄弟节点也只有2个索引项，不管怎么重新分配都无法满足要求，所以只能考虑合并，合并为：

![BPlusTreeDelete1](https://gitee.com/wangziming707/note-pic/raw/master/img/BPlusTreeDelete1.png)

但是这样父节点就太空了，只有一个孩子指针，需要考虑和兄弟节点合并或者重新分配。这里合并是不可能的，因为兄弟节点已经满了，包含4,7,13.所以考虑重新分配。

我们可以将左兄弟节点的最右的索引项13分配给右兄弟，并且重新划分指针，最终变为：



![BPlusTreeDelete2](https://gitee.com/wangziming707/note-pic/raw/master/img/BPlusTreeDelete2.png)

如果最终删除到根节点仅剩一个孩子指针，就可以删除根节点，让其唯一孩子节点称为根节点。这样树的深度减1.

## 多码访问

之前的讨论都是建立在一个属性上的一个索引来执行关系上的查询的。但是对于某些类型的查询，如果存在多个索引则使用多个索引，或者使用建立在多属性搜索码上的索引

### 使用多个单码索引

假设`instructor`文件有两个索引，分别建立在`dept_name`和`salary`上。考虑下面查询：

~~~sql
select ID
from instructor
where dept_name='Finance'
and salary = 80000
~~~

处理这个查询可以有三个策略：

* 利用`dept_name`上的索引，找出属于金融系的所有记录。检查每条记录是否满足salary=80000
* 利用`salary`上的索引，找出所有工资等于80000的记录，检查每条记录是否满足dept_name=Finance

* 利用dept_name上的索引，找出属于金融系的所有记录；利用salary上的索引，找出所有工资等于80000的记录。计算这两个记录的交集。

上面三种策略只有第三种利用了存在多个索引的优势，然而如果下面所有条件都成立，那么第三种策略效率也会非常低：

* 属于金融系的所有记录太多
* 工资等于80000的记录太多
* 金融系中工资为80000的记录只有几条

上述条件成立的话，为了得到一个很小的结果集，我们必须扫描大量的指针。

### 多码索引

在上述场景中另一个可选的策略是在复合的搜索码(dept_name,salary)上建立和使用索引，也就是说，这一搜索码是由系名和教师工资连接而成的

我们可以使用上述的搜索码上的顺序索引来高效地回答具有如下形式等值形式的条件的查询：

~~~sql
select ID
from instructor
where dept_name='Finance'
and salary = 80000
~~~

，对于范围条件的查询它同样也能高效处理：

~~~sql
select ID
from instructor
where dept_name='Finance'
and salary < 80000
~~~

对于复合搜索码上的索引，即使只搜索复合搜索码中的一个码，它同样也可以高效处理：

~~~sql
select ID
from instructor
where dept_name='Finance'
~~~

但是，使用建立在一个复合搜索码上的顺序索引结构是有一定的缺点的，例如，考虑下面查询：

~~~sql
select ID
from instructor
where dept_name <'Finance'
and salary < 80000
~~~

如果使用建立在搜索码(dept_name,salary)上的顺序索引来回答这个查询：那么对于小于`Finance`的每个`dept_name`值，系统定位`salary`值小于80000的那些记录。但是由于文件记录的顺序，每条记录可能位于不同的磁盘块，因此导致大量的I/O操作

### 覆盖索引

覆盖索引存储一些属性(但不是搜索码属性)的值以及指向记录的指针。

这使我们仅仅使用索引就能回答一些查询，甚至不用找到实际的记录。

例如：假设我们有一个建立在instructor关系上的ID属性上的非 聚集索引。如果我们把salary属性的值与记录一同存储。那么我们就能回答那些查询salary值的查询而不需要访问instructor记录

使用搜索码(ID,salary)上创建索引能够达到同样的效果，但是一个覆盖索引能够减小搜索码的大小，使非叶节点中有更大的扇出，从而减低索引的高度

## 静态散列

顺序文件组织的一个缺点就是必须访问索引结构来定位数据，或者必须使用二分搜索法，这会导致过多的I/O操作。

基于散列(hashing)技术的文件组织能够避免访问呢索引结构。

在对散列的描述中，我们用桶(bucket)来标识能存储一条或者多条记录的一个存储单位。

令$K$标识所有搜索码值的集合，令$B$标识所有桶地址的集合，散列函数$h$时从$K$到$B$的函数

为了插入一条搜索码为$K_i$的记录，计算$h(K_i)$，返回值为存放该记录的桶的地址。将该记录存储到这个桶中。

为了进行一次基于搜索码值$K_i$的查找，计算$h(K_i)$，找到该值所在的桶，检查该桶中每条记录的搜索码值，以找到记录。

删除也是同样的操作。

### 散列函数

散列函数是可以自选的，散列函数有优劣之分，好的散列函数将搜索码值均匀的分布到所有桶中。最坏的散列函数将所有的搜索码值映射到同一个桶中，这样就和没有使用散列是一样的。

我们希望使用具有下列分布特性的散列函数：

* 分布是均匀的
* 分布是随机的

### 桶溢出处理

在插入一条记录是，如果对应的桶没有存储记录的空间，就会发生桶溢出，桶溢出的发生可能有如下原因：

* 桶不足：桶数目 * 每个桶能存放的记录数 如果小于 记录总数，就会发生桶不足
* 偏斜：如果某些桶分配到的记录比其他桶多，即使其他桶仍有空间，某个桶仍然可能溢出。

为了减少桶溢出的可能性，桶的数目通常 为 (记录总数/每个桶能存放的记录数) *（1+d），其中d为避让因子。这会浪费一部分空间，但是减少了溢出的可能性。

如果桶溢出了，我们会用溢出桶来处理溢出的数据：

如果一条记录必须插入桶b，但是b已经满了，系统会为桶b提供一个溢出桶，并将该记录插入到这个溢出桶中。

如果溢出桶也满了，系统会提供另外一个溢出桶。

一个给定桶的所有溢出桶用链表连接在一起。称为溢出链。

另外一种策略是在B桶满了后，将要插入的记录插入到下一个(按轮转顺序)的空间的桶，这种策略称为线性探查法。

### 散列索引

散列可以用于构建索引结构。散列索引将搜索码及其相应的指针构成的索引项组成成散列文件结构。

用散列函数作用于搜索码以确定对应的桶。然后遍历桶以确定具体的搜索码。

## 动态散列

如果使用静态散列，会有如下问题：

* 需要预估要存储记录的大小以确定桶大小的桶数目
* 初始时会造成空间浪费，随着文件增大，又会造成性能下降
* 为了避免性能下降，需要重组散列结构。而重组耗时大，并且重组期间必须禁止对文件的访问。

因此又了动态散列技术以允许散列函数动态改变，以适应数据库增大或者缩小的需要。

### 数据结构

当数据库增大或者缩小时，可扩充散列可以通过桶的分裂和合并来适应。此外，由于重组每次仅作用于一个桶，开销也较低。

使用可扩充散列时，需要选择一个具有均匀性和随机性特性的散列函数$h$.但是，次散列函数的值范围相对较大，是b位二进制整数。一个典型的b值是32

我们不会为每一个散列值创建一个桶。是在把记录插入文件时按需建桶的。开始时，不使用散列值的全部b位。任意时刻使用的位数$i$满足$0 \le i \le b$。这样的$i$个位用作附加在桶地址表中的偏移量。$i$的值随数据库的大小的变化而增大或减小。

为了能够实现动态扩展，我们有一个保存桶地址的目录作为中间索引，算出散列值后，我们会先查找目录，然后根据目录找到具体的桶位置，其目录大小为$i^2$,而桶的实际个数$d$会是$2^{i-1} < d \le 2^2$

为了确定含有搜索码值$K_l$的桶的位置，系统取得$h(K_l)$的前$i$个低位；这里$i$也就是动态散列的全局位深，而每个桶也有局部位深$i_k$，表示当前桶只取散列函数的前$i_k$位，局部位深有利于我们进行桶的分裂和合并

一个动态散列的具体结构如下：

为了方便表示，假设该散列的搜索码值为整数，其散列函数为$h(x) = |x|$

每个桶的容量为4，其上数字，例如3，表示哈希值为3的某个搜索码

![DynamicHashTable0](https://gitee.com/wangziming707/note-pic/raw/master/img/DynamicHashTable0.png)



因为桶b的局部深度为1，所以由于 01,11的第一位都是1，所有者两个桶目录的指针都指向b

### 查询和更新

以上面的动态散列为例。

在查询时，假设我们要查询搜索码值为7的记录，首先要算出7的散列值，这里为$h(7) = 7$。也就是101.因为目前的全局深度为2，所有我们只取前两低位，也就是01，所以就是目录的第二项，该项指向桶b。接下来只需要遍历桶b就能找到记录了。

在插入值时，假设为9，首先用上面查询的一样的过程找出9应该在的桶，这里是桶b。

如果桶没满，那么就直接插入该桶。如果桶已经满了，那么就要考虑分裂桶，例如本例中的桶b。

分裂桶b也就是将桶b的局部深度提高1位。由原来的 1,变为 2位的 01、 11 两个桶，然后为原桶b中的所有元素重新计算找出在新的两个桶中的哪一个,最终分裂出b1,b2两个桶

![DynamicHashTable1](https://gitee.com/wangziming707/note-pic/raw/master/img/DynamicHashTable1.png)

上述过程中，提高的局部深度仍然小于等于全局深度，如果分裂后的局部深度大于了全局深度，那么全局深蹲就要加1.并重新计算目录中指针的指向。

而删除时，删除后桶可能为空，这是要删除该桶，此时桶可能合并，目录大小可能也要减半

## 位图索引

位图索引是建立在一个码上的索引，但是它是为多码上的简单查询设计的特殊索引

### 位图索引结构

位图就是位的一个简单数组。位图中一个位代表一个记录。和实际关系的大小相比，位图索引通常比较小，因为位图中一个位就代表一条记录。

在最简单的形式中，关系r的属性A上的位图索引是由A能取的每个值建立的位图构成的。每个位图都和关系中的记录数相等数目的位。

例如值3在记录中只有第1、3条。那么值3的位图就是 10100...;

例如对下面记录中的sex属性建立位图：

| id   | name  | sex  |
| ---- | ----- | ---- |
| 1    | 张三  | f    |
| 2    | 李四  | m    |
| 3    | 王五  | m    |
| 4    | 赵六  | m    |
| 5    | Alice | f    |
| 6    | 铁柱  | m    |

f对应的位图为 `100010` 1表示该位置所代表的元组 sex值为f

m对应的位图为`011101` 1表示该位置所代表的元组 sex值为m

所以如果要直接搜索性别为f的成员，那么通过f对应的位图就能直接找到对应的记录，第1条和第5条记录。但是这样在单个搜索码上使用位图并不能加快检索速度。

位图索引主要在多个码上的选择操作有用。

比如考虑一个选择收入在L2水平，的女性的查询：

~~~sql
select *
from r
where gender = 'f'
and income_level = 'L2';
~~~

这两个属性上都有位图索引。

那么，我们就可以取属性gender值为f的位图和属性income_level值为L2的位图，然后执行两个位图的交(逻辑与)。计算出新的位图。

这样如果满足条件的记录占比比较小，那么这种查询方式是代价更低的选择，只进行了一次与操作。



### 位图操作的高效实现

计算两个位图的交是，我们可以使用按位与 (计算机的指令集)来加快交操作的运算速度。

一般一个按位与指令通常支持一次运算64位操作。

如果一个关系又100w条记录，每个位图将包含100w位，相当于128k。按照按位与的操作，只需要15625条指令。因此位图的交运算非常快。

同样的，计算两个位图的并可以使用按位或的操作。

计算位图的取反，可以使用位图的补码来实现。

删除记录会在顺序排序的记录之间产生间隙，因为移动记录来填充空隙需要很大开销。

为了识别被删除的记录，我们需要单独存储一个存在位图。该位图第i位为0表示记录i不存在。

## SQL中的索引定义

SQL标准中并未提供任何在数据库系统中控制创建和维护索引的方法。

原则上，数据库系统可以自动决定创建何种索引。但是由于索引的空间代价和对更新操作的影响，在维护何种索引上自动地做出正确的选择并不容易。所以大多数SQL允许程序员通过数据定义语言的命令对索引的创建和删除进行控制。

下面的语法被很多数据库系统使用和支持，但不是SQL标准的一部分：

我们使用`create index`创建索引，形式为：

~~~sql
create index <index-name> on <relation-name> ( <attribute-list>)
~~~

attribute-list是构成索引搜索码的关系属性列表

删除所有的命令为：

~~~sql
drop index <index-name>;
~~~

# 查询处理

查询处理是指从数据库中欧给提取数据时涉及的一系列活动，包括：将用高层数据库语言表示的查询语句翻译为能在文件系统的物理层上使用的表达式，为优化查询而进行的各种转换，以及查询的实际执行。

## 查询处理概述

查询处理的基本步骤如下：

1、语法分析和翻译

2、优化

3、执行

![QueryProcessing](https://gitee.com/wangziming707/note-pic/raw/master/img/QueryProcessing.png)

**翻译**

查询处理开始之前，系统内部必须将查询语句翻译成可用的形式，SQL这样的语言适合人使用，但是不适合查询的系统内部表示。一般的系统内部表示是建立在扩展的关系代数基础上的。

所以，查询处理中系统首先必须把查询语句翻译成系统的内部表示形式。该翻译的过程由类似于编译器的语法分析器来完成。

在翻译过程中，语法分析器检查用户查询的语法，验证查询中出现的关系名是否在数据库中存在等。构造该查询语句的语法分析树，然后将之翻译成关系代数表达式。

如果查询是用视图形式表示的，翻译阶段还要用定义该视图的关系代数表达式来替换所有对该视图的引用。

对于同一个查询，通常可以翻译成多个关系代数表达式。例如查询：

~~~sql
select salary instructor where salary < 75000;
~~~

该查询语句可以翻译成下面两个关系代数表达式中的任意一个:
$$
\begin{flalign}
\begin{split}
&\bullet  \sigma_{salary< 75000} (\Pi_{salary}(instructor))  \\
&\bullet \Pi_{salary}(\sigma_{salary<75000}(instructor))

\end{split}&
\end{flalign}
$$
**优化**

要全面说明如何执行一个查询，我们不仅需要提供关系代数表达式，还要对表达式加上注释来说明如何执行每个操作。

注释可以什么某个具体操作所采用的算法，或将要使用的特定的索引。

加了“如何执行”注释的关系代数运算称为计算原语。

用于执行一个查询的原语操作序列称为查询执行计划。

一个查询执行计划如下：
$$
\Pi_{salary} \to \sigma_{salary<75000};使用索引l \to instructor
$$
给定查询的不同执行计划会有不同的代价。而构造具有最小查询执行代价的查询执行计划是系统的责任，这项工作就叫查询优化

为了优化查询，查询优化器必须知道每个操作的代价。虽然精确计算代价是很难的，但是对每个操作的执行代价得出一个粗略的估计是可能的。

**执行**

查询执行引擎接受一个查询执行计划，执行该计划并把结果返回给查询

## 查询代价的度量

数据库中可以存在多种可能的查询计算计划，我们需要根据它们的(估计)代价来对不同的计划做比较，并选择最佳方案。为此我们必须估计个别操作的成本，并结合它们得到要给查询执行计划的开销。

查询处理的代价可以通过该查询对各种资源的使用情况进行度量，这些资源包括本地磁盘存取、所用CPU时间，和再并行/分布式数据库系统中的通信代价。

但是在大型数据库系统中，在本地磁盘上存取数据的代价通常是最主要的代价，因为相比于cpu执行、和内存存取，在本地磁盘上的存取耗时通常要高上几个数量级。

所以可以说花费在磁盘存取上的时间决定了着整个查询计划的执行时间。所以为了简化问题，我们将忽略CPU时间，仅仅用磁盘存取代价来度量整个查询执行计划的代价。

我们用传送磁盘块数和搜索磁盘次数来度量查询执行计划的代价：假设磁盘子系统传输一个块的数据平均耗时$t_\tau$秒，磁盘的平均访问时间为$t_s$秒，则一次传输$b$个块以及执行$S$次磁盘搜索的操作将消耗$b\times t_\tau + S \times t_s$秒。

假设磁盘块的的大小是4KB，传输率为40MB/秒。那么$t_s = 4 ms$ ，$t_\tau = 0.1 ms$

为了简化代价的估算，我们需要简化以下需要考虑的要素：

* 通过把读磁盘和写磁盘区分开，可以进一步细化磁盘读取代价的估算。因为写磁盘的代价通常是读磁盘的两倍。简化起见我们忽略这个细节。
* 暂时不考虑将操作的最终结果写回磁盘的代价，在需要时再单独考虑
* 执行计划的代价依赖于主存中缓冲区的大小。最好的情况是所有的数据都可以读入到缓冲区中，不必再访问磁盘。最坏的情况是假定缓冲区只能容纳数目不多的数据块。我们通常假定是最坏的情况
* 尽管我们假定开始时数据必须从磁盘中读取出来，但是很可能我们访问的磁盘块已经再内存缓冲区中了，为了简化起见，这种情况也忽略了。

所以执行一个查询计划过程中的实际磁盘存取代价可能比估计的要小。

假设计算机中没有其他活动在进行，那么一个查询计算计划的响应时间就是所有的这些开销，并可以作为计划的代价的度量。但是，没有实际地执行计划，就很难估算计划的响应时间，因为：

* 查询计划的执行的响应时间依赖有缓冲区中的内容，如果缓存未命中，那么响应时间会很高，如果缓存命中，则响应时间会大大降低
* 在多磁盘系统中，响应时间依赖于访问如何分布在各磁盘上。

因此，  优化器通常尽可能降低查询计划总的资源消耗，而不是尽可能缩短响应时间。

## 选择运算

