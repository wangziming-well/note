# 索引和散列

数据库系统中文件索引的工作方式类似于书本中的索引。在查找一个具体条目时可以先查找条目所在的索引。

有两种基本的索引类型：

* 顺序索引：基于知道顺序排序
* 散列索引：基于将值平均分布大宋若干散列桶中，通过哈希函数来确定具体值所在的桶编号

对索引的性能/效率可以通过以下层面进行评估：

* 访问类型
* 访问时间
* 插入时间
* 删除时间
* 空间开销

通常需要在一个文件上建立多个索引。

用于在文件中查找记录的属性或属性集称为**搜索码**。

## 顺序索引

为了快速随机访问文件中的记录，可以使用索引结构。每个索引结构于一个特定的搜索码相关联。

被索引文件中的记录自身也可以按照某种排序顺序存储。

一个文件可以有多个索引，分别基于不同的搜索码。如果包含记录的文件按照某个搜索码指定的顺序排序，那么该搜索码对应的索引称为**聚集索引**。聚集索引页称为**主索引**。注意主索引并不表示建立在主码上的索引。虽然聚集索引的搜索码常常是主码，尽管并非必须如此。

搜索码指定的顺序于文件中记录的物理顺序不同的索引称为**非聚集索引**或**辅助索引**。

在搜索码上有聚集索引的文件称作索引顺序文件

### 稠密索引和稀疏索引

**索引项**或**索引记录**由一个搜索码值(属性值)和指向具有该搜索码的一条或者多条记录(元组)的指针构成。

 我们可以使用的顺序索引有两类：

* 稠密索引：文件中的每个搜索码值都有一个索引项。

  在稠密索引中，索引包括搜索码值以及指向具有该搜索码值的第一条数据记录的指针。

  稠密索引可以是聚集或者非聚集索引，如果是非聚集索引，索引必须存储指向所有具有相同搜索码的记录的指针列表。

* 稀疏索引：只为搜索码的某些具体值建立索引项。

  只有索引是聚集索引时才能使用稀疏索引。每个索引项也包括一个搜索码值和指向具有该搜索码值的第一条数据记录的指针。

稠密索引通常可以比稀疏索引更快地定位一条记录。但是稀疏索引所占空间较小，并且插入和删除时维护索引的开销也较小。

### 多级索引

虽然索引项比具体的数据记录要小，但是当关系中元组相当大时，索引项也会占据大量的空间，甚至能达到GB级别。

如果索引比较小，那么就可以在内存中访问索引，查询速度能非常快。但是当索引非常大时，这样大的索引只能以顺序文件的当时存储在硬盘上。这样会大大降低搜索索引项的速度。

为了处理这个问题，我们像对待其他顺序文件那样对待索引文件，并且在原始的内层索引上构造一个稀疏的外层索引。

这样，为了定位一条记录，我们首先在外层索引上使用二分搜索找到其最大搜索码值小于或等于所需搜索码的记录。该记录的指针指向一个内层索引块(包含多个索引项)，然后扫描这个块，知道找到其最大搜索码值小于或者等于所需搜索码值的记录。这个记录的指针指向包含所查找记录的文件块。

具有两级或者两级以上的索引称为多级索引。利用多级索引搜索记录需要的I/O操作要少得多。

### 索引的更新

无论采用何种形式的索引，每当文件中有记录插入或删除时，索引都需要更新。此外，如果文件中的记录更新，任何搜索码属性受影响的索引页必须更新。

首先描述单级索引的更新算法：

* 插入，系统首先用出现在待插入记录中的搜索码值进行查找：

  * 对稠密索引：
    * 如果该搜索码不在索引中，系统就在索引中合适的位置插入具有该搜索码的索引项。
    * 否则：
      * 如果索引项存储的时指向具有相同搜索码值的所有记录的指针，系统就在索引项中增加一个指向新记录的指针
      * 如果索引项存储一个仅指向具有相同搜索码值的第一条记录的指针，系统把待插入的记录放到具有相同搜索码值的其他记录之后
  * 对稀疏索引：我们假设索引为每个块保存一个索引项。如果系统创建一个新的块，它会将新块中出现的第一个搜索码值插入到索引中。另一方面，如果这条新插入的记录含有最小搜索码值，那么系统就会更新指向该块的索引；否则，系统对索引不做任何变动。

* 删除：首先找到要删除的记录

  * 稠密索引：

    * 如果被删除的记录时具有这个特定搜索码值的唯一的一条记录，系统就从索引中删除相应的索引项
    * 否则：
      * 如果索引项存储的是指向所有具有相同搜索码值的记录的指针，系统就从索引项中删除指向被删除记录的指针
      * 如果索引项存储的是指向具有该搜索码值的第一条记录的指针。这种情况下，如果被删除的记录是具有该搜索码值的第一条记录，系统就更新索引项，使其指向下一条记录

  * 稀疏索引：

    * 如果索引不包含具有被删除记录搜索码值的索引项，索引不做任何修改

    * 否则：

      * 如果被删除的记录是具有该搜索码值的唯一记录，系统用下一个搜索码值的索引记录替换相应的索引记录。

        如果下一个搜索码值已经有一个索引项，则删除该索引项

      * 如果该搜索码值的索引记录指向被删除的记录，系统就更新索引项，使其指向具有相同搜索码值的下一条记录

多级索引的掺入和删除算法是对上述算法的一个简单扩展，先更新底层索引，然后按照底层索引的更新来更新第二次索引，依次类推。

### 多码上的索引

一般来说，一个搜索码可以有多个属性。一个包含多个属性的搜索码称为**复合搜索码**

对复合搜索码来说，搜索码值按照字典序排序。

## B^+^树索引文件

顺序索引随着文件的增大，索引查找性能和数据顺序扫描性能都会下降。

与之相比：B^+^树索引结构会增加文件插入和删除性能的性能开销，同时会增加空间的开销，但是会大大提高查询的效率，即使文件非常大。

### B^+^树结构

B^+^树所以是一种多级索引，但是其结构不同于多级索引顺序文件。是典型的树形结构

**叶节点:**

其叶子节点最多由n-1个搜索码值$K_1,K_2,...,K_{n-1}$和n个指针$P_1,P_2,...,P_n$构成。每个节点中的搜索码值排序存放。

即$若i<j,则K_i<K_j$

![BPlusTreeNodeStructure](https://gitee.com/wangziming707/note-pic/raw/master/img/BPlusTreeNodeStructure.png)

对$i=1,2,...,n-1$指针$P_i$指向具有搜索码值$K_i$的一条文件记录，而$P_n$指向下一个叶子节点

每个叶节点至多由n-1个值，我们允许叶节点包含的值的个数最少为$\lceil (n-1)/2 \rceil$

**非叶节点:**

B^+^树的非叶子节点(根节点和分支节点)形成叶子节点上的一个多级稀疏索引。其结构叶叶节点相同，只不过非叶节点中所有的指针都是指向树中下一级节点的指针。一个非叶节点最多可以容纳n个指针，同时必须至少容纳$\lceil n/2 \rceil$个指针。结点的指针数称为该节点的扇出。非叶节点叶称为内部节点。

对与包含m个指针的内部节点来说对$i=2,3,..,m-1$，指针$P_i$指向一个子树，该子树包含的搜索码值范围为$[K_{i-1},K_i)$,$P_m$指向的子树所含的搜索码值范围为$[K_m,+\infty)$，$P_1$指向的子树所含的搜索码值范围是$(-\infty,K_1)$。

跟节点和其他非叶节点不同，它包含的指针数可以小于$\lceil n/2 \rceil$，但是，除非整个树只有一个结点，否则根节点必须至少包含两个指针。

如下是n=3，深度也是3的一颗B^+^树：

![BPlusTreeDemo](https://gitee.com/wangziming707/note-pic/raw/master/img/BPlusTreeDemo.png)



B^+^树是平衡树，即从根到叶节点的每条路径长度都相同。这保证了它具有良好的查找、插入和修改性能。

### B^+^树的查询

我们需要考虑如何处理B^+^树上的查询。

首先考虑无重复搜索码的情况，可以通过下面算法查找元组：
$$
\begin{flalign}
\begin{split}
&function\ find(value \ V) \\
&\qquad /*假设没有重复的搜索码，最终返回叶节点C和索引i使得C.P_i指向第一条搜索码值等于V的记录 */ \\
&\qquad 置 C = 根节点 \\
&\qquad while\ C不是叶节点 : \\
&\qquad\qquad 令i = 满足V \le C.K_i 的最小值 \\
&\qquad\qquad if\ 没有这样的i : \\
&\qquad\qquad\qquad 令P_m=结点中最后一个非空指针 \\
&\qquad\qquad\qquad 置C = C.P_m \\
&\qquad\qquad else\ if (V = C.K_i):\\
&\qquad\qquad\qquad 置C = C.P_i+1\\
&\qquad\qquad else : \\
&\qquad\qquad\qquad C=C.P_i \\
&\qquad /*现在C是叶子节点  */\\ 
&\qquad 设i是满足K_i=V的最小值 \\
&\qquad if 有这样的i存在: \\
&\qquad\qquad 返回(C,i) \\
&\qquad else \\
&\qquad\qquad 返回空
\end{split}&
\end{flalign}
$$

如果B^+^树中有重复的搜索码，那么情况就会发生变化，$P_i$指向的子树的范围不再是 $[K_{i-1},K_i)$而是$[K_{i-1},K_i]$,所以我们不止要搜索find()返回的最终的叶子节点C，还要搜索它的右兄弟节点。

这样能搜索有重复码值的算法如下，记为$findFirst()$：
$$
\begin{flalign}
\begin{split}
&function\ findFirst(value \ V) \\
&\qquad /*假设没有重复的搜索码，最终返回叶节点C和索引i使得C.P_i指向第一条搜索码值等于V的记录 */ \\
&\qquad 置 C = 根节点 \\
&\qquad while\ C不是叶节点 : \\
&\qquad\qquad 令i = 满足V \le C.K_i 的最小值 \\
&\qquad\qquad if\ 没有这样的i : \\
&\qquad\qquad\qquad 令P_m=结点中最后一个非空指针 \\
&\qquad\qquad\qquad 置C = C.P_m \\
&\qquad\qquad else\ if (V = C.K_i):\\
&\qquad\qquad\qquad 置C = C.P_i+1\\
&\qquad\qquad else : \\
&\qquad\qquad\qquad C=C.P_i \\
&\qquad /*现在C是叶子节点  */\\ 
&\qquad 令 C = C的右兄弟节点
&\qquad 设i是满足K_i=V的最小值 \\
&\qquad if\ 有这样的i存在: \\
&\qquad\qquad 返回(C,i) \\
&\qquad else \\
&\qquad\qquad 令C = C的左兄弟节点 \\
&\qquad\qquad 设i是满足K_i=V的最小值 \\
&\qquad\qquad if\ 有这样的i存在: \\
&\qquad\qquad\qquad 返回(C,i) \\
&\qquad\qquad else \\ 
&\qquad\qquad\qquad 返回空
\end{split}&
\end{flalign}
$$
以上是找出第一个搜索码值为V的元组的算法，如果想要找出所有的匹配元组，可以在$findFisrt()$的基础上进行,在找到第一个值后继续比较后续的值，直到不为V。

### B^+^树的更新

对B^+^树的更新会比查找更加复杂，因为节点可能因为插入而变得过大而需要分裂或者因为扇出而变得过小而需要合并。并且在分裂合并时，要保证B^+^树保持平衡。

为了方便讨论，我们先考虑节点没有分裂合并的情况下，插入和删除是按照怎样的方式进行的：

* 插入：通过$find()$方法中类似的方式，首先找到搜索码值将出现的叶子节点。然后在该叶节点中插入一条新记录(即一对搜索码值和指针),并保证插入后搜索码的有序性。
* 删除：通过$find()$方法找到待删除记录的搜索码值，找到包含待删除项的叶节点；如果多项含有相同的搜索码值，就遍历这些相同搜索码值的项，直到找到指向被删除记录的项，然后从叶节点中移除该项。该叶节点中已删除项的所有项左移一位。

现在我们通过处理节点分裂和节点合并，来考虑插入和删除的一般情况

#### 插入

现在考虑必须分裂的例子：

**叶子节点的分裂**

在找到需要插入项应该在的叶子节点后，如果该叶子节点已经满了，那么就必须分裂，考虑向下面树插入搜索码值为4的搜索项：

![](https://gitee.com/wangziming707/note-pic/raw/master/img/BPlusTreeDemo.png)

可以找出，4应该在最左边的叶子节点，但是该节点已经满了，所以需要分裂成下面两个节点：

![BPlusTreeInsert1](https://gitee.com/wangziming707/note-pic/raw/master/img/BPlusTreeInsert1.png)

分裂后的2个节点需要插入回树中，那么就需要接入原节点的父节点，因为原父节点还没有满，所以可以直接接入：

![BPlusTreeInsert2](https://gitee.com/wangziming707/note-pic/raw/master/img/BPlusTreeInsert2.png)

**非叶子节点的分裂**

但是如果要分裂节点的父节点(非叶节点)也满了，那么它也要进行分裂。

比如向上面插入4后的树继续插入15：

一个非叶节点的分裂与叶节点略有不同。其非叶节点的孩子指针分裂为两部分。在该例中，孩子指针分为了左边三个原节点和右边2个新节点。而原搜索码值的归属分为两部分：

* 在分配后的左孩子指针和右孩子指针之间的搜索码值，这里是13，要变为父节点的搜索码值
* 在分配后的指针之间之外的搜索码值，这里是4,7，要跟随分裂变动

分裂后没有搜索码值但需要搜索码值的位置按照子节点生成搜索码

所以分裂后的树如下：

![BPlusTreeInsert3](https://gitee.com/wangziming707/note-pic/raw/master/img/BPlusTreeInsert3.png)

**根节点的跟列**

如果跟节点也满了，那么原根节点就分裂成两个，并生成一个新的根节点。作为分裂后的节点的父节点。这样树的深度就增加1了。

例如向下面B^+^树插入3：

![BPlusTreeInsert4](https://gitee.com/wangziming707/note-pic/raw/master/img/BPlusTreeInsert4.png)

插入后树变为：

![BPlusTreeInsert5](https://gitee.com/wangziming707/note-pic/raw/master/img/BPlusTreeInsert5.png)

**总之**：往B^+^树中尽显插入的流程为确定插入发生的叶节点$l$，如果产生分裂，则将新节点插入节点$l$的父节点中。如果这一插入导致分裂，就沿着树向上递归处理，直到不再产生分裂或者创建一个新的根节点位置。

#### 删除

如果在删除索引项后，所在叶节点的个数小于了$\lceil (n-1)/2 \rceil$(n为指针数),那么要么将该节点同一个兄弟节点合并，要么在节点间重新分配项，以此来保证每个节点至少半满。

考虑删除如下树中的33：

![BPlusTreeInsert3](https://gitee.com/wangziming707/note-pic/raw/master/img/BPlusTreeInsert3.png)

删除后，最右边节点就只剩下 1个索引项28，小于$\lceil (n-1)/2 \rceil(n=4)$，所以需要考虑和兄弟节点重新分配项或者与兄弟节点合并。这里兄弟节点也只有2个索引项，不管怎么重新分配都无法满足要求，所以只能考虑合并，合并为：

![BPlusTreeDelete1](https://gitee.com/wangziming707/note-pic/raw/master/img/BPlusTreeDelete1.png)

但是这样父节点就太空了，只有一个孩子指针，需要考虑和兄弟节点合并或者重新分配。这里合并是不可能的，因为兄弟节点已经满了，包含4,7,13.所以考虑重新分配。

我们可以将左兄弟节点的最右的索引项13分配给右兄弟，并且重新划分指针，最终变为：



![BPlusTreeDelete2](https://gitee.com/wangziming707/note-pic/raw/master/img/BPlusTreeDelete2.png)

如果最终删除到根节点仅剩一个孩子指针，就可以删除根节点，让其唯一孩子节点称为根节点。这样树的深度减1.

## 多码访问

之前的讨论都是建立在一个属性上的一个索引来执行关系上的查询的。但是对于某些类型的查询，如果存在多个索引则使用多个索引，或者使用建立在多属性搜索码上的索引

### 使用多个单码索引

假设`instructor`文件有两个索引，分别建立在`dept_name`和`salary`上。考虑下面查询：

~~~sql
select ID
from instructor
where dept_name='Finance'
and salary = 80000
~~~

处理这个查询可以有三个策略：

* 利用`dept_name`上的索引，找出属于金融系的所有记录。检查每条记录是否满足salary=80000
* 利用`salary`上的索引，找出所有工资等于80000的记录，检查每条记录是否满足dept_name=Finance

* 利用dept_name上的索引，找出属于金融系的所有记录；利用salary上的索引，找出所有工资等于80000的记录。计算这两个记录的交集。

上面三种策略只有第三种利用了存在多个索引的优势，然而如果下面所有条件都成立，那么第三种策略效率也会非常低：

* 属于金融系的所有记录太多
* 工资等于80000的记录太多
* 金融系中工资为80000的记录只有几条

上述条件成立的话，为了得到一个很小的结果集，我们必须扫描大量的指针。

### 多码索引

在上述场景中另一个可选的策略是在复合的搜索码(dept_name,salary)上建立和使用索引，也就是说，这一搜索码是由系名和教师工资连接而成的

我们可以使用上述的搜索码上的顺序索引来高效地回答具有如下形式等值形式的条件的查询：

~~~sql
select ID
from instructor
where dept_name='Finance'
and salary = 80000
~~~

，对于范围条件的查询它同样也能高效处理：

~~~sql
select ID
from instructor
where dept_name='Finance'
and salary < 80000
~~~

对于复合搜索码上的索引，即使只搜索复合搜索码中的一个码，它同样也可以高效处理：

~~~sql
select ID
from instructor
where dept_name='Finance'
~~~

但是，使用建立在一个复合搜索码上的顺序索引结构是有一定的缺点的，例如，考虑下面查询：

~~~sql
select ID
from instructor
where dept_name <'Finance'
and salary < 80000
~~~

如果使用建立在搜索码(dept_name,salary)上的顺序索引来回答这个查询：那么对于小于`Finance`的每个`dept_name`值，系统定位`salary`值小于80000的那些记录。但是由于文件记录的顺序，每条记录可能位于不同的磁盘块，因此导致大量的I/O操作

### 覆盖索引

覆盖索引存储一些属性(但不是搜索码属性)的值以及指向记录的指针。

这使我们仅仅使用索引就能回答一些查询，甚至不用找到实际的记录。

例如：假设我们有一个建立在instructor关系上的ID属性上的非 聚集索引。如果我们把salary属性的值与记录一同存储。那么我们就能回答那些查询salary值的查询而不需要访问instructor记录

使用搜索码(ID,salary)上创建索引能够达到同样的效果，但是一个覆盖索引能够减小搜索码的大小，使非叶节点中有更大的扇出，从而减低索引的高度

## 静态散列



