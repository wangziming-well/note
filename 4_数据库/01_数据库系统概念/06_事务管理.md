# 事务

从数据库用户的观点来看，数据库中的一些操作的集合被认为是一个独立单元。不如，从顾客角度来看，银行转账是一次单一的操作，而在数据库系统中，这些由几个操作组成。显然，这些操作要么全部发生，要么由于出错而全不发生。

构成单一逻辑工作单元的操作集合称为事务。这些操作步骤集合必须作为一个单一的、不可分割的单元出现。

由于事务是不可分割的，要么执行其全部内容，要么就根本不执行。因此，如果一个事务开始执行，但是由于某些原因失败，那事务对数据库造成的任何可能的修改都要撤销。无论是事务本身的失败，还是操作系统崩溃，或者计算机本身停止运行，这项要求都要成立。这种“全或无”的特性称为**原子性**

此外，由于事务是一个单一的单元，它的操作不能看起来是被其他不属于该事务的分隔开的。数据库必须采取特殊处理来保证事务正常执行而不被来自并发执行的数据库语句干扰。这种特性称为**隔离性**

即使系统能保证一个事务的正确执行，但如果执行后因为各种原因，入系统崩溃，导致系统丢失了事务的执行结果。那么事务的意义也不大。所以即使崩溃后事务的操作也必须是持久的。这种特性称为**持久性**

事务必须保持数据库的一致性：如果一个事务作为原子从一个一致的数据库状态开始独立运行，则事务结束时数据库也必须再次是一致的。这种一致性的约束远比数据完整性约束(如主码约束、参照完整性等)复杂，是基于数据库建模的现实模型要求的约束。如一次转账后，A账户少的钱需和B账户多的钱相等。实现这种一致性是编写事务的程序员的责任。这种特性就是**一致性**

将上述内容重新描述，我们要求数据库系统维护事务的以下性质：

* 原子性：事务的所有操作在数据库中要么全部正确反映出来，要么完全不反映
* 一致性：隔离执行事务时，保持数据库的一致性
* 隔离性：在多个事务并发执行的情况下，保证对任何一对事务$T_i$和$T_j$在$T_i$看来，$T_j$要么已经执行了，要么还没执行，在$T_i$的视角下不存在$T_j$执行中的状态
* 持久性：一个事务成功完成后，它对数据库的改变必须时永久的，即使出现系统故障

这些特性通常称为ACID特性

## 一个简单事务模型

因为SQL语言很复杂，为了学习事务，我们先采用一种简单的数据库语言。该语言关注数据何时从磁盘移动到主存以及何时从主存移动到磁盘。忽略SQL插入和删除操作。

在这个简单的事务模型中，对数据的实际操作仅限于算数操作。数据项只含一个单一的数据值。每个数据项由一个名字所标识。

采用一个由几个账户和更新账户的事务集合构成的简单银行应用来阐明事务概念。事务运用以下两个操作访问数据：

* `read(X)`：从数据库把数据项X传给到执行read操作的事务的主存缓冲区的一个也叫X的变量中
* `write(X)`:从执行`write`的事务的主存缓冲区的变量X中把数据项X传回数据库中

设$T_i$是从账户A过户$\$50$到账户B的事务。这个事务可以定义未：
$$
\begin{flalign}
\begin{split}
T_i:&read(A); \\
&A:= A -50; \\
&write(A); \\
&read(B); \\
&B:=B+50;\\
&write(B); \\
\end{split}&
\end{flalign}
$$
以这个事务为例，我们考虑ACID特性

* 一致性：在这里，一致性要求事务的执行不改变A、B之和。

* 原子性：在系统执行事务时，一定会有一段时间处在不一致的状态，比如在A账户转出钱后，B账户还没有收到钱。但是要保证事务结束时，系统要处在一致性状态。所以要求事务内的操作集合要么全部成功，要么全部失败。

  保证原子性的基本思路是：对于事务要执行写操作的数据项，数据库系统在磁盘上记录其旧值。这个信息记录在日志文件中。如果事务内能完成它的执行，数据库系统从日志中恢复旧值，使得看上去事务从未执行过。

* 持久性：一旦事务完成，该事务对数据库所作的更新都是池就的，即使之后出现系统故障。

  我们假设计算机系统的故障将会导致内存中的数据丢失，但已写入磁盘的数据绝不会丢失。我们可以确保以下两条中的任何一条来做到持久性：

  * 事务做的更新在事务结束前已经写入磁盘
  * 有关事务已执行的更新信息已写入磁盘上，这些信息必须充分，能让数据库系统在恢复数据时能重新构造更新

* 隔离性：在多个事务并发更新时，当前事务对其他事务必须是不可见的，否则会造成数据不一致

## 事务原子性和持久性

事务并非总能成功地执行完成，这种事务称为中止了。为了确保原子性，中止事务必须对数据库的状态不造成影响。因此中止事务对数据库所做过的任何改变必须撤销。一旦中止事务造成的变更被撤销，我们就说事务已回滚。

恢复机制负责管理事务中止。通常通过日志实现事务的回滚，后续会详细条论基于日志的故障恢复。

成功完成执行的事务称为**已提交**.一个对数据库进行过i更新的已提交事务使数据库进入一个新的一致状态，即使出现系统故障，这个状态也必须保持。

一旦事务已提交，就不能通过中止来撤销其造成的影响。撤销已提交事务所造成的影响的唯一方法是再执行一个**补偿事务**例如一个事务给账户加上了20元，其补偿事务就是对该账户减去20元。

为了更准确地定义一个书屋成功完成的含义。我们建立了一个简单的抽象事务模型：

* 活动的：初始状态，事务执行时处于这个状态
* 部分提交的：最后一条语句执行后
* 失败的：发现正常的执行不能继续后
* 中止的：事务回滚并且数据库已恢复到事务开始执行前的状态后
* 提交的：成功完成后

其状态机如图所示：

![transactionStateMachine](https://gitee.com/wangziming707/note-pic/raw/master/img/transactionStateMachine.png)

## 事务隔离性

事务在串行执行下能避免很多并发问题，但是为了更高效的利用计算机的多cpu和多核的硬件基础，以及提高事务的执行效率。我们还是允许多个事务并发更新数据。

当多个事务并发执行时，可能违背隔离性。即多线程环境下并发更新数据会造成数据的不一致，从而导致数据库系统不一致。

所以数据库系统必须控制事务之间的交互，以防止它们破坏数据库的一致性。系统通过称为并发控制机制的一系列机制来保证这一点。

### 调度

我们用**调度**描述多个事务并发执行的每个指令的执行顺序。

一组事务的一个调度必须包含这一组事务的全部指令，并且必须保持指令在各个事务中出现的顺序。

并发事务可以进行串行或者并行的调度。但为了保证数据库的一致性(即不出现并发问题)，需要调度在某种程度上等价于一个串行调度，这种调度称为**可串行化调度**

显然串行调度是可串行化调度，但许多事务的步骤交错的调度是否是可串行化的很难确定。

我们考虑一个调度S，其中含有分别属于$I$和$J$的两条连续指令,$I_i$和$J_j$.如果$I$和$J$引用不同的数据项，则交换$I$和$J$不会影响调度中任何指令的结果。如果$I$和$J$引用相同的数据项$Q$，则两者的顺序是重要的，我们只考虑read和write指令，因此需要考虑以下四种场景：

* `I=read(Q)`，`J=read(Q)`，此时`I`和`J`的次序不影响操作的结果
* `I=read(Q)`,`J=write(Q)`，此时`I`和`J`的次序影响操作的结果
* `I=write(Q)`,`J=read(Q)`，此时`I`和`J`的次序影响操作的结果
* `I=write(Q)`，`J=write(Q)`此时`I`和`J`的次序影响操作的结果,影响的是Q的最终值

因此只有在$I$和$J$全为read指令时，两条指令的执行顺序才无关紧要。

当$I$和$J$是不同事务在相同的数据项的操作，并且其中至少有一个是`write`指令时，我们说$I$和$J$是**冲突**的。

设$I$和$J$是调度S的两条连续指令，若$I$和$J$是属于不同事务的指令且不冲突，则可以交换$I$和$J$的顺序得到一个新的调度$S’$.$S$和$S'$等价。

如果调度$S$可以经过一系列非冲突指令交换转换成$S'$，我们称$S$和$S'$是**冲突等价**的

若一个调度$S$与一个串行调度冲突等价，则称调度$S$是**冲突可串行化**的

为了确认要给调度是否冲突可串行化，我们可以用有向图的方式进行判断：

设$S$是一个调度，由$S$构成一个有向图，称为优先图。盖度由两部分组成$G=(V,E)$，其中$V$是顶点集，$E$是边集，顶点集由所有参与调度的事务组成，边集由满足下列三个条件之一的边$T_i\to T_j$组成：

* 在$T_j$执行read(Q)之前，$T_i$执行write(Q)
* 在$T_j$执行write(Q)之前，$T_i$执行read(Q)
* 在$T_j$执行write(Q)之前，$T_i$执行write(Q)

如果调度$S$的优先图有环，则调度$S$是非冲突可串行化的，如果优先图无环，则调度$S$是冲突可串行化的。

例如对于如下调度：

| T1       | T2       |
| -------- | -------- |
| read(Q)  |          |
|          | write(Q) |
| write(Q) |          |

其优先图为：

![precedenceDiagram](https://gitee.com/wangziming707/note-pic/raw/master/img/precedenceDiagram.png)

因为有环，所以它是非冲突可串行化的

### 事务隔离性和原子性

在前面学习调度的章节中，我们隐性地假定了无事务故障。现在我们讨论在并发执行过程中事务故障产生的影响

如果一个事务$T_i$失败了，我们必须撤销该事务的影响以确保其原子性。在允许并发执行的系统中，原子性要求依赖于$T_i$的任何事务$T_j$(即$T_j$读取了$T_i$写的数据)也中止。为确保这一点，我们需要对系统中允许的调度类型做一些限制

#### 可恢复调度

如果一个事务失败后，其依赖于这个事务的其他事务已经提交了。那么这个事务无法恢复。例如下面部分调度：

| T1                    | T2                  |
| --------------------- | ------------------- |
| read(A)<br />write(A) |                     |
|                       | read(A)<br />commit |
| read(B)               |                     |

在这个调度中，如果在T1执行read(B)时发生错误，因为此时T2已经提交，这时T1不可正确恢复。

一个**可恢复调度**应该满足：对于每对事务$T_i$和$T_j$,如果$T_j$读取了之前由$T_i$所写的数据项，则$T_i$先于$T_j$提交

#### 无级联调度

即使一个调度是可恢复的，要从事务$T_i$的故障中正确恢复，可能需要回滚若干个事务。因为一个事务$T_i$被$T_j$依赖，而$T_j$又可能被其他事务依赖，形成了一个依赖链条，如果要回滚$T_i$，那么这个依赖链上的所有事务都需要回滚。这种因为单个事务故障导致一系列事务回滚的现象称为**级联回滚**

级联回滚导致撤销大量工作，这是应该尽力避免的。我们希望对调度加以限制，避免级联回滚发生。这样的调度称为无级联调度。

无级联调度应满足：对于每个事务$T_i$和$T_j$，如果$T_j$读取了先前由$T_i$所写的数据项，则$T_i$必须在$T_j$这一读操作前提交

### 事务隔离级别

可串行化可以完全保证事务的隔离性：可串行化的调度保证执行前后数据库的一致性。但是可串行化的调度只允许极小的并发度。

在这种情况下，我们采用较弱级别的一致性。

SQL标准规定了不同程度的隔离级别，实现不同程度的一致性：

* 可串行化(serializable):保证可串行化调度。
* 可重复读(repeatable read):只允许读取已提交数据，而且在一个事务两次读取一个数据项期间，其他事务不得跟更新该条数据。
* 读已提交：只允许读取已提交数据
* 读未提交：可以读取未提交数据

以上四个隔离级别并发程度依次升高，但数据一致性依次降低。

多数数据库系统运行时默认隔离级别为读已提交。

### 隔离级别的实现

数据库系统通过多种**并发控制机制**来实现事务的隔离级别。例如让事务使用整个数据库的锁来实现可串行化。

下面简单介绍数据库系统使用的并发控制机制

#### 锁

事务可以通过持有其访问的数据项的锁来保证可串行化。

数据库系统通过两阶段锁协议保证获取和释放锁的时机，使事务持有锁的时间不会过长也不会过短。

共享锁用于事务读的数据项，排他锁用于事务写的数据项。

多个事务可以持有一个数据项的共享锁。而排他锁只能由一个事务持有。

#### 时间戳

可以为每个事务分配一个时间戳，通常使它开始的时候。

而对于每个数据项，系统维护两个时间戳：

* 读时间戳，记录该数据项的事务的最大时间戳
* 写时间戳，记录写入该数据项当前值的事务的时间戳

时间戳用于确保在访问冲突情况下，事务按照事务时间戳的顺序来访问数据项。

当某个事务不可访问时，该事务会中止并重新分配一个新的时间戳重新开始。

#### 多版本和快照隔离

通过维护数据项的多个版本，一个事务允许读取一个旧版本的数据项，而不是被另一个未提交或者在串行化序列中应该排在后面的事务写入的新版本的数据项。

由多版本并发控制技术有多种，其中广泛应用的是快照隔离技术。

在快照隔离中，我们可以想象每个事务开始







# 并发控制











# 恢复系统
