# 事务

从数据库用户的观点来看，数据库中的一些操作的集合被认为是一个独立单元。不如，从顾客角度来看，银行转账是一次单一的操作，而在数据库系统中，这些由几个操作组成。显然，这些操作要么全部发生，要么由于出错而全不发生。

构成单一逻辑工作单元的操作集合称为事务。这些操作步骤集合必须作为一个单一的、不可分割的单元出现。

由于事务是不可分割的，要么执行其全部内容，要么就根本不执行。因此，如果一个事务开始执行，但是由于某些原因失败，那事务对数据库造成的任何可能的修改都要撤销。无论是事务本身的失败，还是操作系统崩溃，或者计算机本身停止运行，这项要求都要成立。这种“全或无”的特性称为**原子性**

此外，由于事务是一个单一的单元，它的操作不能看起来是被其他不属于该事务的分隔开的。数据库必须采取特殊处理来保证事务正常执行而不被来自并发执行的数据库语句干扰。这种特性称为**隔离性**

即使系统能保证一个事务的正确执行，但如果执行后因为各种原因，入系统崩溃，导致系统丢失了事务的执行结果。那么事务的意义也不大。所以即使崩溃后事务的操作也必须是持久的。这种特性称为**持久性**

事务必须保持数据库的一致性：如果一个事务作为原子从一个一致的数据库状态开始独立运行，则事务结束时数据库也必须再次是一致的。这种一致性的约束远比数据完整性约束(如主码约束、参照完整性等)复杂，是基于数据库建模的现实模型要求的约束。如一次转账后，A账户少的钱需和B账户多的钱相等。实现这种一致性是编写事务的程序员的责任。这种特性就是**一致性**

将上述内容重新描述，我们要求数据库系统维护事务的以下性质：

* 原子性：事务的所有操作在数据库中要么全部正确反映出来，要么完全不反映
* 一致性：隔离执行事务时，保持数据库的一致性
* 隔离性：在多个事务并发执行的情况下，保证对任何一对事务$T_i$和$T_j$在$T_i$看来，$T_j$要么已经执行了，要么还没执行，在$T_i$的视角下不存在$T_j$执行中的状态
* 持久性：一个事务成功完成后，它对数据库的改变必须时永久的，即使出现系统故障

这些特性通常称为ACID特性

## 一个简单事务模型

因为SQL语言很复杂，为了学习事务，我们先采用一种简单的数据库语言。该语言关注数据何时从磁盘移动到主存以及何时从主存移动到磁盘。忽略SQL插入和删除操作。

在这个简单的事务模型中，对数据的实际操作仅限于算数操作。数据项只含一个单一的数据值。每个数据项由一个名字所标识。

采用一个由几个账户和更新账户的事务集合构成的简单银行应用来阐明事务概念。事务运用以下两个操作访问数据：

* `read(X)`：从数据库把数据项X传给到执行read操作的事务的主存缓冲区的一个也叫X的变量中
* `write(X)`:从执行`write`的事务的主存缓冲区的变量X中把数据项X传回数据库中

设$T_i$是从账户A过户$\$50$到账户B的事务。这个事务可以定义未：
$$
\begin{flalign}
\begin{split}
T_i:&read(A); \\
&A:= A -50; \\
&write(A); \\
&read(B); \\
&B:=B+50;\\
&write(B); \\
\end{split}&
\end{flalign}
$$
以这个事务为例，我们考虑ACID特性

* 一致性：在这里，一致性要求事务的执行不改变A、B之和。

* 原子性：在系统执行事务时，一定会有一段时间处在不一致的状态，比如在A账户转出钱后，B账户还没有收到钱。但是要保证事务结束时，系统要处在一致性状态。所以要求事务内的操作集合要么全部成功，要么全部失败。

  保证原子性的基本思路是：对于事务要执行写操作的数据项，数据库系统在磁盘上记录其旧值。这个信息记录在日志文件中。如果事务内能完成它的执行，数据库系统从日志中恢复旧值，使得看上去事务从未执行过。

* 持久性：一旦事务完成，该事务对数据库所作的更新都是池就的，即使之后出现系统故障。

  我们假设计算机系统的故障将会导致内存中的数据丢失，但已写入磁盘的数据绝不会丢失。我们可以确保以下两条中的任何一条来做到持久性：

  * 事务做的更新在事务结束前已经写入磁盘
  * 有关事务已执行的更新信息已写入磁盘上，这些信息必须充分，能让数据库系统在恢复数据时能重新构造更新

* 隔离性：在多个事务并发更新时，当前事务对其他事务必须是不可见的，否则会造成数据不一致

## 事务原子性和持久性

事务并非总能成功地执行完成，这种事务称为中止了。为了确保原子性，中止事务必须对数据库的状态不造成影响。因此中止事务对数据库所做过的任何改变必须撤销。一旦中止事务造成的变更被撤销，我们就说事务已回滚。

恢复机制负责管理事务中止。通常通过日志实现事务的回滚，后续会详细条论基于日志的故障恢复。

成功完成执行的事务称为**已提交**.一个对数据库进行过i更新的已提交事务使数据库进入一个新的一致状态，即使出现系统故障，这个状态也必须保持。

一旦事务已提交，就不能通过中止来撤销其造成的影响。撤销已提交事务所造成的影响的唯一方法是再执行一个**补偿事务**例如一个事务给账户加上了20元，其补偿事务就是对该账户减去20元。

为了更准确地定义一个书屋成功完成的含义。我们建立了一个简单的抽象事务模型：

* 活动的：初始状态，事务执行时处于这个状态
* 部分提交的：最后一条语句执行后
* 失败的：发现正常的执行不能继续后
* 中止的：事务回滚并且数据库已恢复到事务开始执行前的状态后
* 提交的：成功完成后

其状态机如图所示：

![transactionStateMachine](https://gitee.com/wangziming707/note-pic/raw/master/img/transactionStateMachine.png)

## 事务隔离性

事务在串行执行下能避免很多并发问题，但是为了更高效的利用计算机的多cpu和多核的硬件基础，以及提高事务的执行效率。我们还是允许多个事务并发更新数据。

当多个事务并发执行时，可能违背隔离性。即多线程环境下并发更新数据会造成数据的不一致，从而导致数据库系统不一致。

所以数据库系统必须控制事务之间的交互，以防止它们破坏数据库的一致性。系统通过称为并发控制机制的一系列机制来保证这一点。

### 调度

我们用**调度**描述多个事务并发执行的每个指令的执行顺序。

一组事务的一个调度必须包含这一组事务的全部指令，并且必须保持指令在各个事务中出现的顺序。

并发事务可以进行串行或者并行的调度。但为了保证数据库的一致性(即不出现并发问题)，需要调度在某种程度上等价于一个串行调度，这种调度称为**可串行化调度**

显然串行调度是可串行化调度，但许多事务的步骤交错的调度是否是可串行化的很难确定。

我们考虑一个调度S，其中含有分别属于$I$和$J$的两条连续指令,$I_i$和$J_j$.如果$I$和$J$引用不同的数据项，则交换$I$和$J$不会影响调度中任何指令的结果。如果$I$和$J$引用相同的数据项$Q$，则两者的顺序是重要的，我们只考虑read和write指令，因此需要考虑以下四种场景：

* `I=read(Q)`，`J=read(Q)`，此时`I`和`J`的次序不影响操作的结果
* `I=read(Q)`,`J=write(Q)`，此时`I`和`J`的次序影响操作的结果
* `I=write(Q)`,`J=read(Q)`，此时`I`和`J`的次序影响操作的结果
* `I=write(Q)`，`J=write(Q)`此时`I`和`J`的次序影响操作的结果,影响的是Q的最终值

因此只有在$I$和$J$全为read指令时，两条指令的执行顺序才无关紧要。

当$I$和$J$是不同事务在相同的数据项的操作，并且其中至少有一个是`write`指令时，我们说$I$和$J$是**冲突**的。

设$I$和$J$是调度S的两条连续指令，若$I$和$J$是属于不同事务的指令且不冲突，则可以交换$I$和$J$的顺序得到一个新的调度$S’$.$S$和$S'$等价。

如果调度$S$可以经过一系列非冲突指令交换转换成$S'$，我们称$S$和$S'$是**冲突等价**的

若一个调度$S$与一个串行调度冲突等价，则称调度$S$是**冲突可串行化**的

为了确认要给调度是否冲突可串行化，我们可以用有向图的方式进行判断：

设$S$是一个调度，由$S$构成一个有向图，称为优先图。盖度由两部分组成$G=(V,E)$，其中$V$是顶点集，$E$是边集，顶点集由所有参与调度的事务组成，边集由满足下列三个条件之一的边$T_i\to T_j$组成：

* 在$T_j$执行read(Q)之前，$T_i$执行write(Q)
* 在$T_j$执行write(Q)之前，$T_i$执行read(Q)
* 在$T_j$执行write(Q)之前，$T_i$执行write(Q)

如果调度$S$的优先图有环，则调度$S$是非冲突可串行化的，如果优先图无环，则调度$S$是冲突可串行化的。

例如对于如下调度：

| T1       | T2       |
| -------- | -------- |
| read(Q)  |          |
|          | write(Q) |
| write(Q) |          |

其优先图为：

![precedenceDiagram](https://gitee.com/wangziming707/note-pic/raw/master/img/precedenceDiagram.png)

因为有环，所以它是非冲突可串行化的

### 事务隔离性和原子性

在前面学习调度的章节中，我们隐性地假定了无事务故障。现在我们讨论在并发执行过程中事务故障产生的影响

如果一个事务$T_i$失败了，我们必须撤销该事务的影响以确保其原子性。在允许并发执行的系统中，原子性要求依赖于$T_i$的任何事务$T_j$(即$T_j$读取了$T_i$写的数据)也中止。为确保这一点，我们需要对系统中允许的调度类型做一些限制

#### 可恢复调度

如果一个事务失败后，其依赖于这个事务的其他事务已经提交了。那么这个事务无法恢复。例如下面部分调度：

| T1                    | T2                  |
| --------------------- | ------------------- |
| read(A)<br />write(A) |                     |
|                       | read(A)<br />commit |
| read(B)               |                     |

在这个调度中，如果在T1执行read(B)时发生错误，因为此时T2已经提交，这时T1不可正确恢复。

一个**可恢复调度**应该满足：对于每对事务$T_i$和$T_j$,如果$T_j$读取了之前由$T_i$所写的数据项，则$T_i$先于$T_j$提交

#### 无级联调度

即使一个调度是可恢复的，要从事务$T_i$的故障中正确恢复，可能需要回滚若干个事务。因为一个事务$T_i$被$T_j$依赖，而$T_j$又可能被其他事务依赖，形成了一个依赖链条，如果要回滚$T_i$，那么这个依赖链上的所有事务都需要回滚。这种因为单个事务故障导致一系列事务回滚的现象称为**级联回滚**

级联回滚导致撤销大量工作，这是应该尽力避免的。我们希望对调度加以限制，避免级联回滚发生。这样的调度称为无级联调度。

无级联调度应满足：对于每个事务$T_i$和$T_j$，如果$T_j$读取了先前由$T_i$所写的数据项，则$T_i$必须在$T_j$这一读操作前提交

### 事务隔离级别

可串行化可以完全保证事务的隔离性：可串行化的调度保证执行前后数据库的一致性。但是可串行化的调度只允许极小的并发度。

在这种情况下，我们采用较弱级别的一致性。

SQL标准规定了不同程度的隔离级别，实现不同程度的一致性：

* 可串行化(serializable):保证可串行化调度。
* 可重复读(repeatable read):只允许读取已提交数据，而且在一个事务两次读取一个数据项期间，其他事务不得跟更新该条数据。
* 读已提交：只允许读取已提交数据
* 读未提交：可以读取未提交数据

以上四个隔离级别并发程度依次升高，但数据一致性依次降低。

多数数据库系统运行时默认隔离级别为读已提交。

### 隔离级别的实现

数据库系统通过多种**并发控制机制**来实现事务的隔离级别。例如让事务使用整个数据库的锁来实现可串行化。

下面简单介绍数据库系统使用的并发控制机制

#### 锁

事务可以通过持有其访问的数据项的锁来保证可串行化。

数据库系统通过两阶段锁协议保证获取和释放锁的时机，使事务持有锁的时间不会过长也不会过短。

共享锁用于事务读的数据项，排他锁用于事务写的数据项。

多个事务可以持有一个数据项的共享锁。而排他锁只能由一个事务持有。

#### 时间戳

可以为每个事务分配一个时间戳，通常使它开始的时候。

而对于每个数据项，系统维护两个时间戳：

* 读时间戳，记录该数据项的事务的最大时间戳
* 写时间戳，记录写入该数据项当前值的事务的时间戳

时间戳用于确保在访问冲突情况下，事务按照事务时间戳的顺序来访问数据项。

当某个事务不可访问时，该事务会中止并重新分配一个新的时间戳重新开始。

#### 多版本和快照隔离

通过维护数据项的多个版本，一个事务允许读取一个旧版本的数据项，而不是被另一个未提交或者在串行化序列中应该排在后面的事务写入的新版本的数据项。

由多版本并发控制技术有多种，其中广泛应用的是快照隔离技术。

在快照隔离中，我们可以想象每个事务开始时有其自身的数据库版本或者快照。它从这个私有版本中读取数据，因此和其他事务所做的更新隔离开。如果事务新数据库，更新只出现在其私有版本中，而不是涉及的数据库本身中。当事务提交时，和更新有关的信息将保存，使得更新被写入真正的数据库。

当一个事务T进入部分提交状态后，只有在没有其他并发事务已经修改该事务想要更新的数据项的情况下，事务进入提交状态。不能提交的事务将中止。

快照隔离可以保证读数据的尝试永远无须等待。只读事务不会中止；只有修改数据的事务有微小的中止风险。

但是快照隔离带来了太多的隔离，在快照隔离下，任何事务都看不到其他事务的更新。

# 并发控制

为了保证事务的隔离性，数据库系统必须对并发事务 之间的相互作用加以控制；这种控制是通过并发控制的机制来实现的。

并发控制有许多种机制。每种机制都有优缺点。

实践中最常用的机制是两阶段锁和快照隔离。

## 基于锁的协议

确保隔离性的方法之一是要求对数据项以互斥的方式进行访问，即当一个事务访问某个数据项时，其他事务不能修改该数据项。

实现该需求的最常用方法是只允许事务访问当前该事务持有锁的数据项

### 锁

我们先考虑如下两种锁：

* 共享锁：如果事务T获得了数据项Q上的共享型锁(记为S)，则T可读但不能写Q
* 排他锁：如果事务T获得了数据项Q上的排他型锁(记为X)，则T即可读又可写Q

要求每个事务都要根据自己将对数据项Q进行的操作类型申请适当的锁。该事务将请求发送给并发控制管理器。事务只有在并发事务管理器授予所需要的锁后才能继续其操作。

如果事务T1在Q上拥有B类锁的情况下，事务T2在Q上能成功申请A类锁，就称A类锁和B类锁是相容的。

共享锁和共享锁是相容的，排他锁和排他锁或共享锁都是不相容的。

一个事务通过执行`lock-S(Q)`指令俩申请数据项Q上的共享锁，通过`lock-X(Q)`指令来申请排他锁。通过`unlock(Q)`指令来释放数据项Q上的锁。

如果一个事务要访问的数据项已经被其他事务加上了不相容类型的锁，那么这个事务在锁没有释放前，不会授予新锁。因此，该事务只能等待，直到所有其他事务持有的不相容类型锁被释放。

### 锁的授予

锁的授予需要保证避免饿死现象，即一个事务在请求锁后等待时一直无法获取锁的现象，如果锁的授予调度不合理就可能发生这种现象。

例如事务T1请求Q上的一个锁，此时Q上有其他事务的不相容锁，所以T1进入等待。但是Q上的锁释放后，锁没有授予给T1，而是授予给了后来请求锁的T2，T3等，导致T1一直获取不到锁。

我们可以通过按如下方式授权加锁来避免事务饿死：并发控制管理器维护一个队列，先开始等待的事务先获得锁

### 两阶段锁协议

如果简单的在访问数据前加锁，在访问数据后立即释放锁。不能保证调度的可串行化，例如如下调度：

T1 将从账户B转账50元到账户A，T2展示A，B账户资金之和

| T1                                                           | T2                                                           |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| lock-X(B)<br />read(B)<br />B=B-50<br />write(B)<br />unlock(B) |                                                              |
|                                                              | lock-S(A)<br />read(A)<br />unlock(A)<br />lock-S(B)<br />read(B)<br />unlock(B)<br />display(A+B) |
| lock-X(A)<br />read(A)<br />A=A-50<br />write(A)<br />unlock(A) |                                                              |

如果事务开始前，A，B账户都有100元，那么T2显示的A+B为150。因为对T1，T2对B的访问仍然是冲突的，但这里不可串行化。

保证可串行的一个协议是**两阶段锁协议**.该协议要求每个事务分两个阶段提出加锁和解锁的申请：

* 增长阶段：事务可以获得锁，但不能释放锁
* 缩减阶段：事务可以释放锁，但不能获得新锁。

在增长阶段，事务根据需要获得锁。一旦事务释放了锁，它就进入缩减阶段，并且不能再发出加锁请求。

两阶段锁协议可以保证冲突可串行化，但是不保证不会发生死锁，也不保证不会发生级联回滚。

级联回滚可以通过将两阶段协议修改为**严格两阶段协议**加以避免,这个协议要求事务持有的所有排他锁必须再事务提交后方可释放。

另一个两阶段锁协议的变体是**强两阶段锁协议**，它要求事务提交前不得释放任何锁。它可以按照事务提交的顺序串行化

我们可以再基本的两阶段锁协议上加入锁转换的概念:

* 锁升级：表示从共享锁转换为排他锁
* 锁降级：表示从排他锁转换为共享锁

锁升级只能发生在增长阶段，锁降级只能发送在缩减阶段。

### 锁的实现

锁管理器负责对锁相关功能的实现。它针对锁请求返回授予锁消息，或者要求事务回滚的消息(发生死锁时)。

锁管理器使用以下数据结构：它为已加锁的每个数据项维护一个链表，每一个请求为链表中一条记录，按请求到达的顺序排序。它使用一个以数据项名称为索引的散列表来查找列表中的数据项；这个表叫锁表。锁表采用溢出链

一个简单的锁表如下：

![锁表结构](https://gitee.com/wangziming707/note-pic/raw/master/img/%E9%94%81%E8%A1%A8%E7%BB%93%E6%9E%84.png)

锁管理器这样处理请求：

* 当一个锁请求消息达到时，如果相应数据项的链表存在，在该链表末尾增加一个记录；否则，新建一个仅包含该请求记录的链表

  在当前没有加锁的数据项上总是授予第一个加锁请求，但当事务向已经被加锁的数据项申请加锁时，只有当前请求与当前持有的锁相容，斌哥所有先前的请求都已授予锁的条件下，锁管理器才会为该请求授予锁，否则，该请求只能等待

* 当锁管理器收到一个事务的解锁请求时，它将与该事务相对应的数据项链表中的记录三处，然后检查随后的记录，如果有，如前所属，看该请求是否能被授权，如果能，锁管理器授权该请求并处理其后记录，如果还有，类似的依次处理。

* 如果一个事务中止，锁管理器删除该事务产生的正在等待加锁的所有请求。

这个算法保证了锁请求无饿死现象。

### 死锁处理

如果两个或者多个事务都处于互相等待的状态，那么我们就说系统处于死锁状态。

死锁问题的处理有两种方法：

* 死锁预防协议：保证系统永不进入死锁状态
* 死锁检测、死锁恢复：允许系统进入死锁状态，然后进行检测和回复

如果系统进入死锁的概率较高，那么可以使用死锁预防机制；否则，使用检测和回复机制更有效。

#### 死锁预防

预防死锁有两种方法。一种是通过对加锁请求进行排序或者要求同时获得所有的锁来保证不会发生循环等待。另一只能是每当等待有可能导致死锁时，进行事务回滚而不是等待加锁。

第一种方法下最简单的机制要求每个事务在开始之前封锁它的所有数据项。此外，要么一次全部封锁，要么全不封锁。但这种机制有两个缺点：1、在事务开始前通常很难预知那些数据项需要封锁2、数据项使用率可能很低，因为许多数据项可能封锁很长时间却用不到

第一种方法的另一种机制是通过对所有的数据项添加一个次序，同时要求事务只能按照次序封锁数据项。

第二种方法就是使用抢占和事务回滚。在抢占机制还能够，如果T1要申请的锁已经被T2持有，那么可以通过回滚T2来让T1抢占T2的锁。

为控制抢占，我们为每个事务赋一个唯一的时间戳，系统仅用时间戳来决定事务是应当等待还是回滚。若一个事务回滚。则该事务重启时仍持有原来的时间戳。利用时间戳有两种不同 死锁预防机制：

* wait-die 机制基于非抢占基数。当事务T1申请的数据项当前被T2持有，仅当T1的时间戳小于T2的时间戳(即T1比T2老)时允许等待，否则T1回滚
* wound-wait 机制基于抢占技术，与wait-die机制相反，当事务T1申请的数据项当前被T2持有，仅当T1的时间戳大于T2的时间戳(即T1比T2年轻)时，允许T1等待。否则T2回滚

这两种机制都会导致不必要的回滚

另一种死锁处理的简单方法是基于锁超时的：申请锁的事务至多等待一段给定的时间。若在此期间未授予该事务锁，则该事务超时，此时该事务自己回滚并重启。但是很难界定具体的超时时长。

#### 死锁检测和恢复

如果系统没有采用能保证不产生死锁的协议，那么系统必须采用检测和恢复机制。检查系统状态的算法周期性地激活，判断有无死锁发生。如果发生死锁，则系统必须试着从死锁中恢复。为了实现这一点，系统必须：

* 维护当前数据项分配给事务的有关信息，以及任何未解决的数据项请求的信息
* 提供一个是使用这些信息判断系统是否进入死锁状态的算法
* 当检测算法判定存在死锁时，从死锁中恢复

##### 死锁检测



##### 死锁恢复



### 多粒度





# 恢复系统
