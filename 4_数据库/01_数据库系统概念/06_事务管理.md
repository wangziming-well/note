# 事务

从数据库用户的观点来看，数据库中的一些操作的集合被认为是一个独立单元。不如，从顾客角度来看，银行转账是一次单一的操作，而在数据库系统中，这些由几个操作组成。显然，这些操作要么全部发生，要么由于出错而全不发生。

构成单一逻辑工作单元的操作集合称为事务。这些操作步骤集合必须作为一个单一的、不可分割的单元出现。

由于事务是不可分割的，要么执行其全部内容，要么就根本不执行。因此，如果一个事务开始执行，但是由于某些原因失败，那事务对数据库造成的任何可能的修改都要撤销。无论是事务本身的失败，还是操作系统崩溃，或者计算机本身停止运行，这项要求都要成立。这种“全或无”的特性称为**原子性**

此外，由于事务是一个单一的单元，它的操作不能看起来是被其他不属于该事务的分隔开的。数据库必须采取特殊处理来保证事务正常执行而不被来自并发执行的数据库语句干扰。这种特性称为**隔离性**

即使系统能保证一个事务的正确执行，但如果执行后因为各种原因，入系统崩溃，导致系统丢失了事务的执行结果。那么事务的意义也不大。所以即使崩溃后事务的操作也必须是持久的。这种特性称为**持久性**

事务必须保持数据库的一致性：如果一个事务作为原子从一个一致的数据库状态开始独立运行，则事务结束时数据库也必须再次是一致的。这种一致性的约束远比数据完整性约束(如主码约束、参照完整性等)复杂，是基于数据库建模的现实模型要求的约束。如一次转账后，A账户少的钱需和B账户多的钱相等。实现这种一致性是编写事务的程序员的责任。这种特性就是**一致性**

将上述内容重新描述，我们要求数据库系统维护事务的以下性质：

* 原子性：事务的所有操作在数据库中要么全部正确反映出来，要么完全不反映
* 一致性：隔离执行事务时，保持数据库的一致性
* 隔离性：在多个事务并发执行的情况下，保证对任何一对事务$T_i$和$T_j$在$T_i$看来，$T_j$要么已经执行了，要么还没执行，在$T_i$的视角下不存在$T_j$执行中的状态
* 持久性：一个事务成功完成后，它对数据库的改变必须时永久的，即使出现系统故障

这些特性通常称为ACID特性

## 一个简单事务模型

因为SQL语言很复杂，为了学习事务，我们先采用一种简单的数据库语言。该语言关注数据何时从磁盘移动到主存以及何时从主存移动到磁盘。忽略SQL插入和删除操作。

在这个简单的事务模型中，对数据的实际操作仅限于算数操作。数据项只含一个单一的数据值。每个数据项由一个名字所标识。

采用一个由几个账户和更新账户的事务集合构成的简单银行应用来阐明事务概念。事务运用以下两个操作访问数据：

* `read(X)`：从数据库把数据项X传给到执行read操作的事务的主存缓冲区的一个也叫X的变量中
* `write(X)`:从执行`write`的事务的主存缓冲区的变量X中把数据项X传回数据库中

设$T_i$是从账户A过户$\$50$到账户B的事务。这个事务可以定义未：
$$
\begin{flalign}
\begin{split}
T_i:&read(A); \\
&A:= A -50; \\
&write(A); \\
&read(B); \\
&B:=B+50;\\
&write(B); \\
\end{split}&
\end{flalign}
$$
以这个事务为例，我们考虑ACID特性

* 一致性：在这里，一致性要求事务的执行不改变A、B之和。

* 原子性：在系统执行事务时，一定会有一段时间处在不一致的状态，比如在A账户转出钱后，B账户还没有收到钱。但是要保证事务结束时，系统要处在一致性状态。所以要求事务内的操作集合要么全部成功，要么全部失败。

  保证原子性的基本思路是：对于事务要执行写操作的数据项，数据库系统在磁盘上记录其旧值。这个信息记录在日志文件中。如果事务内能完成它的执行，数据库系统从日志中恢复旧值，使得看上去事务从未执行过。

* 持久性：一旦事务完成，该事务对数据库所作的更新都是池就的，即使之后出现系统故障。

  我们假设计算机系统的故障将会导致内存中的数据丢失，但已写入磁盘的数据绝不会丢失。我们可以确保以下两条中的任何一条来做到持久性：

  * 事务做的更新在事务结束前已经写入磁盘
  * 有关事务已执行的更新信息已写入磁盘上，这些信息必须充分，能让数据库系统在恢复数据时能重新构造更新

* 隔离性：在多个事务并发更新时，当前事务对其他事务必须是不可见的，否则会造成数据不一致

## 事务原子性和持久性

事务并非总能成功地执行完成，这种事务称为中止了。为了确保原子性，中止事务必须对数据库的状态不造成影响。因此中止事务对数据库所做过的任何改变必须撤销。一旦中止事务造成的变更被撤销，我们就说事务已回滚。

恢复机制负责管理事务中止。通常通过日志实现事务的回滚，后续会详细条论基于日志的故障恢复。

成功完成执行的事务称为**已提交**.一个对数据库进行过i更新的已提交事务使数据库进入一个新的一致状态，即使出现系统故障，这个状态也必须保持。

一旦事务已提交，就不能通过中止来撤销其造成的影响。撤销已提交事务所造成的影响的唯一方法是再执行一个**补偿事务**例如一个事务给账户加上了20元，其补偿事务就是对该账户减去20元。

为了更准确地定义一个书屋成功完成的含义。我们建立了一个简单的抽象事务模型：

* 活动的：初始状态，事务执行时处于这个状态
* 部分提交的：最后一条语句执行后
* 失败的：发现正常的执行不能继续后
* 中止的：事务回滚并且数据库已恢复到事务开始执行前的状态后
* 提交的：成功完成后

其状态机如图所示：

![transactionStateMachine](https://gitee.com/wangziming707/note-pic/raw/master/img/transactionStateMachine.png)

## 事务隔离性

事务在串行执行下能避免很多并发问题，但是为了更高效的利用计算机的多cpu和多核的硬件基础，以及提高事务的执行效率。我们还是允许多个事务并发更新数据。

当多个事务并发执行时，可能违背隔离性。即多线程环境下并发更新数据会造成数据的不一致，从而导致数据库系统不一致。

所以数据库系统必须控制事务之间的交互，以防止它们破坏数据库的一致性。系统通过称为并发控制机制的一系列机制来保证这一点。

### 调度

我们用**调度**描述多个事务并发执行的每个指令的执行顺序。

一组事务的一个调度必须包含这一组事务的全部指令，并且必须保持指令在各个事务中出现的顺序。

并发事务可以进行串行或者并行的调度。但为了保证数据库的一致性(即不出现并发问题)，需要调度在某种程度上等价于一个串行调度，这种调度称为**可串行化调度**

显然串行调度是可串行化调度，但许多事务的步骤交错的调度是否是可串行化的很难确定。

我们考虑一个调度S，其中含有分别属于$I$和$J$的两条连续指令,$I_i$和$J_j$.如果$I$和$J$引用不同的数据项，则交换$I$和$J$不会影响调度中任何指令的结果。如果$I$和$J$引用相同的数据项$Q$，则两者的顺序是重要的，我们只考虑read和write指令，因此需要考虑以下四种场景：

* `I=read(Q)`，`J=read(Q)`，此时`I`和`J`的次序不影响操作的结果
* `I=read(Q)`,`J=write(Q)`，此时`I`和`J`的次序影响操作的结果
* `I=write(Q)`,`J=read(Q)`，此时`I`和`J`的次序影响操作的结果
* `I=write(Q)`，`J=write(Q)`此时`I`和`J`的次序影响操作的结果,影响的是Q的最终值

因此只有在$I$和$J$全为read指令时，两条指令的执行顺序才无关紧要。

当$I$和$J$是不同事务在相同的数据项的操作，并且其中至少有一个是`write`指令时，我们说$I$和$J$是**冲突**的。

设$I$和$J$是调度S的两条连续指令，若$I$和$J$是属于不同事务的指令且不冲突，则可以交换$I$和$J$的顺序得到一个新的调度$S’$.$S$和$S'$等价。

如果调度$S$可以经过一系列非冲突指令交换转换成$S'$，我们称$S$和$S'$是**冲突等价**的

若一个调度$S$与一个串行调度冲突等价，则称调度$S$是**冲突可串行化**的

为了确认要给调度是否冲突可串行化，我们可以用有向图的方式进行判断：

设$S$是一个调度，由$S$构成一个有向图，称为优先图。盖度由两部分组成$G=(V,E)$，其中$V$是顶点集，$E$是边集，顶点集由所有参与调度的事务组成，边集由满足下列三个条件之一的边$T_i\to T_j$组成：

* 在$T_j$执行read(Q)之前，$T_i$执行write(Q)
* 在$T_j$执行write(Q)之前，$T_i$执行read(Q)
* 在$T_j$执行write(Q)之前，$T_i$执行write(Q)

如果调度$S$的优先图有环，则调度$S$是非冲突可串行化的，如果优先图无环，则调度$S$是冲突可串行化的。

例如对于如下调度：

| T1       | T2       |
| -------- | -------- |
| read(Q)  |          |
|          | write(Q) |
| write(Q) |          |

其优先图为：

![precedenceDiagram](https://gitee.com/wangziming707/note-pic/raw/master/img/precedenceDiagram.png)

因为有环，所以它是非冲突可串行化的

### 事务隔离性和原子性

在前面学习调度的章节中，我们隐性地假定了无事务故障。现在我们讨论在并发执行过程中事务故障产生的影响

如果一个事务$T_i$失败了，我们必须撤销该事务的影响以确保其原子性。在允许并发执行的系统中，原子性要求依赖于$T_i$的任何事务$T_j$(即$T_j$读取了$T_i$写的数据)也中止。为确保这一点，我们需要对系统中允许的调度类型做一些限制

#### 可恢复调度

如果一个事务失败后，其依赖于这个事务的其他事务已经提交了。那么这个事务无法恢复。例如下面部分调度：

| T1                    | T2                  |
| --------------------- | ------------------- |
| read(A)<br />write(A) |                     |
|                       | read(A)<br />commit |
| read(B)               |                     |

在这个调度中，如果在T1执行read(B)时发生错误，因为此时T2已经提交，这时T1不可正确恢复。

一个**可恢复调度**应该满足：对于每对事务$T_i$和$T_j$,如果$T_j$读取了之前由$T_i$所写的数据项，则$T_i$先于$T_j$提交

#### 无级联调度

即使一个调度是可恢复的，要从事务$T_i$的故障中正确恢复，可能需要回滚若干个事务。因为一个事务$T_i$被$T_j$依赖，而$T_j$又可能被其他事务依赖，形成了一个依赖链条，如果要回滚$T_i$，那么这个依赖链上的所有事务都需要回滚。这种因为单个事务故障导致一系列事务回滚的现象称为**级联回滚**

级联回滚导致撤销大量工作，这是应该尽力避免的。我们希望对调度加以限制，避免级联回滚发生。这样的调度称为无级联调度。

无级联调度应满足：对于每个事务$T_i$和$T_j$，如果$T_j$读取了先前由$T_i$所写的数据项，则$T_i$必须在$T_j$这一读操作前提交

### 事务并发问题

在数据库并发执行多个事务时，如果不加操作，将破会事务的性质(一致性、隔离性):

* 脏读

  一个事务读取了另一个事务未提交的数据。(因为该数据未提交所以是不确定的，所以称为脏数据；如果该事务回滚了，该数据就是错误的数据了)

* 不可重复读

  在同一个事务中，使用相同的查询，读取到的结果的值是不一致的

  这是因为在两次查询间，该数据被其他事务修改(update)并提交了

* 幻读

  一个事务两次执行相同的条件查询，两次查询的记录数不同

  因为有其他事务在两次读取之间增加(insert)或删除(delete)表中数据并提交了

* 第一类更新丢失（回滚丢失）

  一个事务对某数据的回滚操作覆盖了其他事务对该行数据的更新操作。

* 第二类更新丢失(覆盖丢失)

  一个事务对某数据的更新操作覆盖了其他事务对该行数据的更新操作。

### 事务隔离级别

可串行化可以完全保证事务的隔离性：可串行化的调度保证执行前后数据库的一致性。但是可串行化的调度只允许极小的并发度。

在这种情况下，我们采用较弱级别的一致性。

SQL标准规定了不同程度的隔离级别，实现不同程度的一致性：

* 可串行化(serializable):保证可串行化调度。

  能避免所有并发问题，但并发程度很低

* 可重复读(repeatable read):只允许读取已提交数据，而且在一个事务两次读取一个数据项期间，其他事务不得跟更新该条数据。

  可能发生： 幻读

* 读已提交：只允许读取已提交数据

  可能发生：不可重复读 幻读

* 读未提交：可以读取未提交数据

  可能发生：脏读 不可重复读 幻读

以上四个隔离级别并发程度依次升高，但数据一致性依次降低。

多数数据库系统运行时默认隔离级别为读已提交。

### 隔离级别的实现

数据库系统通过多种**并发控制机制**来实现事务的隔离级别。例如让事务使用整个数据库的锁来实现可串行化。

下面简单介绍数据库系统使用的并发控制机制

#### 锁

事务可以通过持有其访问的数据项的锁来保证可串行化。

数据库系统通过两阶段锁协议保证获取和释放锁的时机，使事务持有锁的时间不会过长也不会过短。

共享锁用于事务读的数据项，排他锁用于事务写的数据项。

多个事务可以持有一个数据项的共享锁。而排他锁只能由一个事务持有。

#### 时间戳

可以为每个事务分配一个时间戳，通常使它开始的时候。

而对于每个数据项，系统维护两个时间戳：

* 读时间戳，记录该数据项的事务的最大时间戳
* 写时间戳，记录写入该数据项当前值的事务的时间戳

时间戳用于确保在访问冲突情况下，事务按照事务时间戳的顺序来访问数据项。

当某个事务不可访问时，该事务会中止并重新分配一个新的时间戳重新开始。

#### 多版本和快照隔离

通过维护数据项的多个版本，一个事务允许读取一个旧版本的数据项，而不是被另一个未提交或者在串行化序列中应该排在后面的事务写入的新版本的数据项。

由多版本并发控制技术有多种，其中广泛应用的是快照隔离技术。

在快照隔离中，我们可以想象每个事务开始时有其自身的数据库版本或者快照。它从这个私有版本中读取数据，因此和其他事务所做的更新隔离开。如果事务新数据库，更新只出现在其私有版本中，而不是涉及的数据库本身中。当事务提交时，和更新有关的信息将保存，使得更新被写入真正的数据库。

当一个事务T进入部分提交状态后，只有在没有其他并发事务已经修改该事务想要更新的数据项的情况下，事务进入提交状态。不能提交的事务将中止。

快照隔离可以保证读数据的尝试永远无须等待。只读事务不会中止；只有修改数据的事务有微小的中止风险。

但是快照隔离带来了太多的隔离，在快照隔离下，任何事务都看不到其他事务的更新。

# 并发控制

为了保证事务的隔离性，数据库系统必须对并发事务 之间的相互作用加以控制；这种控制是通过并发控制的机制来实现的。

并发控制有许多种机制。每种机制都有优缺点。

实践中最常用的机制是两阶段锁和快照隔离。

## 基于锁的协议

确保隔离性的方法之一是要求对数据项以互斥的方式进行访问，即当一个事务访问某个数据项时，其他事务不能修改该数据项。

实现该需求的最常用方法是只允许事务访问当前该事务持有锁的数据项

### 锁

我们先考虑如下两种锁：

* 共享锁：如果事务T获得了数据项Q上的共享型锁(记为S)，则T可读但不能写Q
* 排他锁：如果事务T获得了数据项Q上的排他型锁(记为X)，则T即可读又可写Q

要求每个事务都要根据自己将对数据项Q进行的操作类型申请适当的锁。该事务将请求发送给并发控制管理器。事务只有在并发事务管理器授予所需要的锁后才能继续其操作。

如果事务T1在Q上拥有B类锁的情况下，事务T2在Q上能成功申请A类锁，就称A类锁和B类锁是相容的。

共享锁和共享锁是相容的，排他锁和排他锁或共享锁都是不相容的。

一个事务通过执行`lock-S(Q)`指令俩申请数据项Q上的共享锁，通过`lock-X(Q)`指令来申请排他锁。通过`unlock(Q)`指令来释放数据项Q上的锁。

如果一个事务要访问的数据项已经被其他事务加上了不相容类型的锁，那么这个事务在锁没有释放前，不会授予新锁。因此，该事务只能等待，直到所有其他事务持有的不相容类型锁被释放。

### 锁的授予

锁的授予需要保证避免饿死现象，即一个事务在请求锁后等待时一直无法获取锁的现象，如果锁的授予调度不合理就可能发生这种现象。

例如事务T1请求Q上的一个锁，此时Q上有其他事务的不相容锁，所以T1进入等待。但是Q上的锁释放后，锁没有授予给T1，而是授予给了后来请求锁的T2，T3等，导致T1一直获取不到锁。

我们可以通过按如下方式授权加锁来避免事务饿死：并发控制管理器维护一个队列，先开始等待的事务先获得锁

### 两阶段锁协议

如果简单的在访问数据前加锁，在访问数据后立即释放锁。不能保证调度的可串行化，例如如下调度：

T1 将从账户B转账50元到账户A，T2展示A，B账户资金之和

| T1                                                           | T2                                                           |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| lock-X(B)<br />read(B)<br />B=B-50<br />write(B)<br />unlock(B) |                                                              |
|                                                              | lock-S(A)<br />read(A)<br />unlock(A)<br />lock-S(B)<br />read(B)<br />unlock(B)<br />display(A+B) |
| lock-X(A)<br />read(A)<br />A=A-50<br />write(A)<br />unlock(A) |                                                              |

如果事务开始前，A，B账户都有100元，那么T2显示的A+B为150。因为对T1，T2对B的访问仍然是冲突的，但这里不可串行化。

保证可串行的一个协议是**两阶段锁协议**.该协议要求每个事务分两个阶段提出加锁和解锁的申请：

* 增长阶段：事务可以获得锁，但不能释放锁
* 缩减阶段：事务可以释放锁，但不能获得新锁。

在增长阶段，事务根据需要获得锁。一旦事务释放了锁，它就进入缩减阶段，并且不能再发出加锁请求。

两阶段锁协议可以保证冲突可串行化，但是不保证不会发生死锁，也不保证不会发生级联回滚。

级联回滚可以通过将两阶段协议修改为**严格两阶段协议**加以避免,这个协议要求事务持有的所有排他锁必须再事务提交后方可释放。

另一个两阶段锁协议的变体是**强两阶段锁协议**，它要求事务提交前不得释放任何锁。它可以按照事务提交的顺序串行化

我们可以再基本的两阶段锁协议上加入锁转换的概念:

* 锁升级：表示从共享锁转换为排他锁
* 锁降级：表示从排他锁转换为共享锁

锁升级只能发生在增长阶段，锁降级只能发送在缩减阶段。

### 锁的实现

锁管理器负责对锁相关功能的实现。它针对锁请求返回授予锁消息，或者要求事务回滚的消息(发生死锁时)。

锁管理器使用以下数据结构：它为已加锁的每个数据项维护一个链表，每一个请求为链表中一条记录，按请求到达的顺序排序。它使用一个以数据项名称为索引的散列表来查找列表中的数据项；这个表叫锁表。锁表采用溢出链

一个简单的锁表如下：

![锁表结构](https://gitee.com/wangziming707/note-pic/raw/master/img/%E9%94%81%E8%A1%A8%E7%BB%93%E6%9E%84.png)

锁管理器这样处理请求：

* 当一个锁请求消息达到时，如果相应数据项的链表存在，在该链表末尾增加一个记录；否则，新建一个仅包含该请求记录的链表

  在当前没有加锁的数据项上总是授予第一个加锁请求，但当事务向已经被加锁的数据项申请加锁时，只有当前请求与当前持有的锁相容，斌哥所有先前的请求都已授予锁的条件下，锁管理器才会为该请求授予锁，否则，该请求只能等待

* 当锁管理器收到一个事务的解锁请求时，它将与该事务相对应的数据项链表中的记录三处，然后检查随后的记录，如果有，如前所属，看该请求是否能被授权，如果能，锁管理器授权该请求并处理其后记录，如果还有，类似的依次处理。

* 如果一个事务中止，锁管理器删除该事务产生的正在等待加锁的所有请求。

这个算法保证了锁请求无饿死现象。

## 死锁处理

如果两个或者多个事务都处于互相等待的状态，那么我们就说系统处于死锁状态。

死锁问题的处理有两种方法：

* 死锁预防协议：保证系统永不进入死锁状态
* 死锁检测、死锁恢复：允许系统进入死锁状态，然后进行检测和回复

如果系统进入死锁的概率较高，那么可以使用死锁预防机制；否则，使用检测和回复机制更有效。

### 死锁预防

预防死锁有两种方法。一种是通过对加锁请求进行排序或者要求同时获得所有的锁来保证不会发生循环等待。另一只能是每当等待有可能导致死锁时，进行事务回滚而不是等待加锁。

第一种方法下最简单的机制要求每个事务在开始之前封锁它的所有数据项。此外，要么一次全部封锁，要么全不封锁。但这种机制有两个缺点：1、在事务开始前通常很难预知那些数据项需要封锁2、数据项使用率可能很低，因为许多数据项可能封锁很长时间却用不到

第一种方法的另一种机制是通过对所有的数据项添加一个次序，同时要求事务只能按照次序封锁数据项。

第二种方法就是使用抢占和事务回滚。在抢占机制还能够，如果T1要申请的锁已经被T2持有，那么可以通过回滚T2来让T1抢占T2的锁。

为控制抢占，我们为每个事务赋一个唯一的时间戳，系统仅用时间戳来决定事务是应当等待还是回滚。若一个事务回滚。则该事务重启时仍持有原来的时间戳。利用时间戳有两种不同 死锁预防机制：

* wait-die 机制基于非抢占技术。当事务T1申请的数据项当前被T2持有，仅当T1的时间戳小于T2的时间戳(即T1比T2老)时允许等待，否则T1回滚
* wound-wait 机制基于抢占技术，与wait-die机制相反，当事务T1申请的数据项当前被T2持有，仅当T1的时间戳大于T2的时间戳(即T1比T2年轻)时，允许T1等待。否则T2回滚

这两种机制都会导致不必要的回滚

另一种死锁处理的简单方法是基于锁超时的：申请锁的事务至多等待一段给定的时间。若在此期间未授予该事务锁，则该事务超时，此时该事务自己回滚并重启。但是很难界定具体的超时时长。

### 死锁检测和恢复

如果系统没有采用能保证不产生死锁的协议，那么系统必须采用检测和恢复机制。检查系统状态的算法周期性地激活，判断有无死锁发生。如果发生死锁，则系统必须试着从死锁中恢复。为了实现这一点，系统必须：

* 维护当前数据项分配给事务的有关信息，以及任何未解决的数据项请求的信息
* 提供一个是使用这些信息判断系统是否进入死锁状态的算法
* 当检测算法判定存在死锁时，从死锁中恢复

#### 死锁检测

死锁可以用称为等待图的有向图来精确描述。该图由G=(V,E)对组成，其中V是顶点集，E是边集。顶点集由系统中所有事务组成，边集E的每一元素是一个有序对$T_i \to T_j$。如果$T_i \to T_j$属于E，则存在从事务$T_i$到$T_j$的一条有向边，表示视图$T_i$再等待$T_j$释放所需数据项

当前仅当等待图包含环时，系统中存在死锁。再该环中的每个事务称为处于死锁状态。要检测死锁，系统需要维护等待图，并周期性激活一个在等待图中搜索环的算法。

#### 死锁恢复

当一个检测算法判定存在死锁时，系统必须从死锁中恢复。解除死锁最通常的做法是回滚一个或多个事务。需采取如下操作：

* 选择牺牲者：给的那个处于死锁状态的事务集，为解除死锁，我们必须确定回滚哪一个或则和哪一些事务以打破死锁。我们应使事务回滚带来的代价最下。但是有多种影响因素：

  * 事务已计算了多久，并且完成指定任务之前该事务还需要计算多长时间
  * 该事务已使用了多少数据项
  * 为完成事务还需要使用多少数据项
  * 回滚时需要级联回滚的事务

* 回滚：一旦决定了要回滚事务，就必须决定事务回滚多远。

  最简单的方法时彻底回滚，中止该事务，然后重新开始

  然而，事务只回滚到可以解除死锁处更有效。这种部分回滚要求系统维护所有正在运行事务的额外状态信息。确切的说，需要记录锁的申请/授予序列和事务执行的更新。

* 饿死：在系统中，如果选择牺牲者主要基于代价因素，有可能同一事务总是被选为牺牲者。这样一来，该事务就总是不能完成指定任务，就发生了饿死。我们必须保证一个事务被选为牺牲者的次数有限。最常见的方案时在代价因素中包含回滚次数。

## 多粒度

到目前为止，我们将一个个数据项作为进行同步执行的单元。

然而，某些情况下，我们需要把多个数据项聚为一组，将它们作为一个同步单元。

例如事务T需要访问整个数据库，如果使用的锁协议粒度的最小单位时数据项，那么事务T必须给数据库中的每一个数据项都加锁。显然，这样执行大量加锁操作时很费时的。要是T能够只发出单个封锁整个数据库的加锁请求会更高效。

我们需要的是一种允许系统定义多级粒度的机制。这通过允许各种大小的数据项并定义数据粒度的层次结构，其中小粒度数据项嵌套在大粒度数据项中来实现。可这种层次结构可以图形化得表示为树，其中非叶子节点表示于其后代相关联的数据。

比如根节点表示整个数据库，下一层表示不同模块，第三层表示不同表，第四层表示表中的行，也就是数据项。

树中的每个结点都可以单独加锁。当事务对一个结点加锁，该事务会用同样类似的锁隐式地封锁这个节点的全部后代节点。

如果事务要给某个节点加锁，比如根节点，就需要判断是否可以给它加锁，如果这个节点的后代已经有了不相容的锁，那么就不允许加锁。一种判断方式是搜索所有后代节点，但这个方法破坏了多粒度锁的初衷。

为了更有效方便的判断节点是否可以加锁，我们引入了一种新的锁类型，即**意向锁**。如果一个结点加上了意向锁，则表示这个结点的后代结点上有显示加锁。在一个结点显式加锁之前，该结点的全部祖先结点均加上了意向锁。因此事务不必搜索整个树就可以判定能否给结点加锁。

而不同类型的锁有对应的意向锁。共享锁对应共享意向锁(IS)，排他锁对应排他意向锁(IX)。意向锁的相容性和起对应的锁的类型相同。

## 基于时间戳的协议

我们可以事先选定事务的次序来让事务的调度可串行化。最常见的方法是时间戳排序机制

### 时间戳

我们为系统中的每个事务都用一个固定时间戳与之关联，事务T的时间戳记为TS(T)。新的事务时间戳要大于旧的事务。

实现这种机制可以使用下面两种简单方法：

* 使用系统时钟的值作为时间戳
* 使用逻辑计数器，每赋予一个时间戳，计数器增加1

事务的时间戳决定了串行化顺序。若TS(T1) <TS(T2) ，则系统必须保证产生的调度等价于事务T1出现在事务T2之前的某个串行调度。

要实现这个机制，需要为每个数据项关联两个时间戳：

* `W-timestamp(Q)`，表示成功执行`write(Q)`的所有事务的最大时间戳
* `R-timestamp(Q)`，表示成功执行`read(Q)`的所有事务的最大时间戳

每当有新的读写Q的指令时，这两个时间戳旧会更新

### 时间戳排序协议

时间戳排序协议保证任何有冲突的read和write操作按时间戳排序执行。该协议按如下方式运作：

* 假设事务T发出read(Q)

  * 若TS(T) < W-timestamp(Q)，则T需要读入的Q值已经被覆盖，因此，read操作被拒绝，T回滚
  * 若TS(T) >= W-timestamp(Q)，则执行read操作，R-timestamp(Q)被设置为R-timestamp(Q)和TS(T)两者的最大值

* 假设事务T发出write(Q)

  * 若TS(T) < R-timestamp(Q),当前Q值已经被T新的事务读取过了，所以write操作被拒绝，T回滚
  * 若TS(T) < W-timestamp(Q),当前Q值已经被T旧的事务写过了，所以write操作被拒绝，T回滚

  * 其他情况，系统执行write操作，将W-timestamp(Q)设置为TS(T)

如果事务T由于发出read或write操作而被并发控制机制回滚，则系统赋予它新的时间戳并重新启动。

时间戳排序协议保证冲突可串行化，因此冲突的操作按照事务产生的先后顺序进行处理。

该协议保证无死锁，因为不存在等待的事务。但是当一系冲突的短事务引起长事务反复重启时，可能导致长事务饿死的现象。所以如果发现一个事务反复重启，与之冲突的事务应该暂时阻塞，以使该事务能够完成

该协议可能产生不可恢复的调度。可以对该协议进行扩展，来保证调度是可恢复的：

通过使用一个受限的锁形式来保证，因此，对未提交数据项的读操作被推迟倒更新该数据项的事务提交后。

### Thomas写规则

我们考虑如下调度：

| T1       | T2       |
| -------- | -------- |
| read(Q)  |          |
|          | write(Q) |
| write(Q) |          |

其中T1先于T2开始，即TS(T1)<TS(T2)

应用时间戳排序协议，T1的read(Q)操作成功，T2的write(Q)操作也成功，当T2尝试write(Q)操作时，因为TS(T1) < W-timestamp(Q)，所以T1的write(Q)操作被拒绝并且T1回滚

但是这个回滚时不必要的。由于T2已经写入了Q，因此T1想要写入的值将永远也不会被读到。因为

* 满足TS(Ti)<TS(T2)的任何事务Ti试图进行read(Q)操作时均回滚，因为TS(Ti)<W-timestamp(Q).

* 满足TS(Tj)>TS(T2)的任何事务Tj必须读T2写入的Q值，而不是T1想要写入的值。

根据以上分析，我们只需要跳过T1的write(Q)操作就能保证数据的正确性，因为T1的write操作已经过时了

这样我们将时间戳排序协议修改为Thomas写规则：假设T发出write操作：

* 若TS(T) <R-timestamp(Q)，当前的Q值已经被比T新的事务Ts读取过了，如果该操作成功，Ts就读取了脏数据。所以wirte操作被拒绝，T回滚
* 若TS(T)<W-timestamp(Q),则T事务写入的Q值已经过时。因此，该write操作可忽略
* 其他情况，系统执行write操作，将W-timestamp(Q)设置为TS(T)

## 基于有效性检查的协议

在大部分事务是只读事务的情况下，事务发生冲突的频率较低。在这种情况下，我们不进行事务的回滚或者阻塞，而是采用一种监控系统的机制。有效性检查协议要求每个事务T在其生命周期中按两个或三个阶段执行：

* 读阶段：在这个阶段，系统执行事务T，各数据项被读入并保存在事务T的局部变量中。所有write操作都是对局部临时变量进行的，并不对数据库进行真正的更新
* 有效性检查阶段：对事务T进行有效性检测。判定是否可以执行wirte操作而不违反可串行性。如果事务有效性测试失败，则终止事务
* 写阶段：若事务通过有效性检查，则将保存T的所有写操作结果的局部变量值更新到数据库中。只读事务没有该阶段。

为了检测有效性，我们需要知道事务的各个阶段何时进行。为此，我们将三个不同的时间戳与事务T相关联：

* Start(T)，事务T开始执行的时间
* Validation(T)，事务开始其有效性检查的时间
* Finish(T),事务T完成写阶段的时间

我们利用时间戳Validation(T)的值，通过时间戳排序技术决定可串行性顺序。因此，值TS(T)=Validation(T)

我们选择Validation(T)而不是Start(T)作为事务T的时间戳，是在冲突频率很低的情况下，期望有更快的响应时间。

事务T2的有效性测试要求任何满足TS(T1)<TS(T2)的事务T1满足如下两个条件之一：

* Finish(T1) < Start(T2).因为T1在T2开始之前完成执行，所以可串行性次序得到保证。
* T1所写的数据项集与T2所读的数据项集不相交，并且T1的写阶段在T2开始其有效性检查阶段之前完成(Start(T1)<Finsish(T2)<Validation(T1) ).这保证T1和T2的写不重叠。因为T1的写不影响T2的读，又因为T2不可能影响T1的读，从而保证了可串行性次序。

有效性检查机制自动预防级联回滚，因为只有发出写操作事务提交后实际的写才发生。但存在长事务饿死的可能，为了避免饿死，与之重读的事务应当短暂阻塞，以使长事务能够完成。

在有效性检查机制中，因为假定它们能够完成执行并且最终有效，因此也称为乐观的并发控制。与之相反，锁和时间戳排序是悲观的，因为当它们检测到一个冲突时，它们强迫事务等待或者回滚，即使该调度有可能时冲突可串行化的。

## 多版本机制

在多版本并发控制机制中，每个write(Q)操作创建Q的一个新版本。当事务发出一个read(Q)操作时，并发控制管理器选择Q的一个版本进行读取。并发控制机制必须保证用于读取的版本的选择能保持可串行性。

### 多版本时间戳排序

时间戳排序协议可以扩展为多版本的协议。对于系统中的每个事务T，我们将唯一的静态时间戳与之关联，记为TS(T)。数据库系统在事务开始前赋予该时间戳

对于每个数据项Q，有一个版本序列$<Q_1,Q_2,...,Q_m>$与之关联，每个版本$Q_k$包含三个数据字段：

* Content :是$Q_k$版本的值
* W-timestamp(Q)，是创建$Q_k$版本的事务的时间戳
* R-timestamp(Q),是最后一次成功读取$Q_k$版本的事务的时间戳

多版本时间戳排序机制保证可串行性，其运作如下：

设T发出read(Q)或write(Q)操作，令$Q_k$表示Q满足如下条件的版本，其写时间戳是小于或者等于TS(T)的最大写时间戳：

* 如果事务T发出read(Q)，则返回值为$Q_k$的内容
* 如果事务T发出write(Q)，
  * 若TS(T)<R-timestamp($Q_k$),则系统回滚事务T
  * 若TS(T)=W-timestamp($Q_k$)，则系统覆盖$Q_k$的内容
  * 如果没有这样的$Q_k$，则创建Q的一个新版本

第一个规则规定事务应该读取位于其前的最近版本

第二个规则规定当一个事务执行写操作“太迟”时将强迫中止。

不再需要的版本根据以下规则删除：若有数据项的两个版本Q1和Q2，这两个版本的W-timestamp都小于系统中最老的事务的时间戳，那么Q1和Q2中较旧的版本将不再被用到，可以删除

多版本时间戳排序机制有一个很好的特性：读请求从不失败且不必等待。

但是它也有两个缺点：

* 首先读取数据项要求更新R-timestamp字段，产生了两次潜在的磁盘访问而不是一次
* 其次，事务间的冲突通过回滚而不是等待来解决，这种做法的开销可能很大

### 多版本两阶段锁

多版本两阶段锁协议希望将多版本并发控制的优点和两阶段锁的优点结合起来。该协议对只读事务和更新事务加以区分：

* 更新事务执行强两阶段锁协议：即它们持有全部的锁直到事物结束。因此，它们可以按照提交的次序进行串行化。数据项的每个版本有一个计数器时间戳，称为ts-counter，这个计数器在提交处理时增加计数
* 只读事务在开始执行前，数据库系统会数据库系统读取ts-counter的当前值作为该事务的时间戳。只读事务在执行读操作时遵循多版本时间戳排序协议。因此，只读事务T发出read(Q)时，返回值是小于TS(T)的最大时间戳的版本的内容

当更新事务读取一个数据项时，它在获得该数据项上的共享锁后读取该数据项最新版本的值。当更新事务想写一个数据项时，它首先要获得该数据项上的排他锁，然后为该数据项创建一个新版本。写操作在新版本上进行，新版本的时间戳最初置为无穷大。

但更新事务TW完成任务后，它将按照如下方式提交：首先T将它创建的每一版本的时间戳设置为ts-counter的值加1；然后T将ts-counter增加1。在同一时间只允许有一个更新事务进行提交。

这样，在T增加了ts-counter之后启动那个的只读事务将看到T更新的值，而在T增加ts-counter之前就启动的只读事务只能看到T更新之前的值。

多版本两阶段锁保证调度是可恢复和无级联的。

版本的删除类似于多版本时间戳协议。

## 快照隔离

快照隔离是一种特殊的并发控制机制。在商业和开源系统中广泛应用。

从概念上讲，快照隔离在事务开始执行时给它数据库一份快照。然后，事务在快照上操作，和其他并发事务完全隔离。快照中的数据值仅包含已经提交的事务所写的值。

这种隔离对于只读事务来说是立项的，因为它们不用等待，也不会被并发管理器中止。

但是对于更新事务，必须在讲更新写入数据库之前，处理于其他并发更新事务之间存在的潜在冲突。

更新操作发生在事务的私有工作空间中，直到事务成功提交，此时更新写入数据库。当允许事务T提交时，事务T变为提交状态，并且T对数据库的所有写操作都必须作为一个原子操作执行，以保证其他事务的快照要么包括T的所有更新，要么都不包括

### 更新事务的有效性检验步骤

两个并发执行的事务可能会更新同一个数据项。由于两个事务的操作用它们各自的私有快照隔离，因此任何事物都看不到对方所做的更新。如果两个事务都被允许写入数据库，第一个更新的写入就会被第二个覆盖。结果导致一个更新丢失。

为了预防更新丢失，产生了快照隔离的两个变种，它们被称为先提交者获胜和先更新者获胜。

如果从事务T开始到执行这个检查之间的任何时刻，有事物是活跃的或者部分提交的，那么这样的事务就称为与T并发的。

按照先提交者获胜方法，当事务T进入部分提交状态，进行以下操作，并且以下操作作为一个原子操作执行：

* 检查是否有与T并发执行的事务，并且对于T打算写入的数据项，该事务已经将更新写入数据库
* 如果有这样的事务，则T中止
* 如果没有发现这样的事务，则T提交，并且将事务写入数据库

按照先更新者获胜方法，系统采用一种仅用于更新操作的锁机制。当事务T试图更新一个数据项时，它请求该数据项的一个写锁。如果没有另一个并发事务持有该锁，那么能够获取锁并进行操作。如果有其他并发啊实物已经获取了锁。则T不能执行，并等待持有该锁的事务Ts中止或者提交。

* 如果Ts中止，则锁被释放并且T可以获得锁
* 如果Ts提交，则T必须中止

### 串行化问题

快照隔离的开销很低并且没有中止发生，除非两个并发更新事务冲突。

但是，实践中快照隔离机制存在一个严重的问题：快照隔离不能保证可串行化。例如：

两个并发事务T1和T2，T1读取A和B，然后更新B。T2读取A和B，然后更新A。由于T1和T2更新的是不同的数据项。不管系统采用先提交者获胜或者先更新者获胜，两者都可以提交。但是这两个事务的调度是不可串行化的，是有冲突的。

像这种一对事务中每一个都读取对方写的数据，但是不存在两者同时写的数据，这种情况称为写偏斜。

存在规范的方法用来判断给定一个事务的混合运行，是否存在快照隔离下非串行化执行的风险。但是这些方法只有在我们事先知道要执行什么事务时才有效。

## 插入、删除操作

到目前为止我们讨论的并发控制只限于read和write操作。但是删除和新增操作同样会影响并发控制。

我们引入一下操作：

* delete(Q)：从数据库删除数据项Q
* insert(Q)：插入一个新的数据项Q到数据库中并赋予Q一个初值

### 删除

我们需要知道delete指令与何种指令会发生冲突，令I和J分别为T1和T2的指令，它们连续地出现在调度S中。令I=delete(Q)，我们考虑如下指令：

* J=read(Q)，I和J冲突。如果J在I之后，J指令将查回空。
* J=write(Q)，I和J冲突。如果J在I之后，J指令将出错。
* J=delete(Q),I和J冲突。不管I，J何种次序，两者都有冲突
* J=insert(Q),I和J冲突。
  * 如果数据项Q原本存在， 必须J在后
  * 如果数据项Q原本不存在，必须J在前

所以删除操作和所有操作都冲突。

在两阶段锁协议下，删除操作必须申请排他锁。

在时间戳排序协议下，必须执行与write操作相似的测试。假设事务T发出delete(Q)

* 若TS(T) < R-timestamp(Q),当前Q值已经被T新的事务读取过了，所以delete操作被拒绝，T回滚
* 若TS(T) < W-timestamp(Q),当前Q值已经被T旧的事务写过了，所以delete操作被拒绝，T回滚

* 其他情况，系统执行delete操作

### 插入

insert操作和delete操作类似。与其他所有操作都冲突

所以：

* 在两阶段锁协议下，需要为insert操作请求排他锁
* 在时间戳协议下，如果T执行insert(Q)操作，就把R-timestamp(Q)和W-timestamp(Q)的值设为TS(T)

### 谓词读和幻读

考虑如下两条SQL查询：

~~~sql
select count(*) from instructor where dept_name = 'Physics';   # s1
insert into instructor values(11111,'Feynman','Physics',94000); # s2
~~~

在一个调度中，s1和s2不同的执行顺序会导致不同的结果，假设原表中有30条数据满足s1：

s1在前，s1将返回30；s1在后，s1将返回31。

所以尽管两条语句没有访问共同的元组，但是它们相互冲突。

为了避免幻读，在锁协议中，执行s1时需要对整个关系进行加锁。但这会导致并发程度低。

较好的方法是使用索引锁技术，它避免封锁整个索引。在关系中插入元组的任何事务必须在该关系上维护的每一个索引中插入有关信息。通过使用索引的锁协议，我们可以避免幻读。我们现在只考虑B^+^树索引

概括来说，每一个搜索码值与索引中的一个叶结点相关联。而查询通常使用一个或者多个索引来访问关系。我们可以在索引的叶结点上加锁。让s1和s2在该叶结点上发生冲突，从而避免幻读。

索引锁协议具体运作如下：

* 每个关系至少有一个索引
* 只有查找的事务T必须在它要访问的所有索引叶结点上获得共享锁
* 在没有更新关系r上的所有索引之前，事务T不能插入、删除或更新关系r中的元组t。
* 元组照常获得锁
* 必须遵循两阶段锁协议

# 恢复系统

计算机系统会发生故障。故障的原因，包括磁盘故障、电源故障、软件错误，甚至人为破坏。数据库系统必须预先采取措施，以保证即使发生故障，也可以保证事务的原子性和持有性。

恢复系统是数据库系统必不可少的组成部分，它负责将数据库恢复到故障发生前的一致状态。

恢复系统还必须提供高可用性，即它必须将数据库崩溃后不能使用的时间缩减到最短。

## 故障分类

系统可能发生的故障有很多种，我们只考虑下面类型的故障：

* 事务故障：
  * 逻辑错误：事务由于某些每部条件而无法继续正常执行，如非法输入、找不到数据、溢出或者超出资源限制
  * 系统错误：事务进入一种不良状态(如死锁),结果事务无法继续正常执行。
* 系统崩溃：硬件故障，或者数据库软件或操作系统的漏洞，导致易失性存储器内容的丢失，并使得事务处理停止。而非易失性存储器存储仍完好无损。
* 磁盘故障。在数据传送操作过程种由于磁盘故障导致内容丢失。

## 恢复与原子性
