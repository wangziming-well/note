# 事务概述

从数据库用户的观点来看，数据库中的一些操作的集合被认为是一个独立单元。不如，从顾客角度来看，银行转账是一次单一的操作，而在数据库系统中，这些由几个操作组成。显然，这些操作要么全部发生，要么由于出错而全不发生。

构成单一逻辑工作单元的操作集合称为事务。这些操作步骤集合必须作为一个单一的、不可分割的单元出现。

由于事务是不可分割的，要么执行其全部内容，要么就根本不执行。因此，如果一个事务开始执行，但是由于某些原因失败，那事务对数据库造成的任何可能的修改都要撤销。无论是事务本身的失败，还是操作系统崩溃，或者计算机本身停止运行，这项要求都要成立。这种“全或无”的特性称为**原子性**

此外，由于事务是一个单一的单元，它的操作不能看起来是被其他不属于该事务的分隔开的。数据库必须采取特殊处理来保证事务正常执行而不被来自并发执行的数据库语句干扰。这种特性称为**隔离性**

即使系统能保证一个事务的正确执行，但如果执行后因为各种原因，入系统崩溃，导致系统丢失了事务的执行结果。那么事务的意义也不大。所以即使崩溃后事务的操作也必须是持久的。这种特性称为**持久性**

事务必须保持数据库的一致性：如果一个事务作为原子从一个一致的数据库状态开始独立运行，则事务结束时数据库也必须再次是一致的。这种一致性的约束远比数据完整性约束(如主码约束、参照完整性等)复杂，是基于数据库建模的现实模型要求的约束。如一次转账后，A账户少的钱需和B账户多的钱相等。实现这种一致性是编写事务的程序员的责任。这种特性就是**一致性**

将上述内容重新描述，我们要求数据库系统维护事务的以下性质：

* 原子性：事务的所有操作在数据库中要么全部正确反映出来，要么完全不反映
* 一致性：隔离执行事务时，保持数据库的一致性
* 隔离性：在多个事务并发执行的情况下，保证对任何一对事务$T_i$和$T_j$在$T_i$看来，$T_j$要么已经执行了，要么还没执行，在$T_i$的视角下不存在$T_j$执行中的状态
* 持久性：一个事务成功完成后，它对数据库的改变必须时永久的，即使出现系统故障

这些特性通常称为ACID特性

# 一个简单事务模型

因为SQL语言很复杂，为了学习事务，我们先采用一种简单的数据库语言。该语言关注数据何时从磁盘移动到主存以及何时从主存移动到磁盘。忽略SQL插入和删除操作。

在这个简单的事务模型中，对数据的实际操作仅限于算数操作。数据项只含一个单一的数据值。每个数据项由一个名字所标识。

采用一个由几个账户和更新账户的事务集合构成的简单银行应用来阐明事务概念。事务运用以下两个操作访问数据：

* `read(X)`：从数据库把数据项X传给到执行read操作的事务的主存缓冲区的一个也叫X的变量中
* `write(X)`:从执行`write`的事务的主存缓冲区的变量X中把数据项X传回数据库中

设$T_i$是从账户A过户$\$50$到账户B的事务。这个事务可以定义未：
$$
\begin{flalign}
\begin{split}
T_i:&read(A); \\
&A:= A -50; \\
&write(A); \\
&read(B); \\
&B:=B+50;\\
&write(B); \\
\end{split}&
\end{flalign}
$$
以这个事务为例，我们考虑ACID特性

* 一致性：在这里，一致性要求事务的执行不改变A、B之和。

* 原子性：在系统执行事务时，一定会有一段时间处在不一致的状态，比如在A账户转出钱后，B账户还没有收到钱。但是要保证事务结束时，系统要处在一致性状态。所以要求事务内的操作集合要么全部成功，要么全部失败。

  保证原子性的基本思路是：对于事务要执行写操作的数据项，数据库系统在磁盘上记录其旧值。这个信息记录在日志文件中。如果事务内能完成它的执行，数据库系统从日志中恢复旧值，使得看上去事务从未执行过。

* 持久性：一旦事务完成，该事务对数据库所作的更新都是池就的，即使之后出现系统故障。

  我们假设计算机系统的故障将会导致内存中的数据丢失，但已写入磁盘的数据绝不会丢失。我们可以确保以下两条中的任何一条来做到持久性：

  * 事务做的更新在事务结束前已经写入磁盘
  * 有关事务已执行的更新信息已写入磁盘上，这些信息必须充分，能让数据库系统在恢复数据时能重新构造更新

* 隔离性：在多个事务并发更新时，当前事务对其他事务必须是不可见的，否则会造成数据不一致

