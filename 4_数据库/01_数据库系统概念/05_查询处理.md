# 查询处理概述

查询处理是指从数据库中欧给提取数据时涉及的一系列活动，包括：将用高层数据库语言表示的查询语句翻译为能在文件系统的物理层上使用的表达式，为优化查询而进行的各种转换，以及查询的实际执行。

查询处理的基本步骤如下：

1、语法分析和翻译

2、优化

3、执行

![QueryProcessing](https://gitee.com/wangziming707/note-pic/raw/master/img/QueryProcessing.png)

**翻译**

查询处理开始之前，系统内部必须将查询语句翻译成可用的形式，SQL这样的语言适合人使用，但是不适合查询的系统内部表示。一般的系统内部表示是建立在扩展的关系代数基础上的。

所以，查询处理中系统首先必须把查询语句翻译成系统的内部表示形式。该翻译的过程由类似于编译器的语法分析器来完成。

在翻译过程中，语法分析器检查用户查询的语法，验证查询中出现的关系名是否在数据库中存在等。构造该查询语句的语法分析树，然后将之翻译成关系代数表达式。

如果查询是用视图形式表示的，翻译阶段还要用定义该视图的关系代数表达式来替换所有对该视图的引用。

对于同一个查询，通常可以翻译成多个关系代数表达式。例如查询：

~~~sql
select salary instructor where salary < 75000;
~~~

该查询语句可以翻译成下面两个关系代数表达式中的任意一个:
$$
\begin{flalign}
\begin{split}
&\bullet  \sigma_{salary< 75000} (\Pi_{salary}(instructor))  \\
&\bullet \Pi_{salary}(\sigma_{salary<75000}(instructor))

\end{split}&
\end{flalign}
$$
**优化**

要全面说明如何执行一个查询，我们不仅需要提供关系代数表达式，还要对表达式加上注释来说明如何执行每个操作。

注释可以什么某个具体操作所采用的算法，或将要使用的特定的索引。

加了“如何执行”注释的关系代数运算称为计算原语。

用于执行一个查询的原语操作序列称为查询执行计划。

一个查询执行计划如下：
$$
\Pi_{salary} \to \sigma_{salary<75000};使用索引l \to instructor
$$
给定查询的不同执行计划会有不同的代价。而构造具有最小查询执行代价的查询执行计划是系统的责任，这项工作就叫查询优化

为了优化查询，查询优化器必须知道每个操作的代价。虽然精确计算代价是很难的，但是对每个操作的执行代价得出一个粗略的估计是可能的。

**执行**

查询执行引擎接受一个查询执行计划，执行该计划并把结果返回给查询

# 查询代价的度量

数据库中可以存在多种可能的查询计算计划，我们需要根据它们的(估计)代价来对不同的计划做比较，并选择最佳方案。为此我们必须估计个别操作的成本，并结合它们得到要给查询执行计划的开销。

查询处理的代价可以通过该查询对各种资源的使用情况进行度量，这些资源包括本地磁盘存取、所用CPU时间，和再并行/分布式数据库系统中的通信代价。

但是在大型数据库系统中，在本地磁盘上存取数据的代价通常是最主要的代价，因为相比于cpu执行、和内存存取，在本地磁盘上的存取耗时通常要高上几个数量级。

所以可以说花费在磁盘存取上的时间决定了着整个查询计划的执行时间。所以为了简化问题，我们将忽略CPU时间，仅仅用磁盘存取代价来度量整个查询执行计划的代价。

我们用传送磁盘块数和搜索磁盘次数来度量查询执行计划的代价：假设磁盘子系统传输一个块的数据平均耗时$t_\tau$秒，磁盘的平均访问时间为$t_s$秒，则一次传输$b$个块以及执行$S$次磁盘搜索的操作将消耗$b\times t_\tau + S \times t_s$秒。

假设磁盘块的的大小是4KB，传输率为40MB/秒。那么$t_s = 4 ms$ ，$t_\tau = 0.1 ms$

为了简化代价的估算，我们需要简化以下需要考虑的要素：

* 通过把读磁盘和写磁盘区分开，可以进一步细化磁盘读取代价的估算。因为写磁盘的代价通常是读磁盘的两倍。简化起见我们忽略这个细节。
* 暂时不考虑将操作的最终结果写回磁盘的代价，在需要时再单独考虑
* 执行计划的代价依赖于主存中缓冲区的大小。最好的情况是所有的数据都可以读入到缓冲区中，不必再访问磁盘。最坏的情况是假定缓冲区只能容纳数目不多的数据块。我们通常假定是最坏的情况
* 尽管我们假定开始时数据必须从磁盘中读取出来，但是很可能我们访问的磁盘块已经再内存缓冲区中了，为了简化起见，这种情况也忽略了。

所以执行一个查询计划过程中的实际磁盘存取代价可能比估计的要小。

假设计算机中没有其他活动在进行，那么一个查询计算计划的响应时间就是所有的这些开销，并可以作为计划的代价的度量。但是，没有实际地执行计划，就很难估算计划的响应时间，因为：

* 查询计划的执行的响应时间依赖有缓冲区中的内容，如果缓存未命中，那么响应时间会很高，如果缓存命中，则响应时间会大大降低
* 在多磁盘系统中，响应时间依赖于访问如何分布在各磁盘上。

因此，  优化器通常尽可能降低查询计划总的资源消耗，而不是尽可能缩短响应时间。

# 选择运算

在查询处理中，文件扫描时存取数据最低级的操作。文件扫描是用于定位、检索满足选择条件的记录的搜索算法。在关系系统中，若关系保存在单个专用的文件中，采用文件扫描就可以读取整个关系。

索引结构成为存取路径，因为它们提供了定位和存取数据的一条路径。

主索引(聚集索引)允许文件记录可以按照于其在文件中的物理顺序一致的顺序进行读取

## 等值比较的选择

考虑所有元组都保存在单个文件的关系上的一个选择运算。执行一个选择最简单的方式如下：

**A1(线性搜索)**

在线性搜索中，系统扫描每一个文件块，对所有的记录都进行测试，看它们是否满足条件。

虽然线性搜索比其他实现选择操作的算法速度慢，但它可以用于任何文件，不管该文件的顺序、索引的可用性，以及选择操作的种类。

如果是非码属性的搜索，线性搜索需要扫描整个文件，所以需要开销:$t_s+b_r*t_\tau$，一次初始搜索(搜索文件位置)和$b_\tau$个块传输($b_\tau$表示文件中的块数)

如果是码属性的搜索，那么找到记录后就可以停止搜索，这样开销的期望值为$t_s+b_r*t_\tau /2$

**A2(主索引，码属性等值比较)**

对于具有主索引的码属性的等值比较，我们可以使用索引检索到满足相应等值条件的单条记录

我们使用$h_i$表示B^+^树的高度，如果是B^+^树文件组织，那么可以节省一次存取。

使用$B^+$树作为主索引，搜索时需要进行$h_i$次I/O操作来读取节点，再加上最后一次I/O操作来取记录，每次I/O操作都需要一次搜索和一次块传输。那么开销为：$(h_i+1)*(t_\tau+t_s) $

**A3(主索引，非码属性等值比较)**

当选择条件是基于非码属性A的等值比较时，可以利用主索引检索到多条记录。与上一中情况唯一不同的是，这种情况需要取多条记录。因为文件是按照搜索码进行排序的，所以这些记录在文件中必然是连续存储的。

找到第一条记录的开销和A2一样，接下来的开销就是顺序传输符合条件的记录的块，设B是要传输的块数,则开销为$h_i*(t_\tau+t_s) + b*t_\tau$

**A4(辅助索引,等值比较)**

使用等值条件的选择可以使用辅助索引。

若等值条件是码属性上的，那么这种情况下的时间代价与主索引的情况A2一样,开销为$(h_i+1)*(t_\tau+t_s) $

若等值条件是非码属性上的，符合条件的多条记录可能存在于不同的磁盘块，可能导致每检索到一条记录需要一次I/O操作，以及一次I/O操作需要一次搜索和一个磁盘块传输。最坏的情况下，时间代价是$(h_i+n)*(t_s+t_\tau)$,其中n是所取的记录数

## 比较的选择

考虑形如$\sigma_{A\le v }(r)$的选择，我们可以使用线性搜索，或者使用下面索引来实现选择运算：

**A5(主索引，比较)**

在选择条件是比较时，可使用顺序主索引。形如$A >v$或者$A \ge v$的比较条件，可以按以下方式使用A上的主索引来进行元组的搜索:

对于$A \ge v$，可以在索引中寻找值v，以检索满足条件$A=v$的首条记录。从该元组开始到文件末尾进行一次文件扫描就返回所有满足该条件的元组。

对于$A > v$，文件扫描从第一条满足$A > v$的记录开始。

对于形如$A<v$和$A\le v$的比较式，没有必要使用索引，只需要简单地从文件头开始进行文件扫描，直到遇上首条不满足条件的元组为止

和A3的非码属性开销一样，需要$h_i*(t_\tau+t_s) + b*t_\tau$的开销

**A6(辅助索引，比较)**

辅助索引提供了指向记录的指针，但我们仍然需要使用指针以取得实际的记录。由于连续的记录可能存在不同的磁盘块中，因此每取一条记录可能需要一次I/O操作。如果检索得到的记录数很大，使用辅助索引的代价甚至比线性搜索还要大。

其开销和A4的非码属性情形一样，需要$(h_i+n)*(t_s+t_\tau)$的开销

## 复杂选择的情况

上面我们讨论等值比较或者比较运算这种简单选择条件。现在我们看更复杂的选择谓词，

* 合取：$\sigma_{\theta_1 \and \theta_2 \and ...\and \theta_n}(r)$
* 析取：$\sigma_{\theta_1 \or \theta_2 \or ...\or \theta_n}(r)$

* 取反：$\sigma_{\lnot\theta }(r)$

其中$\theta$是等值比较或者比较运算这样的简单条件

我们可以使用下面算法之一来实现设计多个简单条件的合取或析取的选择操作

取反操作比较简单，对于等值比较的取反，必须对整个文件进行扫描。

对于比较的取反，只需要执行比较的反面即可

**A7(利用一个索引的合取选择)**

首先我们判断是否存在某个简单条件中的某个属性上的一条存取路径。

若存在，则可以使用算法A2~A6中的一个来检索满足该条件的记录。然后在内存缓冲区中。我们通过测试每条检索到记录是否满足其余的简单操作，来获取最终的结果

为了减少代价，我们要选择$\theta_i$以及A1~A6算法之一，它们的组合可使$\sigma_{\theta_i}(r)$的代价达到最小。

**A8(使用组合索引的合取选择)**

某些合取操作可能使用合适的组合索引。如果选择指定的是两个或多个属性上的等值条件，并且在这些属性字段的组合上又存在组合索引，则可以直接使用该索引。根据索引类型使用A2，A3，A4中的一种。

**A9(通过标识符的交实现合取选择)**

这种方式利用指针或记录标识符。该算法要求各个条件所涉及的字段上都有带指针记录的索引。

该算法对每个索引进行扫描，获取那么指向满足单个条件的记录的指针。所有检索到的指针集合的交集就是那些满足合取条件的指针的集合。利用这个指针集合获取实际的记录。

如果并非所有条件上的属性都存在索引，接下来就要用剩余条件对所检索到的记录进行测试

**A10(通过标识符的交实现析取选择)**

和A9类似，只是在获取满足单个条件的记录的指针。所有检索到的指针集合的并集就是满足析取条件的集合。

但是，即使只有其中一个条件不存在存取路径，我们也必须对这个关系进行一次线性扫描以找出满足条件的元组。

因此，如果析取式中有一个这样的条件，最有效的方法就是线性扫描，扫描的同时对每个元组进行析取条件测试。

# 排序

数据排序在数据库系统有重要的作用，原因有两个：

* SQL查询会指明对结果进行排序
* 当输入的关系已排序时，关系运算中的一些运算(如连接运算)能够得到高效实现

可以在要排序的码上建立索引，然后使用该索引按顺序读取关系，可以完成对关系的排序。然而，这一过程仅仅是在逻辑上通过索引对关系排序，并没有在物理上排序，因此顺序读取元组可能导致每读一个元组都要访问一次磁盘。由于记录数目可能比磁盘块数目大得多，这样的代价会很大。所以，有时需要在物理上对记录排序。

在逻辑上对关系排序，可以使用标准的排序技术(如快排).

我们这里主要讨论在物理上对记录排序。

## 外部排序归并算法

对不能全部放在内存中的关系的排序称为**外排序**

外排序中最常见的技术是外排序归并算法。

令$M$表示内存缓冲区中可以用于排序的块数。接下来表述该算法：

1、 第一阶段，建立多个排好序的归并段。每个归并段都是排序过的，仅包含关系中的部分记录：
$$
\begin{flalign}
\begin{split}
 &i = 0 ;\\
 &repeat \\
 &\qquad 读取关系的M块数据或剩下的不足M块的数据; \\
 &\qquad 将内存中对关系的这一部分进行排序; \\
 &\qquad 将排好序的数据写入到归并段文件R_i中; \\
 &\qquad i= i+1; \\
 &\ until\ 到达关系末尾\\
\end{split}&
\end{flalign}
$$
2、第二阶段，对归并段进行归并，假设第一步产生N个归并段文件

假设N小于M，那么就可以为每个归并段文件分配一个块，剩下的空间还能容纳存放结果的块：

为N个归并段文件$R_i$各分配一个内存缓冲块，并分别读入一个数据块：
$$
\begin{flalign}
\begin{split}
 &repeat \\
 &\qquad 在所有缓冲块中挑选出第一个元组;\\
 &\qquad 把该元组作为输出写出，并将其从缓冲块中删除;\\
 &\qquad if \ 任何一个归并段文件R_i的缓冲区为空并且没有达到R_i末尾; \\
 &\qquad\qquad then \ 读入R_i的下一块到相应的缓冲块; \\
 & until \ 所有的缓冲块均为空
\end{split}&
\end{flalign}
$$
这样输出的就是排序后的元组

如果关系比内存大得多，那么N就很容易大于M，这样在归并阶段为每个归并段分配一个块是不可能的。此时归并操作需要分多趟进行。

在进行多轮归并时，第一轮，先将归并段分组为每组M-1个归并段，然后每组进行归并，归并输出的结果成为下一轮归并的输入；经过第一轮后，归并段数目减少到原来的$1/(M-1)$。这样经过多轮归并，直到只剩下一个归并段，也就是输出

如图是M为3，N为4的归并示例：



![外归并排序示例png](https://gitee.com/wangziming707/note-pic/raw/master/img/%E5%A4%96%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%A4%BA%E4%BE%8Bpng.png)

## 外排序归并的开销

首先计算算法的磁盘存取代价，设$b_r$表示关系r中记录的磁盘块数：

在第一阶段要读入关系的每一个数据块并写出，共需$2b_r$次磁盘块传输。初始归并段为$\lceil b_r/M \rceil$。由于每趟归并会使归并段数目减少为原来的$1/(M-1)$，所以归并的总趟数为$\lceil log_{M-1}(b_r/M) \rceil$。每一趟都需要读入和写出每一块磁盘。如果最后一次归并只输出结果i而并不写入磁盘，那么外排序归并的磁盘块传输的总数为：
$$
 b_r(   2\lceil log_{M-1}(b_r/M) \rceil +1 )
$$

# 连接运算

我们用等值连接来表示形如$r \Join_{r.A = s.B} s$的连接，其中A，B分别是关系r和s的属性或者属性组。

我们使用下面的表达式作为例子：
$$
student \Join takes
$$

* student的记录数是$n_s$
* student的磁盘块数是$b_s$
* takes的记录数为$n_t$
* takes的磁盘块数为$b_t$

## 嵌套循环连接

最简单的算法就是直接遍历两个关系，测试每对元组是否满足条件。这就是嵌套循环算法。

下面给出了计算两个关系$r$和$s$的$\theta$连接$r\Join_\theta s$的嵌套循环算法：

其中关系$r$称为链接的外层关系，$s$称为连接的内层关系。

$t_r和t_s$表示r、s的元组，$t_r\cdot t_s$表示将$t_r$和$t_s$元组的属性值拼接而成的元组。
$$
\begin{flalign}
\begin{split}
 &for \ each \ 元组t_r\  in\ r\ :\\
 &\qquad for \ each \ 元组t_s\  in\ s\ :\\
 &\qquad\qquad 测试元组对(t_r,t_s)是否满足连接条件\theta\\
 &\qquad\qquad 如果满足，把t_r.t_s添加到结果中

\end{split}&
\end{flalign}
$$


该算法不需要索引，但是代价很大，因为逐个检查两个关系中的每一对元组，要检查$n_t\times n_s$次

**最坏的情况下**缓冲区只能容纳每个关系的一个数据块：

因为对关系$r$中的每一条记录，都必须对$s$做一次完整的扫，此时需要$n_r\times b_s + b_r$次数据块传输

对内次扫描内层关系s我们只需要一次磁盘搜索，因为它的数据是顺序读取的，而读取关系r需要$b_r$次磁盘搜索，所以共需要$n_r+b_r$次磁盘搜索

**最好的情况下**内存有足够的空间同时容纳两个关系，此时每个数据块只需要读一次，只需要$b_r+b_s$次块传输和两次磁盘搜索。

如果只有一个关系能完全放到内存总，有两种情况：

* 将外层关系r全部放到内存中，仍然需要$n_r\times b_s + b_r$次块传输，和$n_r+1$次磁盘搜索
* 将内层关系s全部放到内存中，需要$b_s+b_r$次块传输，和$b_r+1$次磁盘搜索

由此可见，这种情况下降内层关系放到内存中更合适

## 块嵌套循环连接

因缓冲区太小而内存不能完全容纳任何一个关系时，可以以块的方式而不是以元组的方式处理关系，这样可以减少不少块读写次数：
$$

$$





