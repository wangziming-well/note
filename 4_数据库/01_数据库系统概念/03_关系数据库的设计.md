# 关系数据库设计概述

关系数据库设计的目的是生成一组关系模式，使存储信息时避免不必要的冗余，同时让我们更方便高效地获取信息。这是通过设计满足适当范式的模式来实现的。

我们首先来探讨什么样的模式设计是更合适的。

例如大学中部门实体集和导师实体集对应的关系模式：

~~~sql
instructor(ID,name,dept_name,salary);
department(dept_name,building,budget);
~~~

## 更大的模式

考虑用更大的模式来替代insructor和department模式：

~~~sql
inst_dept(ID,name,salary,dept_name,building,budget);
~~~

使用这个更大的模式，在进行某些查询的时候可以用哪个更少的连接来表达。但是，这是以信息的冗余为代价的：一个系中的所有教师都不得不重复一遍系信息building和budget。并且这些所在建筑和预算信息必须相同。否则数据库将不一致。

即使我们容许冗余的问题。inst_dept模式仍然存在其他问题：如果我们在大学里创建一个新的系。使用inst_dept使我们无法直接表达关于一个系的信息，除非该系在学校中至少有一位教师。

## 更小的模式

我们从inst_dept模式开始。我们已经知道了它是一个坏的模式设计，那在此之前我们又该如何发现它有信息重复并且需要分解成instructor和department两个模式呢？

我们可以通过观察发现每个与系关联的见识都需要列一遍办公楼和预算所导致的信息重复。但是这是一个不可靠的方式。一个真实的数据库拥有大量模式以及数量更多的属性。我们没办法通过一个一个观察来发现是否有信息重复。并且我们没办法确认这种观察到的重复是否只是一种偶然。除非我们了解模式对应在现实中的实体的规则。

为了能够精确的发现信息重复，我们需要一条规则，那就是**函数依赖**：如果存在模式A，A有属性a，则a可以作为主码

例如如果存在模式(dept_name,budget)，则是dept_name可以作为主码。

通过这样的规则，我们就能够发现信息重复，由于dept_name在inst_dept中不是主码，所以budget就有可能重复。

通过函数依赖，可以让数据库设计者发现一个模式应拆分或者分解为两个或者多个模式

但不是所有的分解都是有益的。有些分解会让模式无法真正区分实体，或者表达实体的重要信息。这样的分解就是有损分解。反之则称为无损分解

# 原子域和第一范式

在关系模式中，一个域是原子的，即该域的元素被认为是不可分的单元。

如果R的所有属性的域都是原子的，那么我们称关系模式R属于第一范式(First Normal Form,1NF)

而一个域是否是原子的，取决于在数据库中我们如何使用域元素。

如果我们认为整数是原子的，那么整数的集合就是一个原子域，但是如果我们认为整数是一列有序的数字，那么这样的整数的集合就是非原子的。

有时候非原子域的组合值属性常常很有用，在包含复杂结构的实体域中，强制使用第一范式会给程序员造成不必要的负担：必须编写代码将数据转换为原子形式。从原子形态来回转换数据也会在运行时造成额外开销。

所以在这样的域中支持非原子的值是很有用的。

# 使用函数依赖进行分解

前面提到了基于码和函数依赖来判断一个关系模式是否应该分解。我们继续用符号语言深入学习这些内容

* 一般情况下，用希腊字母表示属性集合(例如$\alpha$).

* 用一个小写的罗马字母后面跟着一对圆括号括住的大写字母来指关系模式，例如$r(R)$，其中$r$表示关系，$R$表示属性集。如果我们不关注关系的名称时，可以简化为只用$R$

  当然，一个关系模式一定是一个属性集，但并非所有的属性集都是模式。

* 当属性集是一个超码时，用$K$表示

## 码和函数依赖

一个关系的满足所有现实世界约束的实例，称为关系的合法实例；一个数据库实例中所有关系实例都是合法实例，这样的数据库实例称为数据库的合法实例。

我们用符号语言重新定义超码：

令$r(R)$是一个关系模式。$R$的子集$K$是$r(R)$的超码的条件是：
$$
在关系r(R)的任何合法实例中，对于r的实例中的任意元组t_1和t_2，满足若t_1 \neq t_2  则 t_1[K] \neq t_2[K] \\ 即在关系r(R)的任意合法实例中没有两条元组在属性集K上存在相同的值。\\ 这样在r中的一个K值唯一标识一条元组
$$
超码时能够唯一标识整条元组的属性集，函数依赖让我们可以表达唯一标识某些属性的值的约束。

考虑一个关系模式$r(R)$，令$\alpha \subseteq R 且 \beta \subseteq R$

* 给定$r(R)$的一个实例，这个实例满足函数函数依赖$\alpha \to \beta$的条件是：

  $\forall 实例中元组对t_1,t_2,若t_1[\alpha]=t_2[\alpha],则t_1[\beta]= t_2[\beta]$

* 如果在$r(R)$的每个合法实例中都满足函数依赖$\alpha\to\beta$，则函数依赖在模式$r(R)$上成立

通过如上定义，我们有结论：如果函数依赖$K\to R$在$r(R)$上成立，则$K$是$r(R)$的一个超码

所以对于关系`inst_dept(ID,name,salary,dept_name,building,budget)`

在该模式中函数依赖$dept\_name\to budget$成立，因为对于每个系，都存在唯一的预算

如果一个函数依赖在它们的所有关系上都满足，那么这样的函数依赖就是**平凡的**

一般的，如果$\beta\subseteq\alpha$，则$\alpha\to\beta$是平凡的

函数依赖具有传递性，给定模式`r(A,B,C)`，如果函数依赖$A\to B$和$B \to C$在`r`上成立，则函数依赖$A \to C$也一定在`r`上成立

我们使用$F^+$来表示$F$函数依赖集合的闭包，也就是能从给定$F$推导出的所有函数依赖的集合

## Boyce-Codd范式

Boyce-Codd范式(Boyce-Codd Normal Form,BCNF)能消除所有基于函数依赖能够发现的冗余。

具有函数依赖集$F$的关系模式$R$属于BCNF的条件是，对$F^+$中所有形如$\alpha\to \beta$的函数依赖，下面至少有一项成立：

* $\alpha\to \beta$是平凡的函数依赖(即$\beta \subseteq \alpha$)
* $\alpha$ 是模式R的一个超码

一个数据库设计属于BCNF的条件是，构成该设计的关系模式集中的每个模式都属于BCNF

如果一个关系模式不属于BCNF模式，那么我们可以对其进行分解：

如果R为不属于BCNF的一个模式则有：
$$
\exists 函数依赖\alpha\to\beta ，其中 \alpha\to\beta是非平凡的，且 \alpha 不是R的超码
$$
那么我们可以用下面两个模式取代$R$:

* $(\alpha\cup \beta )$
* $R- (\beta -\alpha)$

例如对`inst_dept(ID,name,salary,dept_name,building,budget)`来说$\alpha =\{dept\_name \}$和$\beta = \{building,budget \}$

可以将其分解为：

* `(dept_name,building,budget)`
* `(ID,name,salary,dept_name)`

我们分解不属于BCNF的模式时，产生的模式中可能仍有一个或者多个不属于BCNF。在这种情况中，需要进一步分解。

## BCNF和保持依赖

在大学的数据库模型中，如果要求教师只能和单个系关联，且一个学生可以有多个导师，但是一个给定的系中至多一位(这对多专业的学生来说有意义)

那么对于实体集关系：

* `student(ID,name,tot_cred)`
* `instructor(ID,name,salary)`
* `department(dept_name,building,budget)`

来说，有联系集关系：

`dept_advisor(s_id,i_id,dept_name)`

因为有上述要求的约束，那么下面函数依赖在`dept_advisor`上成立
$$
i\_id \to dept\_name \\
s\_id ,dept\_name \to i\_id
$$
因为`i_id`不是超码，根据BCNF分解规则，可以得到：

* `(s_id,i_id)`
* `(i_id,dept_name)`

这样以上两个模式都属于BCNF

但是这样的两个模式没有一个模式包含函数依赖$s\_id ,dept\_name \to i\_id$

这样的模式设计使得该函数依赖的强制实施在计算上很困难，因此我们称这样的设计不是保持依赖的

由于我们常常希望保持依赖，因此我们需要考虑另外一种必BCNF弱的范式，它允许我们保持依赖。该范式称为第三范式

## 第三范式

BCNF要求所有非平凡函数依赖都形如$\alpha \to \beta$ ,其中$\alpha$ 为一个超码。第三范式(3NF)稍微放宽了这个约束，它允许左侧不是超码的某些非平凡函数依赖

具有函数依赖集$F$的关系模式$R$属于第三范式的条件是：
$$
对于F^+中所有形如 \alpha\to\beta 的函数依赖(其中 \alpha \sube R且 \beta\sube R ),以下至少一项成立: \\
\bullet \alpha\to\beta是一个平凡的函数依赖 \\
\bullet \alpha 是R的一个超码 \\
\bullet \beta -\alpha 中的每个属性A都包含于R的一个候选码中
$$
3NF的定义允许某些BCNF中不允许的函数依赖

再次考虑联系集dept_advisor,它具有函数依赖：
$$
i\_id \to dept\_name \\
s\_id ,dept\_name \to i\_id
$$
其中$i\_id \to dept\_name$函数依赖虽然不满足BCNF范式，但满足了第三范式

# 函数依赖理论

作为检查模式是否属于BCNF或者3NF这一过程的一部分，能过对函数依赖进行系统地推理是很有用的

## 函数依赖集的闭包

给定关系模式$r(R)$,如果$r(R)$的每个满足$F$的实例也满足$f$，则$R$上的函数依赖$f$被$r$上的函数依赖集$F$逻辑蕴涵

例如假设给定给关系模式$r(A,B,C,D)$及其函数依赖集:
$$
A \to B \\
B \to C \\
C \to D 
$$
那么函数依赖$A\to D$被逻辑蕴涵

令$F$为一个函数依赖集。$F$的闭包是被$F$逻辑蕴涵的所有函数依赖的集合，记作$F^+$

给定$F$，可以由函数依赖的形式化定义计算出$F^+$。如果$F$很大，则这个过程将会很长并且很难

我们可以使用以下三条公理去寻找逻辑蕴涵的函数依赖。通过反复应用这些规则，可以找出给定$F$的全部的$F^+$，这被称为Armstrong公里：
$$
\begin{flalign}
\begin{split}
 &\bullet \ 自反律：若\alpha 为一属性集且 \beta \sube \alpha ，则 \alpha \to \beta  \\
&\bullet \ 增补律：若\alpha \to \beta 成立且 \gamma 为一属性集，则 \gamma\alpha\to \gamma\beta \\
&\bullet \ 传递律：若 \alpha \to \beta 和 \beta \to \gamma 成立，则 \alpha \to \gamma 成立 \\
\end{split}&
\end{flalign}
$$
虽然Armstrong公理是完备的，但是直接用它们计算$F^+$会很麻烦。我们可以使用公理推出的其他命题进行计算：
$$
\begin{flalign}
\begin{split}
 &\bullet \ 合并律：若\alpha \to \beta 和 \alpha \to \gamma 成立，则 \alpha \to \beta\gamma 成立  \\
&\bullet \ 分解律：若\alpha \to \beta \gamma 成立,则 \alpha \to \beta 和\alpha \to \gamma 成立 \\
&\bullet \ 伪传递律：若 \alpha\to \beta 和 \gamma\beta\to\delta 成立，则 \alpha\gamma\to\delta成立  \\
\end{split}&
\end{flalign}
$$
我们通过下面流程使用Armstrong公理计算$F^+$：
$$
\begin{flalign}
\begin{split}
 &F^+ = F\\
 &\qquad repeat \\
 &\qquad\qquad for\ each \ F^+ 中的函数依赖f \\
 &\qquad\qquad\qquad 在f上应用自反率和增补律，将结果加入到F^+中 \\
 &\qquad\qquad for\ each \ F^+ 中的一对函数依赖f_1和f_2 \\
 &\qquad\qquad\qquad if \ f_1和f_2可以使用传递律结合起来 \\
 &\qquad\qquad\qquad\qquad 将结果加入到F^+中 \\
 &\qquad  F^+不再发生变化
\end{split}&
\end{flalign}
$$

## 属性集的闭包

如果$\alpha\to\beta$我们称$B$被$\alpha$函数确定。要判断集合$\alpha$是否为超码，我们必须设计一个算法，用于计算被$\alpha$ 函数确定的属性集。一个方法是计算$F^+$，找出所有左半部为$\alpha$的函数依赖，并合并这些函数依赖的右半部。但这样做开销很大，因为$F^+$可能很大

另$\alpha$是一个属性集。我们将函数依赖集$F$下被$\alpha$函数确定的所有属性的集合称为$F$下$\alpha$的闭包



