# 关系数据库设计概述

关系数据库设计的目的是生成一组关系模式，使存储信息时避免不必要的冗余，同时让我们更方便高效地获取信息。这是通过设计满足适当范式的模式来实现的。

我们首先来探讨什么样的模式设计是更合适的。

例如大学中部门实体集和导师实体集对应的关系模式：

~~~sql
instructor(ID,name,dept_name,salary);
department(dept_name,building,budget);
~~~

## 更大的模式

考虑用更大的模式来替代insructor和department模式：

~~~sql
inst_dept(ID,name,salary,dept_name,building,budget);
~~~

使用这个更大的模式，在进行某些查询的时候可以用哪个更少的连接来表达。但是，这是以信息的冗余为代价的：一个系中的所有教师都不得不重复一遍系信息building和budget。并且这些所在建筑和预算信息必须相同。否则数据库将不一致。

即使我们容许冗余的问题。inst_dept模式仍然存在其他问题：如果我们在大学里创建一个新的系。使用inst_dept使我们无法直接表达关于一个系的信息，除非该系在学校中至少有一位教师。

## 更小的模式

我们从inst_dept模式开始。我们已经知道了它是一个坏的模式设计，那在此之前我们又该如何发现它有信息重复并且需要分解成instructor和department两个模式呢？

我们可以通过观察发现每个与系关联的见识都需要列一遍办公楼和预算所导致的信息重复。但是这是一个不可靠的方式。一个真实的数据库拥有大量模式以及数量更多的属性。我们没办法通过一个一个观察来发现是否有信息重复。并且我们没办法确认这种观察到的重复是否只是一种偶然。除非我们了解模式对应在现实中的实体的规则。

为了能够精确的发现信息重复，我们需要一条规则，那就是**函数依赖**：如果存在模式A，A有属性a，则a可以作为主码

例如如果存在模式(dept_name,budget)，则是dept_name可以作为主码。

通过这样的规则，我们就能够发现信息重复，由于dept_name在inst_dept中不是主码，所以budget就有可能重复。

通过函数依赖，可以让数据库设计者发现一个模式应拆分或者分解为两个或者多个模式

但不是所有的分解都是有益的。有些分解会让模式无法真正区分实体，或者表达实体的重要信息。这样的分解就是有损分解。反之则称为无损分解

# 原子域和第一范式

在关系模式中，一个域是原子的，即该域的元素被认为是不可分的单元。

如果R的所有属性的域都是原子的，那么我们称关系模式R属于第一范式(First Normal Form,1NF)

而一个域是否是原子的，取决于在数据库中我们如何使用域元素。

如果我们认为整数是原子的，那么整数的集合就是一个原子域，但是如果我们认为整数是一列有序的数字，那么这样的整数的集合就是非原子的。

有时候非原子域的组合值属性常常很有用，在包含复杂结构的实体域中，强制使用第一范式会给程序员造成不必要的负担：必须编写代码将数据转换为原子形式。从原子形态来回转换数据也会在运行时造成额外开销。

所以在这样的域中支持非原子的值是很有用的。

# 使用函数依赖进行分解

前面提到了基于码和函数依赖来判断一个关系模式是否应该分解。我们继续用符号语言深入学习这些内容

* 一般情况下，用希腊字母表示属性集合(例如$\alpha$).

* 用一个小写的罗马字母后面跟着一对圆括号括住的大写字母来指关系模式，例如$r(R)$，其中$r$表示关系，$R$表示属性集。如果我们不关注关系的名称时，可以简化为只用$R$

  当然，一个关系模式一定是一个属性集，但并非所有的属性集都是模式。

* 当属性集是一个超码时，用$K$表示

## 码和函数依赖

一个关系的满足所有现实世界约束的实例，称为关系的合法实例；一个数据库实例中所有关系实例都是合法实例，这样的数据库实例称为数据库的合法实例。

我们用符号语言重新定义超码：

令$r(R)$是一个关系模式。$R$的子集$K$是$r(R)$的超码的条件是：
$$
在关系r(R)的任何合法实例中，对于r的实例中的任意元组t_1和t_2，满足若t_1 \neq t_2  则 t_1[K] \neq t_2[K] \\ 即在关系r(R)的任意合法实例中没有两条元组在属性集K上存在相同的值。\\ 这样在r中的一个K值唯一标识一条元组
$$
超码时能够唯一标识整条元组的属性集，函数依赖让我们可以表达唯一标识某些属性的值的约束。

考虑一个关系模式$r(R)$，令$\alpha \subseteq R 且 \beta \subseteq R$

* 给定$r(R)$的一个实例，这个实例满足函数
