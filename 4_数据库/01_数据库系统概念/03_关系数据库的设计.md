# 关系数据库设计概述

关系数据库设计的目的是生成一组关系模式，使存储信息时避免不必要的冗余，同时让我们更方便高效地获取信息。这是通过设计满足适当范式的模式来实现的。

我们首先来探讨什么样的模式设计是更合适的。

例如大学中部门实体集和导师实体集对应的关系模式：

~~~sql
instructor(ID,name,dept_name,salary);
department(dept_name,building,budget);
~~~

## 更大的模式

考虑用更大的模式来替代insructor和department模式：

~~~sql
inst_dept(ID,name,salary,dept_name,building,budget);
~~~

使用这个更大的模式，在进行某些查询的时候可以用哪个更少的连接来表达。但是，这是以信息的冗余为代价的：一个系中的所有教师都不得不重复一遍系信息building和budget。并且这些所在建筑和预算信息必须相同。否则数据库将不一致。

即使我们容许冗余的问题。inst_dept模式仍然存在其他问题：如果我们在大学里创建一个新的系。使用inst_dept使我们无法直接表达关于一个系的信息，除非该系在学校中至少有一位教师。

## 更小的模式

我们从inst_dept模式开始。我们已经知道了它是一个坏的模式设计，那在此之前我们又该如何发现它有信息重复并且需要分解成instructor和department两个模式呢？

我们可以通过观察发现每个与系关联的见识都需要列一遍办公楼和预算所导致的信息重复。但是这是一个不可靠的方式。一个真实的数据库拥有大量模式以及数量更多的属性。我们没办法通过一个一个观察来发现是否有信息重复。并且我们没办法确认这种观察到的重复是否只是一种偶然。除非我们了解模式对应在现实中的实体的规则。

为了能够精确的发现信息重复，我们需要一条规则，那就是**函数依赖**：如果存在模式A，A有属性a，则a可以作为主码

例如如果存在模式(dept_name,budget)，则是dept_name可以作为主码。

通过这样的规则，我们就能够发现信息重复，由于dept_name在inst_dept中不是主码，所以budget就有可能重复。

通过函数依赖，可以让数据库设计者发现一个模式应拆分或者分解为两个或者多个模式

但不是所有的分解都是有益的。有些分解会让模式无法真正区分实体，或者表达实体的重要信息。这样的分解就是有损分解。反之则称为无损分解

# 原子域和第一范式

在关系模式中，一个域是原子的，即该域的元素被认为是不可分的单元。

如果R的所有属性的域都是原子的，那么我们称关系模式R属于第一范式(First Normal Form,1NF)

而一个域是否是原子的，取决于在数据库中我们如何使用域元素。

如果我们认为整数是原子的，那么整数的集合就是一个原子域，但是如果我们认为整数是一列有序的数字，那么这样的整数的集合就是非原子的。

有时候非原子域的组合值属性常常很有用，在包含复杂结构的实体域中，强制使用第一范式会给程序员造成不必要的负担：必须编写代码将数据转换为原子形式。从原子形态来回转换数据也会在运行时造成额外开销。

所以在这样的域中支持非原子的值是很有用的。

# 使用函数依赖进行分解

