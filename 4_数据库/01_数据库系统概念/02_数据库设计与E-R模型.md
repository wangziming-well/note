# 实体-联系模型

实体-联系(entity-relationship,E-R)数据模型的提出使为了方便数据库的设计

E-R数据模型采用了三个基本概念：实体集、联系集和属性。

## 实体集

实体使现实世界中可区别于其他对象的一个事物或对象

实体集使相同类型的一个实体集合

实体通过一组属性来表示，属性使实体机中哦每个成员所拥有的描述性性质。

每个实体的每个属性都有一个值

## 联系集

**联系**是指多个实体间的相互关联。例如一个员工属于一个部门

**联系集**是相同类型联系的集合。确切的说，联系集是$n \ge 2$个实体集上的数学关系。如果$E_1,E_2,...,E_n$为实体集，则联系集$R$是：
$$
\{(e_1,e_2,...,e_n) | e_1 \in E_1,e_2 \in E_2,...,e_n \in E_n  \}
$$
的一个子集，而$(e_1,e_2,...,e_n)$是一个联系

例如一个实体集student,包含(A,B,C,D).一个实体集class包含(classA,classB),那么它们之间可以有联系集
$$
\{(A,classA) ,(B,classA),(C,classB),(D,classB) \}
$$
表示A，B在classA班，C，D在classB班

实体集之间的关联称为**参与**，也就是说实体集$E_1,E_2,...,E_n$参与联系集$R$.

E-R模式中的一个**联系实例**表示在所建模的显示时间中命名实体间的一个关联。

实体在联系中扮演的功能称为实体的**角色**。由于参与一个联系集的实体集通常是互异的，因此角色是隐含的并且一般并不指定。当联系的含义需要解释时角色是很有用的。

同样的实体集以不同的角色参与一个联系集多于一次，这样的联系集称为**自环的联系集**

在自环的联系集中，有必要使用显示的角色名来指明实体是如何参与联系实例的。

联系可以具有**描述性属性**，例如对于导师和学生之间的联系，可以将属性date与该联系关联起来，以表示教师称为学生导师的日期。

相同的实体集可能会参与到多个联系集中。

联系集一般是二元的，即涉及两个实体集的联系集。但有时联系集会涉及多于两个实体集。参与联系集的实体集的数目恒伟联系集的度。

## 属性

每个属性都有一个可取值的集合，称为该属性的域，或者值集。

实体集的属性是将实体集映射到域的函数。每个实体可以用一组(属性，值)来表示

E-R模型中的属性可以按照如下的属性类型进行划分：

* 简单和复合属性：简单属性是不能再划分为更小的部分的属性，而复合属性可以再次划分
* 单值和多值属性：如果一个属性对应一个值，就为单值属性；如果一个属性对应多个值，就为多值属性。特定情况下，可以对多值属性的值个数设置上下界

# 约束

E-R模式可以定义一些数据库中的数据必须满足的约束

## 映射基数

**映射基数**(mapping cardinality)，或者说基数比率，表示一个实体通过一个联系集能关联的实体的个数

映射基数在描述二元联系集时很有用，尽管它可以用于描述多元联系集。但我们只讨论二元联系集

对于实体集A和B之间的二元联系集R来说，映射基数必然是下面情况之一：

* 一对一：A中的一个实体至多与B中的一个实体相关联，并且B中的一个实体也至多与A中的一个实体相关联
* 一对多：A中的一个实体可以与B中的任意数目实体相关联，而B中的一个实体至多与A中的一个实体相关联
* 多对一：A中的一个实体至多与B中的一个实体相关联，B中的一个实体可以与A中任意数目实体相关联
* 多对多A中的一个实体可以与B中的任意数目实体相关联，B中的一个实体可以与A中任意数目实体相关联

一个特定联系集的适当的映射基数依赖于该联系集所建模的现实世界的情况

## 参与约束

如果实体集E中的每个实体都参与到联系集R的至少一个联系中，实体集E在联系集R中的参与称为全部的。如果E中只有部分实体参与到R的联系中，实体集R到联系集R的参与称为部分的。

## 码

在概念上来说，各个实体是互异的，但从数据库的观点来看，它们的区别必须通过其属性来表明。

因此，一个实体的属性的值必须可以唯一标识该实体。

关系模式中码的概念直接适用于实体集。即实体的码是一个足以区分每个实体的属性集。关系模式中的超码、候选码、主码的概念同样适用于实体集。

码同样用于唯一地标识联系，从而将联系互相区分开。

设R是一个涉及实体集$E_1,E_2,...,E_n$的联系集。设主码$(E_i)$代表构成实体集$E_i$的主码的属性集合。联系集主码的构成依赖于同联系集$R$相关联的属性集合：

如果联系集$R$有属性$a_1,a_2,...,a_n$与之关联，那么属性集合：
$$
primary-key(E_1)\cup primary-key(E_2)\cup ...\cup primary-key(E_n) \cup \{a_1,a2,...,a_n \}
$$
描述集合R中的一个联系，其中，属性集合：
$$
primary-key(E_1)\cup primary-key(E_2)\cup ...\cup primary-key(E_n)
$$
构成联系集的一个超码

联系集的主码结构依赖于联系集的映射基数。例如考虑实体集student和teacher和其联系集advisor。

* 如果联系是多对多的，那么advisor的主码由student和teacher的主码的并集构成
* 如果联系是多对一的，那么advisor的主码由teacher的主码构成
* 如果联系是一对一的，主码可以是teacher或者student的主码中的一个

# 实体-联系图

E-R图(E-R diagram)可以图形化表示数据库的全局逻辑结构。

## 基本结构

E-R图包括如下几个主要构件：

* 分成两部分的矩阵代表实体集。上半部分表示实体集的名字，下半部分表示实体集中所有属性的名字
* 菱形代表联系集
* 未分割的矩形代表联系集的属性。构成主码的属性以下划线标明
* 线段将实体集连接到联系集
* 虚线将联系集属性连接到联系集
* 双线显示实体在联系集中的参与度
* 双菱形代表到弱实体集的标志性联系集

例如如下E-R图：

![E-Rdemo1](https://gitee.com/wangziming707/note-pic/raw/master/img/E-Rdemo1.png)

表示通过二元联系集advisor关联的两个实体集instructor和student，并且该联系集advisor有描述性属性date

## 映射基数

实体集之间的联系可以是一对一、一对多、多对一和多对多的。可以通过实体集和联系集之间的箭头区分这些区别：

* 一对一：

  ![1for1E-R](https://gitee.com/wangziming707/note-pic/raw/master/img/1for1E-R.png)

* 一对多：

  ![1forNE-R](https://gitee.com/wangziming707/note-pic/raw/master/img/1forNE-R.png)

* 多对多：

  ![NforME-R](https://gitee.com/wangziming707/note-pic/raw/master/img/NforME-R.png)

E-R图还提供了一种描述每个实体参与联系找那个的联系的次数的更复杂的约束的方法：实体集和二元联系集之间的一条边可以有一个关联的最大和最小的映射基数，用`l...h`的形式表示，其中`l`表示最小的映射基数，而`h`表示最大的映射基数。

最小值为1表示这个实体集在该联系集中全部参与，即实体集中每个实体在联系集中至少一个联系

最大值为1表示这个实体参与至多1个联系

最大值为`*`表示没有限制

例如：

![MappingCardinalitiesConstraintE-R](https://gitee.com/wangziming707/note-pic/raw/master/img/MappingCardinalitiesConstraintE-R.png)

表示每个教师可以有0个或者无限多个学生

而每个学生必须有且只能有1个导师

## 复杂的属性

对于复合属性，可以使用缩进表示一个复合属性的子属性，如图：

![ComplexPropertyE-R](https://gitee.com/wangziming707/note-pic/raw/master/img/ComplexPropertyE-R.png)

## 角色

在E-R图中，我们通过在菱形和矩阵之间的连线上进行标注来表示角色，表示实体参与联系时的角色。

之前我们已经讨论过了，在自环联系集中，角色是很有必要的，例如：

![roleE-R](https://gitee.com/wangziming707/note-pic/raw/master/img/roleE-R.png)

表示课程间的 前置关系

## 非二元的联系集

非二元的联系集也可以在E-R图中简单的表示。如：

![multi-relationalE-R](https://gitee.com/wangziming707/note-pic/raw/master/img/multi-relationalE-R.png)

表示项目、导师和学生之间的联系

在非二元的联系集中，可以表示某些类型的多对一联系。如果一个学生在一个项目上最多只能有一个导师。那么这种约束可以用从proj_guide指向instructor的箭头表示

但是一个联系集至多允许一个箭头，因为在一个非二元的联系集外包含两个或者更多箭头的E-R图可以用两种方法解释：

假设实体集$A_1,A_2,...,A_n$之间有联系集$R$,并且只有指向实体集$A_{i+1},A_{i+1},...,A_n$的边是箭头，那么有两种解释：

* 来自$A_i,A_2,...,A_i$的实体的一个特定的组合可以和至多一个来自$A_{i+1},A_{i+1},...,A_n$的实体组合相关联
* 对每个实体集$A_k$ 其中`i <k<= n`，来自其他实体集的实体的每个组合可以和来自$A_k$的至多一个实体相关联。

这两种解释在只有一个箭头时是等价的。

## 弱实体集

考虑一个section实体，section(sec_id,semester,year,course_id).显然开课实体和课程实体相关联。假设我们在实体集section和course之间创建了一个联系集sec_course。

那么发现sec_course中的信息是冗余的，因为section已有属性course_id,它标识该开合所关联的课程。消除这种冗余的一种方法是删除联系sec_course;然而，这么做使得section和course之间的联系隐含于一个属性中，这不是很好的设计。

消除这种冗余的另外一个方法是删除section中的course_id属性。然而，这样的话实体集section(sec_id,semester,year)就没有足够的属性唯一标识一个指定的section实体。即使每个section实体都是唯一的，不同课程的开课也可能会有下水管南通的sec_id,year和semester。为了解决这个问题，我们将联系sec_course视为一个特殊的联系，它给唯一标识section实体提供额外信息，即course_id

像类似section实体集这种没有足够的属性以形成主码的实体集称为**弱实体集**，有主码的实体集称为**强实体集**。

弱实体集必须与另一个称作**标识**或**属主实体集**的实体集关联才能够有意义.

每个弱实体必须和一个标识实体关联；也就是说，弱实体集**存在依赖**于标识实体集。称标识实体集拥有它所标识的弱实体集。

将弱实体集于其标识实体集相联的联系集称为**标识性联系**

标识性联系是从弱实体集到标识实体集多对一的，并且弱实体集在联系中的参与是全部的。标识性联系集不应该有任何描述性属性，因为这种属性中的任意一个都可以于弱实体集相关联。

虽然弱实体集没有主码，但是我们仍需要区分依赖于特定强实体集的弱实体集中的实体的方法。弱实体集的**分辨符**是使我们进行这种区分的属性集合。例如弱实体集section的分辨符由sec_id、year和semester组成。弱实体集的分辨符也称为该实体集的**部分码**

弱实体集的主码由标识实体集的主码加上该弱实体集的分辨符构成。在section 的例子中，它的主码是{course_id,sec_id,year,semester},其中course_id是标识实体集course的主码

在E-R图中，弱实体集和强实体集类似，以矩形标识，但是有两点主要的区别：

* 弱实体集的分辨符以虚下划线标明，而不是实线
* 关联弱实体集和标识实体集的联系集以双菱形标识

例如:

![weakEntitySetE-R](https://gitee.com/wangziming707/note-pic/raw/master/img/weakEntitySetE-R.png)

表示弱实体集section通过联系集sec_course依赖于强实体集course

该图还使用双线表示全部参与：section在联系sec_course中的参与是全部参与。从sec_course指向course的箭头表示每个course只和一个section有联系。

# E-R模型转换为关系模式

在将企业数据逻辑抽象为E-R模型后，我们最终要将E-R模型转换为数据库的关系模型。

在数据库设计中，对于每个实体集以及对于每个联系集 ，都有唯一的关系模式与之对应。

我们要做的是用关系模式来表示E-R模式，并且将E-R设计中提出的约束映射到关系模式上的约束。

## 强实体集的表示

对于只具有简单描述性属性的强实体集，假设是E，其具有$a_1,a_2,...,a_n$属性。只需要用具有n个不同属性的模式E来表示这个实体集，该模式的关系中的每个元组用实体集E的一个实体相对应。

强实体集的主码就是对应模式的主码。

**复合属性**：

但处理具有复杂属性的实体集时，需要为每个子属性创建一个单独的属性，打死你不会为复合属性自身创建一个单独的属性。

例如instructor有复合属性name有子属性first_name,middle_initial和last_name。为instructor生成的模式包括first_name,middle_initial和last_name，但没有单独的属性或者模式表示name

**多值属性:**

多值属性的处理不同于其他属性，E-R模型中的多值属性映射到关系模式上是一个新的关系模式。

对于一个多值属性M，需要为其构建新关系模式R，该模式包含一个对应于M的属性A，以及对应于M所在的实体集或联系集的主码的属性

例如对实体集instructor的多值属性phone_number,instructor的主码是ID，需要为这个多值属性构建一个关系模式：instructor_phone(<u>ID</u>,<u>phone_number</u>)

如果ID为1的教师有两个电话号码，10000，10001，对应到这张表上就是两个元组(1,10000)和(1,10001)

创建的新关系模式的主码由模式中的所有属性组成。

另外需要在多值属性构建的关系模式上建立外码约束。例如instructor_phone关系上的外码约束时属性ID参照instructor关系

## 弱实体集的表示

设A时具有属性$a_1,a_2,...,a_m$的弱实体集，设B是A所依赖的强实体集，设B的主码包括属性$b_1,b_2,...,b_n$。我们用名为A的关系模式表示实体集A，该模式的每个属性对应下面集合中的一个成员：
$$
\{ a_1,a_2,...,a_m \} \cup \{  b_1,b_2,...,b_n \}
$$
对于从弱实体集转换而来的模式，该模式的主码由其所依赖的强实体集的主码与弱实体集的分辨符组合而成。除了创建主码外，还要再关系A上创建外码约束，该约束指明属性$b_1,b_2,...,b_n$参照关系B的主码。外码约束保证表示弱实体的每个元组都有一个表示相应强实体的元组与之对应。

## 联系集的表示

设$R$是联系集，设$a_1,a_2,...,a_m$表示所有参与E的实体集的主码的并集构成的属性集合，设$R$的描述性属性(如果有)为$b_1,b_2,...,b_n$。我们用名为R的关系模式表示该联系集，下面集合中的每一项表示为模式的一个属性：
$$
x\{ a_1,a_2,...,a_m \} \cup \{  b_1,b_2,...,b_n \}
$$
对于联系集对应关系的主码选择，有如下情况：

* 对于多对多的二元联系，参与实体集的主码属性的并集成为主码
* 对于一对一的二元联系，任何一个实体集的主码都可以作为主码
* 对于多对一/一对多的二元联系集，联系集中多的那一方的实体集的主码构成主码
* 对于没有箭头的n元联系集，所有参与实体集的主码属性的并集构成主码
* 对于有1个箭头的n元联系集，不在箭头侧的实体集的主码属性为模式的主码。

还需要再关系模式R上建立外码约束：对于每个与联系集R相关的实体集$E_i$,建立一个关系模式R上的外码约束，R中来自$E_i$主码属性的那些属性参照表示关系模式$E_i$的主码

### 标识性联系集模式的冗余

连接弱实体集和相应强实体集的联系集比较特殊。这样的联系集是多对一的，且没有描述属性。另外，弱实体集对应的关系模式的主码包含强实体集的主码了。

在如下联系中：

![weakEntitySetE-R](https://gitee.com/wangziming707/note-pic/raw/master/img/weakEntitySetE-R.png)

对应的section关系模式的属性是`{course_id,sec_id,semester,year}`

如果要构造联系集`sec_course`对应的关系模式，那么这个模式按照构造规则同样有属性`{course_id,sec_id,semester,year}`，

所以这个属性组合出现了两次。因此sec_course关系模式是冗余的。

一般情况下，连接弱实体集于其所依赖的强实体集的联系集的模式是冗余的。

### 模式的合并

考虑从实体集A到实体集B的一个多对一的联系集AB。得到对应的三个模式A、B和AB。

如果A在该联系中的参与是全部的；即实体集A中的每个实体a都必须参与到联系AB中。那么我们可以将A和AB模式合并单个包含两个模式所有属性的并集的模式。合并后模式的主码是其模式中融入了联系集模式的那个实体集的主码。

例如员工和部门的的实体和联系集对应的模式是：`staff(ID,name,age,salary)`和`department(ID,dept_name,location)`和`staff_dept(staff_id,dept_id)`

那么`staff`模式和`staff_dept`模式可以合并为：`staff(ID,name,age,salary,dept_id)`



