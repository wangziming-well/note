# 关系模型

在商用数据处理应用中，关系模型是主要的数据模型。它以其简易性简化了编程工作。

## 关系数据库的结构

关系数据库由表的集合构成，每个表有唯一的名字。一般来说，表中的一行代表了一组值之间的联系。一个表就是这种联系的集合，这也是关系数据模型名称的由来。

在关系模型中，**关系**(relation)用来代表表，**元组**(tuple)用来代指行，**属性**(attribute)代指表中的列。

**关系实例**(relation instance)这个术语来表示一个关系的特定实例，也就是所包含的一组特定的行。

关系是元组集合。所以元组在关系中出现的顺序是无关紧要的。即有相同元组的关系，即使元组的顺序不同，这样的关系+也是相同的。为了便于说明，当我们在显示关系时，大多数情况下都按其第一个属性排序。

对于关系的每个属性，都存在一个允许取值的集合，称为该属性的**域**(domain)

如果域中的元素被看做是不可再分的单元，则域是**原子的**

我们要求对所有关系r而言，r的所有属性的域都是原子的,比如一张教师表的phone属性存储的是一组电话号码，它们phone的域就不是原子的。

空(null)值是一个特殊的值，表示值未知或者不存在。

## 数据库模式

数据库有数据库模式(database schema)和数据库实例(database instance)的概念，前者是数据库的设计逻辑，后者是给定时刻数据库中数据的一个快照。就像类和对象的概念关系。

对应的，**关系模式**(relatin schema)是对关系的设计定义。

一般来说，关系模式由属性序列以及个属性对应域组成。

关系实例的概念对应程序设计语言中变量的概念。当关系被更新时，关系实例的内容也随时间发生了变化。而关系模式是不常变化的。

尽管关系模式和关系实例之间的区分，但是常常使用一个名字代指它们。比如teacher，指代模式，也指代实例。

## 码

一个元组的属性值必须能够唯一区分元组。即一个关系中没有两个元组在所有属性上的取值都相同。

**超码**(superkey)时一个或者多个属性的集合，这些属性的组合可以使我们在一个关系中唯一地表示一个元组。例如：一个person关系中，id属性足以将不同的人元组区分开来，因此id使一个超码。但name属性不是一个超码，因为几个人可能同名。

用符号语7、言可以表示为:
$$
设R表示关系r模式中的属性集合。 \\
R的一个子集K是r的一个超码 \Leftrightarrow \vee 两个r中的元组 t_1、t_2,若t_1 \ne t_2,则t_1.K \ne t_2.K
$$
显然。如果K是一个超码，那么K的任意超集也是超码。

如果一个超码的任意真子集都不是超码，这样的超码称为**候选码**(candidate key)

一个关系模式中可以有多个候选码，在一个关系`instructor(id,name,dept_name)`中，如果name和dept_name的组合足以区分该关系中的各个成员，那么$\{id\}$和$\{name,dept\_name\}$都是候选码。同时要注意$\{id,name\}$只是超码不是候选码

我们用**主码**(primary key)这个术语来代码被数据库设计者选中的，主要用来在一个关系中区分不同元组的候选码

码(主码、候选码和超码)是整个关系的一种性质，而不是单个元组的性质。关系中的任意两个不同的元组都不允许同时在码属性上具有相同的值。码的指定代码了被建模的事物在现实世界中的约束。

主码应该选择那些值从不或者极少变化的属性。比如一个人的地址就不应该作为主码的一部分。但身份证号码可以保证从不变化，可以作为主码。

习惯上把一个关系模式的主码属性列在其他属性前面。

一个关系模式$r_1$可能在它的属性中包括另一个关系模式$r_2$的主码。这个属性在$r_1$上称作参照$r_2$的**外码**(foreign key).关系$r_1$也称为外码依赖的参照关系(referencing relation),$r_2$叫做外码的被参照关系(referenced relation)

例如关系`instructor(id,name,dept_id)` 和关系`department(dept_id,dept_name,)`那么instuctor的属性dept_id就称为参照department的外码。因为dept_id是department的主码。所以在任意的数据库实例中，从instructor关系中任取一个元组，该元组的dept_id属性上的取值在department关系中有对应的元组

这种在参照关系中任意元组在特定属性上的取值必然等于在被参照关系中某个元组的在特定属性上的取值的约束，被称为**参照完整性约束**（referential integrity constraint)

## 关系查询语句

查询语句(query language)是用户用来从数据库中请求获取信息的语言。查询语言可以分为过程化的和非过程化的。

过程化语言(procedural language)中，用户知道系统对数据库执行一系列操作以计算出所需结果

非过程化语言(noprocedural language)中，用户只需描述所需的信息，而不是给出获取该信息的具体过程。

## 关系运算

所有的过程化关系查询语句都提供了一组运算，这些运算要么施加于单个关系上，要么施加于一对关系上。这些运算的结果总是单个的关系。这使得可以使用模块化的方式组合集中这样的运算。

特别是，由于关系查询的结果本身也是关系，所以关系运算可施加在查询结果上。

在不同的语言中，特定的关系运算的表示是不同的，但都符合下面描述的通用结构。

假设有关系`student(id,name,age,class_id)`，`class(class_id,class_name,numbers)`

最常用的关系运算是从单个关系中选出满足一些特定谓词的特殊元组。其结果是一个新关系，它是原始关系的一个子集。如从student关系中选出(age > 15)的元组。

另一个常用的运算是从一个关系中选出特定的属性(列)。其结果是一个只包含哪些被选择属性的新关系。例如只从student关系中选出id和name属性，而不列出age，class_id属性

连接运算可以通过下述方式来结合两个关系:把分别来自两个关系的元组对合并成单个元组。有几种不同的方式来对关系进行连接：

* 自然连接:从关系A中选择属性T1,从关系B中选择属性T2，如果A中的元组ati和B中的元组b在t2的取值是相同的，那么它们是匹配的。所有这样匹配的元组都会在连接结果中出现。通常来说，两个关系上的自然连接运算锁匹配的元组在两个关系共有的所有属性上取值相同。
* 笛卡尔积运算：从两个关系中合并元组，其结果包含所有来自连个关系元组的所有配对，不论它们的属性值是否匹配。

因为关系是集合，所以我们可以在关系上施加标准的集合运算。并运算在两个相似结构的表上执行集合并。

# SQL

商业性使用或者实验性使用的数据库查询语言有好几种，我们学习使用其中最为广泛使用的查询语句：SQL

SQL语言 有以下几个部分:

* 数据定义语言(Date-Definition Language DDL):提供定义关系模式、删除关系以及修改关系模式的命令
* 数据操纵语言(Data-Manipulation Language DML):提供从数据库找那个查询信息，并且从数据库中插入元组、删除元组、修改元组的能力
* 完整性(integrity):SQL DDL包括定义完整性约束的命令，保存在数据库中的数据必须满足所定义的完整性约束。破坏完整性约束的更新是不允许的。
* 视图定义(view definition)：SQL DDL 包括定义视图的命令
* 实物控制(transaction control):SQL包括定义事务的开始和结束的命令
* 嵌入式SQL和动态SQL：定义SQL语言如何嵌入到通用编程语言，如C++，Java中
* 授权(authorization): SQL DDL包括定义对关系和视图的访问权限的命令

## SQL数据定义

数据库中的关系集合必须由数据定义语言(DDL)指定给系统。SQL的DDL不仅能定义一组关系，还能定义每个关系的信息，包括：

* 每个关系的模式
* 每个属性的取值类型
* 完整性约束
* 每个关系维护的索引集合
* 每个关系的安全性和权限信息
* 每个关系在磁盘上的物理存储结构

现在我们只讨论基本模式定义和基本类型。对DDL其他特征的讨论放到后续进行

### 基本类型

SQL标准支持多种固有类型：

* `char(n)`固定长度的字符串，用户指定长度n。也可以使用全称character
* `varchar(n)`：可变长度的字符串，用户指定最大长度n，等价于全称character varying
* `int`：整数类型，等价于全称interger
* `smallint`短整数类型
* `numeric(p,d)`:定点数，精度由用户指定。这个数由p位数字(加上一个符号位),其中d位数字在小数点右边。例如`numeric(3,1)`可以精确存储44.5，但不能精确存储444.5或0.32的数
* `real,double precision`:浮点数和双精度浮点数
* `float(n)`：精度至少为n位的浮点数

每种类型都可能包含一个被称为空值的特殊值。空值表示一个空缺的值，该值可能存在但并不为人所知，也可能不存在。

char数据类型存放固定长度的字符串。例如属性A的类型是char(10)。如果为此属性存入字符串`Avi`那么该字符串后会追加7个空格来使其达到10个字符串长度。但如果属性B的类型是varchar(10).为其存入`Avi`不会增加空格。在比较两个`char`类型的值时，如果它们的长度不一致，在比较之前会自动在短值后面加上额外的空格已使它们的长度一致。

当比较一个`char`类型和一个`varchar`类型的时候，即使存储相同的值，它们也可能不相同。这取决于数据库的具体实现。

### 基本模式定义

我们用`create table`命令定义SQL关系。命令的通用形式是：

~~~sql
create table r( 
    A1  D1,
    A2  D2,
    ...,
    An  Dn,
    <完整性约束1>,
	...,
    <完整性约束n>
);
~~~

其中r是关系名，每个$A_i$是关系r模式中的一个属性名。$D_i$是属性$A_i$的域，也就是说$D_i$指定了属性$A_i$的类型以及可选的约束，用于限制所允许的$A_i$取值的集合。

SQL支持许多不同的完整性约束。我们讨论其中的几个：

* `primaryKey(A1 ,A2,...,An)`：声明属性(A1 ,A2,...,An)构成关系的主码。主码属性必须非空且唯一。也就是说没有一个元组在主码属性上取空值，关系中也没有两个元组在所有主码属性上取值相同。

  主码的声明是可选的，但是为每个关系指定一个主码通常更好

* `foreign key(A1,A2,...,An) references s`：声明表示关系中任意元组在属性(A1,A2,...,An)上的取值必须对应关系s中某元组在主码属性上的取值。

* `not null`：声明在该属性上不允许空值。

SQL禁止破坏完整性约束的任何数据库更新。

一个新创建的关系最初是空的，可以用`insert`命令将数据加载到关系中。可以使用`delete`命令从关系中删除元组。使用`drop talbe `命令从数据库中删除关于被去掉关系的所有信息。

使用`alert table`命令为已有关系增加/删除属性。关系中所有元组在新属性上的取值将被设为null

`alert table r add A D;`添加属性，`alert table r drop A`删除属性

## SQL查询的基本结构

SQL查询的基本结构由三个子句构成：`select`、`from`和`where `。

查询的输入是在`from`子句中列出的关系，在这些关系上进行`where`和`select`子句中指定的运算，然后产生一个关系作为结果

### 单关系查询

考虑在通过关系`student(id,name,age,class_id,score)`找到所有学生的姓名，可以通过下面SQL语句：

~~~sql
select name from student;
~~~

其结果是由属性名为name的单个属性构成的关系。

在关系模型的形式化数学定义中，关系是一个集合。重复的元组不会出现在关系中。因为去重重复相当耗时，所有SQL允许在关系以及SQL表达式结果中出现重复。

如果想要删除重复，可以在`select`后加入关键词`distinct`

~~~sql
select distinct name from student ;
~~~

select子句中还可带含有`+ - * /`运算符的算数表达式，运算对象可以是常数或者元组的属性，例如：

~~~sql
select age +3,score *1.1 from student;
~~~

where子句允许我们只选出那些在from子句的结果关系中满足特定谓词的元组。例如

~~~sql
select name from student where age > 15 and score > 60;
~~~

### 多关系查询

如果我们要通过关系`student(id,name,class_id)`和关系`class (class_id ,class_name, number)`找出每个学生对应的班级名称：

~~~sql
select student.name ,calss.class_name
from student,class
where student.class_id = class.class_id;
~~~

在多关系查询中，属性需要加上前缀以表示该属性属于哪个关系。

一个典型的SQL查询具有如下形式：

~~~sql
select A1,A2,...An
from r1,r2,...rm
where P;
~~~

如果不加where子句，上式其结果是r1,r2,…rm关系的笛卡尔积。这会出现大量重复的无用数据。所以通常要加上`where`子句中的谓词以过滤并选择有意义的元组。

一个SQL查询的含义可以理解为：

* 为`from`子句中列出的关系产生笛卡尔积
* 在上一步的结果上应用`where`子句中指定的谓词
* 在上一步结果中的每个元组，输出`select`子句中指定的属性或者表达式的结果

注意上述表述不是SQL语句真正的执行顺序，只是为了明晰一个SQL查询的结果应该是什么样的

### 自然连接

在上一节的查询实例中，需要从student ,class表中组合信息，匹配条件是需要student.class_id和 class.class_id。这是在两个关系中具有相同名称的所有属性。实际上这样的匹配条件是很常见的：from子句中的匹配条件在通常情况下需要再所有匹配名称的属性上相等。

为了简化这种通用情况，SQL支持自然连接的运算：

自然连接作用于两个关系，并产生一个关系作为结果。自然连接结果只保留那些在两个关系模式中都出现的所有同名属性上取值相同的元组对。

~~~sql
select student.name ,calss.class_name
from student,class
where student.class_id = class.class_id;
~~~

和

~~~sql
select student.name ,calss.class_name
from student natural join class;
~~~

查询产生相同的结果。

`student natural join class` 是一种二元运算，结果是一个关系。所以自然连接运算可以进行复合运算

注意自然连接会匹配两个关系中所有的同名属性，如果有不必要相等的属性。SQL提供了一种自然连接的构造形式，允许用户来指定需要哪些列相等：

~~~sql
select student.name ,calss.class_name
from student join class using (class_id);
~~~

## 附加的基本运算

SQL中还支持几种附加的基本运算

### 更名运算

SQL提供了一个重命名结果关系中属性的方法，使用如下的`as`子句：

~~~sql
old_name as new_name
~~~

`as`子句既可出现在`select`子句中，也可以出现在`from`子句中。如：

~~~sql
select s.name as student_name ,c.class_name as class_name
from student as s  ,class as c
where student.class_id = class.class_id;
~~~

as 也可以省略：

~~~sql
select s.name student_name ,c.class_name class_name
from student s  ,class c
where s.class_id = c.class_id;
~~~

通过重命名关系我们可以比较同一个关系中的元组的情况如希望写出查询：“找出满足下面条件的所有学生的姓名，他们的分数至少比2班级某一个学生的分数高”

~~~sql
select distinct T.name 
from student T ,student S
where T.score > S.score and S.class_id = 2;
~~~

在上述查询中，T和S可以被认为是student关系的两个拷贝，更准确的说是被声明为student关系的别名。

像这样被用来重命名关系的标识符在SQL标准中被称为相关名称(correlation name),或者表辨明

### 字符串运算

SQL使用一对单引号来标示字符串，例如`‘Alice’`，也可以用双引号来标示。

在SQL标准中，字符串上的相等运算是大小写敏感的，表达式`‘alice'='Alice'`是假的。但有些数据库中在匹配字符串时不区分大小写。

SQL还允许在字符串上有多种函数，例如串联，提取子串，计算字符串长度、大小写转换、去掉字符串前后的空格等等。不同数据库系统提供的字符串函数集是不同的。

在字符串上可以使用`like`操作符来实现模式匹配。我们可以使用两个特殊的字符来描述模式：

* `%`匹配任意子串
* `_`匹配单个字符

例如找出学生中名字以`A`开头的姓名：

~~~sql
select name from student where name like 'A%'
~~~

如果要在匹配模式中匹配具体的`%`和`_`字符，需要用转义字符来匹配:`\%`和`\_`

SQL允许使用`not like`比较运算符搜索不匹配想。

### select子句中的属性说明

星号`*`在select子句中表示所有的属性，可以查询`from`子句所表示关系的所有属性，如

~~~sql
select student.* from student, class where student.class_id = class.class_id;
~~~

### 排列元组的显示次序

SQL为用户提供了一些对关系中元组显示次序的控制。`order by`子句可以让查询结果中元组按照排序顺序显示。如：

~~~sql
select name from student where age > 15 order by name;
~~~

`order by`子句默认使用升序。可以用`desc`表示降序，或者`asc`表示升序。此外，排列可以在多个属性上进行。如：

~~~sql
select name ,age 
from student
where age > 15
order by name  desc, age asc;
~~~

### where子句谓词

SQL提供`between`比较运算符来说明一个值的区间范围，例如：

~~~sql
select name from student where age between 14 and 15;
~~~

这等价于：

~~~sql
select name from student where age >=14 and age <=15;
~~~

另外SQL允许用记号`(v1,v2,...,vn)`来表示一个n维元组。在元组上可以使用比较运算符，例如：

~~~sql
select name 
from student 
where (score ,age) >=(60,14);
~~~

等价于：

~~~sql
select name 
from student 
where score >=60  and age >=14;
~~~

## 集合运算

SQL作用在关系上的`union`、`intersect`和`except`运算对应于数学集合论中的并、交和差运算

例如下面两个关系分别表示年龄大于14的学生的集合和成绩小于80的学生的集合：

~~~sql
select id from student where age > 14;
select id from student where score < 80;
~~~

那么找出年龄大于14或者成绩小于80的学习，我们可以用：

~~~sql
(select * from student where age > 14)  union (select * from student where score < 80);
~~~

注意`union`的结果会自动去重，如果想要不去重，可以使用`union all `:

~~~sql
(select * from student where age > 14)  union all (select * from student where score < 80 );
~~~

找出年龄大于14并且成绩小于80的学生，我们可以使用：

~~~sql
(select * from student where age > 14)  intersect (select * from student where score < 80 );
~~~

同样的`intersect`结果自动去重，如果不想去重，可以使用`intersect all`

找出年龄大于14但成绩不小于89的学习，可以使用：

~~~sql
(select * from student where age > 14)  except (select * from student where score < 80 );
~~~

同样的`except`自动去重，如果不想去重，可以使用`except all`

## 空值

空值给关系运算带来了特殊的问题，包括算数运算、比较运算和集合运算：

如果算数表达式的任一输入为空，则哎算数表达式的结果为空

涉及控制的任何比较运算的结果视为unknown

谓词中的逻辑运算符可以处理unknown值：

~~~sql
true and unknown = unknown;
false and unknown = false;
unknown and unknown = unknown;
true or unknown = true;
false or unknown = false;
unknown or unknown = unknown;
not unknown = unknown;
~~~

如果`where`子句谓词对一个元素计算出`false`或者`unknown`那么该元组不能被加入到结果集中。

可以通过特殊的关键词`is null /is not null`来测试空值：

~~~sql
select name from instructor where salary is null;
~~~

有些sql还运行我们使用`is unknown / is not unknown`来测试一个表达式的结果是否为`unknown`

## 聚集函数

聚集函数是以值的一个集合为输入，返回单个值的函数。SQL提供了五个固有聚集函数：

* `avg`：平均值
* `min/max`：最小/大值
* `sum`：总和
* `count`：计数

`sum`和`avg`的输入必须是数字集，其他聚集函数还可作用在非数字类型的集合上，如字符串。

例如计算所有学生的平均分：

~~~sql
select avg(score) as avg_score from student;
~~~

统计班级的个数：

~~~sql
select count(distinct class_id) from student;
~~~

注意count函数不会统计null

如果想要统计整个元组的个数，可以使用`count(*)`

### 分组聚集

有时候我们不仅希望将聚集函数作用在单个元组集上，而且希望将其作用到一组元组上，SQL提供`group by`子句实现这个功能

`group by`子句中给出的一个或者多个属性是用来构造分组的，在`group by`子句中所有属性上取值相同的元组将被分到一个组中。

例如，计算并展示每个班级的平均分：

~~~sql
select avg(score) as avg_score,class_id from student group by class_id;
~~~

在使用`group by`子句进行分组时，需要保证出现在`select`子句中但没有被聚集的属性只能出现在`group by`子句中的那些属性。下面的查询将报错：

~~~sql
select avg(score) avg_score,name from student group by class_id;
~~~

### `having`子句

有时候需要对分组限定条件，而不是对单个元组。例如，我们需要找到平均分大于80的班级。该条件就不针对单个元组，而是针对`group by`子句构成的分组。可以使用`having`子句实现对分组的谓词判断，因为`having`子句是在形成分组后才起作用，所有可以使用聚集函数：

~~~sql
select avg(score) avg_score,class_id from student group by class_id having avg(score) > 80;
~~~

与`select`子句类似，任何出现在`having`子句中，但没有被聚集的属性必须出现在`group by`子句中，否则查询将报错。

包含聚集、`group by`和`having`子句的查询的SQL语句，其操作顺序如下：

* 根据`from`子句来计算出一个关系
* 根据`where`子句的谓词对上一步的结果进行过滤
* 通过`group by`子句对上一步结果进行分组
* 根据`having`子句的谓词对上一步结果的分组进行过滤
* `select`子句展示上一步结果中指定的属性

### 对特殊值的处理

除了`count(*)`外所有的聚集函数都忽略输入集合中的空值。如果输入集合的所有元素都是空值，那么`count`运算返回0，其他聚集函数返回一个空值。

有两个聚集函数`some()`和`every`可用来处理布尔值的集合：

* `some`:输入中有一个值为true，结果为true
* `every`：输入中有一个值为false，结果为false

## 嵌套子查询

子查询是嵌套在另一个查询中的`select-from-where`表达式。SQL查询语句的结果也是一个关系，当然可以将其放在另一个查询语句中进行关系的运算

### 集合成员资格

连接词`in/not in`判断元组是否是集合中的成员，集合是由`select`子句产生的一组值构成的

例如找出1班中分数大于60的学生。

~~~sql
select * 
from student 
where score > 60 
and id in (select id from student where class_id =1);
~~~

当然有更简洁的sql，这只是为了演示`in`的使用

`in/not in`也可用于枚举集合：

~~~sql
select * from student where name not in ('Alice','Bob')
~~~



### 集合的比较

考虑查询“找出满足下面条件的所有学生的姓名，他们的分数至少比2班级某一个学生的分数高”，之前我们通过别名进行查询：

~~~sql
select distinct T.name 
from student T ,student S
where T.score > S.score and S.class_id = 2;
~~~

SQL提供了`比较运算符 some`和`比较运算符 all`来进行单个值和集合运算之间的比较。

如`a some < A`表示如果A中的某个元素满足` a< A`则为真。`b <> all B`表示如果B中的所有元素都满足`b <> B`则为真

所以上述查询可以通过下面SQL：

~~~sql
select name 
from student 
where score > some ( select score from student where class_id =2 );
~~~

### 空关系测试

`exists/not exists`结构用于测试一个子查询的结果中是否存在元组，exists结构在作为参数的子查询非空时返回true

例如用`exists`来查询“找出满足下面条件的所有学生的姓名，他们的分数至少比2班级某一个学生的分数高”

~~~sql
select name 
from student S 
where exists(select * from student T where S.score >T.score and T.class_id = 2);
~~~

上述查询还揭示了SQL的一个特性，来自外层查询的一个相关名称可以用在`where`子句的子查询中。使用了外层查询相关名称的子查询就被称为相关子查询

### 重复元组测试

`unique/not unique`结构可以测试在一个子查询结果中是否存在重复元组。如果作为参数的子查询结果中没有重复的元组，`unique`结构将返回true

例如查询“找出所有在2009年最多开设一次的课程”：如：

~~~sql
select T.course_id
from course as T
where unique(select R.course_id from section as R where T.course_id = R.course_id and R.year = 2009);
~~~

### from子句中的子查询

from子句的参数需要是一个关系，而子查询的结果是关系，所有子查询可以直接嵌入到`from`子句中

例如“找出平均分数大于70分的那些班级的平均分”

可以使用分组来实现：

~~~sql
select class_id, avg_score
from (select T.class_id ,avg(T.score) avg_score from student T group by T.class_id) S
where avg_score > 70;
~~~

注意有的数据库要求from子句中的子查询必须要有别名

### with子句

with子句提供定义临时关系的方法，这个定义指对包含with子句的查询有效，例如：

~~~sql
with max_score(value) as (select max(score) from student)
select name from student,max_score where score = max_score.value;
~~~

首先一个临时关系`max_score`，它有一个属性`value`。其元组有后续的查询语句填充。然后后续利用`max_score`进行查询运算

### 标量子查询

如果子查询的结果只返回包含单个属性的单个元组。这样的子查询称为标量子查询

标量子查询允许出现在单个值允许出现的任何地方。即可以将标量子查询当成一个普通的值来使用

例如找到比平均年龄大的学生：

~~~sql
select * from student T where T.age > (select avg(S.age) from student S );
~~~

标量子查询可以出现在select、where和having子句中。

## 数据库的修改

SQL修改数据库语言还有删除、插入和修改

### 删除

删除语句如下：

~~~sql
delete from r where P;
~~~

其中P代表一个谓词，r代表一个关系，delete语句首先从r中找到所有使`P(t)`为真的元组t，然后把它们从r中删除。如果省略`where`子句，则r中所有元组都将被删除

### 插入

插入语句如下：

~~~sql
insert into r(A1,A2,...,An) values (v1,v2,...,vn);
~~~

其中`(A1,A2,...,An) `是关系r属性集合的子集。插入时没有指定的属性，其值将被置为空。

如果插入时指定了所有的属性，那么`(A1,A2,...,An)`可以省略：

~~~sql
insert into r values (v1,v2,...,vn);
~~~

注意` (v1,v2,...,vn)`即可以是显示直接定义的元组，也可以是从查询语句中获取的多个元组集合如：

~~~sql
insert into instructor
(select Id,name,dept_name,18000 from student where dept_name='Music');
~~~

### 更新

使用update对关系中的指定元组的指定属性进行更新。

例如要让所有教师工资增长5%，可以使用：

~~~sql
update instructor set salary = salary *1.05;
~~~

要让对工资低于平均数的教师涨5%的工资，可以使用：

~~~sql
update instructor set salary = salary *1.05 where salary < (select avg(salary) from instructor);
~~~

SQL提供case结构，可以利用它在一条update语句中执行两种更新，避免更新次序引发的问题：

~~~sql
update instructor
set salary = case 
	when salary <=10000 then salary*1.05;
	else salary *1.03;
end;
~~~

case的一般格式如下：

~~~sql
case
	when pred1 then result1
	when pred2 then result2
	...
	when predn then resultn
	else result0
end	
~~~

