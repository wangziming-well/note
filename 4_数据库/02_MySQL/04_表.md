# 索引组织表

在InnoDB中，表都是根据主键顺序组织存放的，这种存储方式的表称为索引组织表(index organized table).

在InnoDB中，每张表都有主键，如果创建表时没有显示地定义主键，则InnoDB会按照如下方式创建或选择主键：

* 判断表中是否有非空的唯一索引(Unique NOT NULL)，如果有，则该列即为主键
* 如果没有，InnoDB自动创建一个6字节大小的指针

当表中有多个非空唯一索引时，InnoDB选择建表时的第一个定义的非空唯一索引作为主键。

# InnoDB逻辑存储结构

从InnoDB的逻辑存储结构来看，所有数据都被逻辑地放到一个空间中，称之为表空间(tablespace)。表空间又由段(segment)、区(extent)、页(page)组成。页有时也被称为块(block),其结构如图所示：

![InnoDBLogicalStorageStructure](https://gitee.com/wangziming707/note-pic/raw/master/img/InnoDBLogicalStorageStructure.png)

## 表空间

表空间可以看作时InnoDB逻辑结构的最高层，所有数据都存放在表空间中。在介绍InnoDB文件时已经介绍过默认情况下InnoDB有一个共享表空间ibdata1，即所有数据都存放在这个表空间内。如果用户启用了`innodb_file_per_table`，则每张表内的数据可以单独存放到一个表空间。

如果启用了`innodb_file_per_table`的参数，那么每张表单独的表空间内只存放数据、索引、和插入缓冲Bitmap页；其他的数据，如回滚信息，插入缓冲索引页、系统事务信息，二次写缓冲等还是存放在原来的共享表空间。所以即使启用了该参数，共享表空间还是会不断地增大。

## 段

表空间是由各个段组成的，常见的段由数据段、索引段、回滚段等。

因为InnoDB表是索引组织的，所以数据就是索引，索引就是数据。那么数据段即为B+数的叶子节点，索引段就是B+数的非叶子节点。

回滚段比较特殊，后续再单独介绍。

InnoDB对段的管理是由引擎自身所完成的，不能也没有必要手动控制。

## 区

区是由连续页组成的空间，在任何情况下每个区的大小都为1MB。为了保证区中页的连续性，InnoDB一次会从磁盘申请4到5个区。

在默认情况下，InnoDB页的大小为16KB，即一个区共有64个连续的页。

InnoDB1.0.x版本开始引入压缩页，即每个页的大小可以通过参数`key_block_size`设置为2k、4k、8k，因此每个区对应页的数量就是512、256、128

InnoDB1.2.x版本新增参数`innodb_page_size`，该参数可以将默认页的大小设置为4K，8K，但页中的数据不是压缩的。此时区中页的数量也为256、128.

总之，不论页的大小怎么变化，区的大小总为1M。

但用户启用了参数`innodb_file_per_table`后，创建的表的默认大小是96k。但是一个区就有1MB了，这是因为在每个段开始时，先用32个页大小的碎片页(fragment page)来存放数据，当使用完这些碎片页后，才会开始64个连续页的申请。这样对于一些小表、或者undo这类的段，可以在开始时申请较少的空间，节省磁盘容量开销。

## 页

页时InnoDB磁盘管理的最小单位。在InnoDB中，默认每个页的大小为16KB。从InnoDB1.2.x开始，可以通过参数`innodb_page_size`将页的大小设置为4K、8K、16K。设置完成后，则所有表中页的大小都为指定值，不可以再次对其修改。除非通过mysqldump导入和导出操作来产生新的库。

InnoDB中常见的页有：

* B-tree Node 数据页
* undo Log Page undo 页
* System Page 系统页
* Transaction system Page 事务数据页
* Insert Buffer Bitmap 插入缓冲位图页
* Insert Buffer Free List 插入缓冲空闲列表页
* Uncompressed BLOB Page 未压缩的二进制大对象页
* Compressed BLOB Page 压缩的二进制大对象页

## 行

InnoDB的数据是按照行进行存放的。每个页存放的行记录是有硬性定义的，最多存放16KB/2-200行的记录。

# InnoDB行记录格式

在InnoDB1.0.x版本之前，InnoDB提供了Compact和Redundant两种格式来存放行记录数据。

Compact是目前使用最多的一种格式，而Redundant格式是为了兼容之前的版本而保留的。

可以通过命令`show table status like 'table_name'`来查找指定表使用的行格式

## Compact行记录格式

Compact行记录格式是MySQL5.0中引入的，能高效地存储数据。一个页中存放的行数据越多，其性能就越高。下面是其格式图：

![Compact行记录格式](https://gitee.com/wangziming707/note-pic/raw/master/img/Compact%E8%A1%8C%E8%AE%B0%E5%BD%95%E6%A0%BC%E5%BC%8F.jpeg)

Compact行记录格式的首部是一个非NULL变长字段长度列表，并且是按照列的顺序逆序放置的，其长度为：

* 若列的长度小于255字节，用1字节表示
* 若大于255个字节，用2字节表示。

变长字段的长度最大不可以超过2字节，因为MySQL中VARCHAR类型的最大长度限制为65535

第二部分是NULL值列表，该位指示了该行数据中是否有NULL值，有则用1表示。该部分所占字节应该是1字节。

接下来是记录头信息(record header)，固定占用5字节，其每位含义如下：

记录头固定占用 5 个字节（40位），每位的含义见下表：

| 名 称        | 大小（bit） | 描 述                                                        |
| ------------ | ----------- | ------------------------------------------------------------ |
| （）         | 1           | 未知                                                         |
| （）         | 1           | 未知                                                         |
| dcleted_flag | 1           | 该行是否已被删除                                             |
| min_rcc_flag | 1           | 为1，如果该记录是预先被定义为最小的记录                      |
| n_owned      | 4           | 该记录拥有的记录数                                           |
| heap_no      | 13          | 索引堆中该条记录的排序记录                                   |
| recordtype   | 3           | 记录该行记录的类型，000表示普通，001表示B+树的结点指针，010表示Infimum，011表示Supremum,1xx表示保留 |
| next_record  | 16          | 页中下一条记录的相对位置（相对本记录的 rowid 地址）          |

最后的部分则是实际存储的每个列的数据。需要注意的是，NULL不占用该部分任何空间，即NULL除了占用NULL值列表，实际存储不占用任何空间。

还有一点是，除了用户定义的列外，还有两个隐藏列，事务ID列和回滚指针列，分别为6字节和7字节大小。若InnoDB表没有定义主键，且没有非空唯一索引，每行还会增加要给6字节的rowid列。

## Redundant行记录格式

Redundant是MySQL5.0版本之前InnoDB的行记录存储方式，5.0之后仍然支持它是为了兼容之前版本的页格式。Redundant行记录采用下面所示的方式存储：

![Redundant行记录格式](https://gitee.com/wangziming707/note-pic/raw/master/img/Redundant%E8%A1%8C%E8%AE%B0%E5%BD%95%E6%A0%BC%E5%BC%8F.jpeg)

Redundant行记录的首部同样是要给字段长度偏移列表，同样按照列的顺序逆序放置。若列的长度小于255，用1字节表示，若大于255字节，用2字节表示。

第二个部分为记录头信息，不同于Compact行记录格式，Redundant行记录格式的记录头占用6字节。具体含义如下

| 名 称            | 大小(bit) | 描 述                                      |
| ---------------- | --------- | ------------------------------------------ |
| （）             | 1         | 未知                                       |
| （）             | 1         | 未知                                       |
| deleted_flag     | 1         | 该行是否已被删除                           |
| min_rcc_flag     | 1         | 为1,如果该记录是预先被定义为最小的记录     |
| n_owned          | 4         | 该记录拥有的记录数                         |
| heap_no          | 13        | 索引堆中该条记录的索引号                   |
| n_fields         | 10        | 记录中列的数量                             |
| lbyte_offs__flag | 1         | 偏移列表为1字节还是2字节                   |
| next_record      | 16        | 页中下一条记录的相对位置（相对本页的地址） |

## 行溢出数据

InnoDB可以将一条记录中的某些数据存储在真正的数据页面之外。这样的数据称为行溢出数据。

一般认为BLOB、LOB这类的大对象列的存储会溢出页面。但是这个理解有偏差，BLOB可以不溢出，而VBARCHAR列数据类型页可能会溢出。

首先对varchar数据类型进行分析。MySQL数据库的varchar类型可以存放65535字节，但是当我们将一个varchar长度设置为65535时：

~~~sql
create table test1(
	a varchar(65535)
) charset=ascii ENGINE=InnoDB;
~~~

会得到下面错误信息：

~~~mysql
Row size too large. The maximum row size for the used table type, not counting BLOBs, is 65535. This includes storage overhead, check the manual. You have to change some columns to TEXT or BLOBs
~~~

从错误信息看，InnoDB不支持65535长度的varchar，因为还有别的存储开销。实际测试来看，varchar类型的最大长度是65532.那么，虾米那命令就不会报错了：

~~~mysql
create table test1(
	a varchar(65532)
) charset=ascii ENGINE=InnoDB;
~~~

要注意，表的字符集会影响varchar的最大长度。因为`varchar(N)`的N指的是字符长度，而ascii的一个字符就是一个字节，所以可以有65532的长度。

我们可以通过命令`show charset`查看支持的字符集，以及每个字符占用的字节，例如`gbk`字符集每个字符占用两个字节，那么用这个字符集建表，varchar的最长长度是32766(实际字节数是65532)

此外需要注意，MySQL官方手册中定义的65535长度是指表中所有VARCHAR列的长度总和，如果列的长度综合超过了这个长度，仍然无法创建：

~~~mysql
create table test(
	a varchar(22000),
	b varchar(22000),
	c varchar(22000)
) charset=ascii ENGINE=InnoDB;
~~~

允许上述命令将报错：

~~~mysql
Row size too large. The maximum row size for the used table type, not counting BLOBs, is 65535. This includes storage overhead, check the manual. You have to change some columns to TEXT or BLOBs
~~~

到此，我们知道了varchar最多能存储65535个字节，但是InnoDB的页为16K，即16384字节，也存放不了这么多的数据。

因此，一般情况下，InnoDB的数据存放在B-tree node页中，当发生行溢出时，数据存放在Uncompress BLOB页中。

对于行溢出数据，其存放采用如下方式：

![行溢出数据存放方式](https://gitee.com/wangziming707/note-pic/raw/master/img/%E8%A1%8C%E6%BA%A2%E5%87%BA%E6%95%B0%E6%8D%AE%E5%AD%98%E6%94%BE%E6%96%B9%E5%BC%8F.png)

也就是行记录会先存储一部分过长的数据，剩余的部分才会继续存储在BLOB Page中。

至于多长开始会发生行溢出，需要考虑到：InnoDB表是索引组织的，即B+Tree的结构，这样每个页中至少应该有两条记录(否则就失去了B+Tree的意义，变成链表了).因此，如果页中只能存放一条数据，那么InnoDB存储引擎会自动将行数据存放到溢出页中。

对于TEXT和BLOB类型的数据也是一样的，它们不总是存放在  Uncompressed BLOB Page中，只有数据过大发生行溢出时，才会如此。否则，如果TEXT和BLOB中的数据能够保证一个页能存放两条记录，那么也不会发生行溢出。

## Compressed 和Dynamic行记录格式

InnoDB1.0.x版本开始引入了新的文件格式，以前支持的Compact和Redundant格式称为Antelope文件格式，新的文件格式称为Barracuda文件格式。Barracuda文件格式下拥有两种新的行记录格式：Compressed 和Dynamic

新的两种记录格式对于存放在BLOB的数据采用了完全的行溢出的方式。如图：

![Barracuda溢出行](https://gitee.com/wangziming707/note-pic/raw/master/img/Barracuda%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E7%9A%84%E6%BA%A2%E5%87%BA%E8%A1%8C.png)

即行内只存放指针，实际的所有数据都存放在Off Page 中，而之前的Compact和Redundant格式会在行内存储768个前缀字节。

Compressed行记录格式中的行数据会以zlib的算法进行压缩。因此对大长度类型的数据能进行有效的存储

## char的行存储结构

char是存储固定长度的字符类型。

和varchar一样，`char(N)`中的N表示的是字符长度，而不是字节长度。也就是说，在不同的字符集下，同一个`char(n)`存储的数据长度也不同。

例如同样是`char(2)`，在gbk字符集下，存入`ab`只占两个字节，但存储`你好`需要4个字节，虽然它们都是2个字符长度。

所以对于多字节的字符编码，char类型不再代表固定长度的字符串了。InnoDB将其视为变长字符类型。这意味着在变成长度列表中会记录char数据类型的长度。

# InnoDB数据页结构

通过前面的介绍，我们已经知道InnoDB中页是最小存储单位，B-tree Node页存放的即是表中行的实际数据。接下来我们会详细介绍InnoDB数据页的内部存储结构。

InnoDB数据页由下面七个部分组成：

* File Header 文件头
* Page Header 页头
* Infimun 和 Supremum Records
* User Records (用户记录，即行记录)
* Free Space 空闲空间
* Page Directory 页目录
* File Trailer 文件结尾信息

结构如下：

![InnoDB数据页机构](https://gitee.com/wangziming707/note-pic/raw/master/img/InnoDB%E6%95%B0%E6%8D%AE%E9%A1%B5%E6%9C%BA%E6%9E%84.png)

## File Header

File Header用来记录页的一些头信息，由8个部分组成，共占用38个字节，具体如下：

| 名称                             | 大小(字节) | 作用                                                         |
| -------------------------------- | ---------- | ------------------------------------------------------------ |
| FIL_PAGE_SPACE_OR_CHKSUM         | 4          | 页的校验或checksum值                                         |
| FIL_PAGE_OFFSET                  | 4          | 表空间中页的偏移量。                                         |
| FIL_PAGE_PREV                    | 4          | 上一页的页号(B+树的特性要求其叶子节点必须是双向链表)         |
| FIL_PAGE_NEXT                    | 4          | 下一页的页号(B+树的特性要求其叶子节点必须是双向链表)         |
| FIL_PAGE_LSN                     | 8          | 该页被最后修改后对应日志序列位置(Log Sequence Number)        |
| FIL_PAGE_TYPE                    | 2B         | 页的类型，常见类型见下一个表。0x45BF代表数据页。             |
| FIL_PAGE_FILE_FLUSH_LSN          | 8B         | 仅在系统表空间的一个页中定义，代表文件至少被刷新到了对应的LSN值。对于独立表空间，该值都为0 |
| FIL_PAGE_ARCH_LOG_NO_OR_SPACE_ID | 4B         | 页属于哪个表空间                                             |

页的类型：

| 名称                    | 十六进制 | 解释                  |
| ----------------------- | -------- | --------------------- |
| FIL_PAGE_INDEX          | 0x45BF   | B+树叶节点            |
| FIL_PAGE_UNDO_LOG       | 0x0002   | undo log页            |
| FIL_PAGE_INODE          | 0x0003   | 索引节点              |
| FIL_PAGE_IBUF_FREE_LIST | 0x0004   | insert buffer空闲列表 |
| FIL_PAGE_TYPE_ALLOCATED | 0x0000   | 该页为最新分配页      |
| FIL_PAGE_IBUF_BITMAP    | 0x0005   | insert buffer 位图    |
| FIL_PAGE_TYPE_SYS       | 0x0006   | 系统页                |
| FIL_PAGE_TYPE_TRX_SYS   | 0x0007   | 事务系统数据          |
| FIL_PAGE_TYPE_FSP_HDR   | 0x0008   | File space Header     |
| FIL_PAGE_TYPE_XDES      | 0x0009   | 扩展描述页            |
| FIL_PAGE_TYPE_BLOB      | 0x000A   | BLOB页                |

## Page Header

Page Header 用来记录数据也的状态信息，由14个部分组成，共占用56个字节，如表所示：

| 名称              | 大小(B) | 说明                                                         |
| ----------------- | ------- | ------------------------------------------------------------ |
| PAGE_N_DIR_SLOTS  | 2       | 在Page Directory页目录中的Slot 槽数，后续                    |
| PAGE_HEAP_TOP     | 2       | 堆中第一个记录的指针， 记录在页中是根据堆的形式存放的        |
| PAG_ N_HEAP       | 2       | 堆中的记录数． 一共占用2 字节， 但是第15 位表示行记录格式    |
| PAGE_FREE         | 2       | 指向可重用空间的首指针                                       |
| PAGE_GARBAGE      | 2       | 己删除记录的字节数， 即行记录结构中delete flag为1的记录大小的总数 |
| PAGE_LAST_INSERT  | 2       | 最后捕入记录的位置                                           |
| PAGE_DIRECTION    | 2       | 最后插入的方向． 可能的取值为<br />PAGE_LEFT (0x01) <br />PAGE_RIGHT (0x02) <br />PAGE_SAME_REC (0x03) <br />PAGE_SAME_PAGE (0x04)<br />PAGE_NO_DIRECTION(0x05) |
| PAGE_N_DIRECTION  | 2       | 一个方向连续插入记录的数量                                   |
| PAGE_N_RECS       | 2       | 该页中记录的数量                                             |
| PAGE_MAX_TRX_ID   | 8       | 修改当前页 的最大事务ID， 注意该值仅在Secondary Index中定义  |
| PAGE_LEVEL        | 2       | 当前页 在索引树中的位置，0x00代表叶节点，即叶结点总在第0层   |
| PAGE_INDEX_ID     | 8       | 索引ID， 表示当前页属于哪个索引                              |
| PAGE_BTR_SEG_LEAF | 10      | B+树数据页非页节点所在段的segment header。 注意该值仅在B+树的Root页中定义 |
| PAGE_BTR_SEG_TOP  | 10      | B+树数据页所在段的segment header。注意该值仅在B+树的Root页中定义 |

## Infimun和Supremum Record

在InnoDB中，每个数据页有两个虚拟的行记录，用来限定记录的边界。Infimum记录的是比该页中任何主键值都要小的值，Supremum值比任何可能大的值都要打的值。这两个值在页被创建时被建立，并且在任何情况下都不会被删除。

在Compact行格式和Redundant行格式下，两者占用的字节数各不相同。下面显示Infimun和Supremum 的记录：

![InfinumAndSupremumRecord](https://gitee.com/wangziming707/note-pic/raw/master/img/InfinumAndSupremumRecord.png)

## User Record和Free Space

User Record就是之前讨论的实际存储行记录的内容的页，即B+树的叶子节点页。

Free Space指空闲空间，同样也是链表数据结构。在一条记录被删除后，该空间会被加入到空闲链表中。

## Page Directory

Page Dirctory (页目录)中存放了记录的相对位置(是页相对位置，而不是偏移量),有些时候这些记录指针称为Slots 槽或者 Directory Slots 目录槽。

InnoDB并不是每个记录拥有一个槽，InnoDB的槽是一个稀疏目录，即一个槽中可能包含多个记录。当记录被插入或删除时需要对槽进行分裂或平衡的维护操作。

在Slots中记录按照索引键值顺序存放，这样可以利用二分查找快速找到记录的指针。这个查找只是一个粗略的结果，找到指针后还有根据指针对应的行记录数据的record header的next_record来进行一次顺序链表查找。来找到具体的行。

需要注意：B+树索引本身不能找到具体的一条记录，而是只找到具体记录所在的页。然后将页载入内存，通过Page Directory进行二分查找。只不过这次二分查找的时间复杂度很低，同时再内存中查找的很快，所以通常忽略这部分查找所用的时间。

## File Trailer

为了检测页是否已经完整地写入磁盘。InnoDB在页中设置了File Trailer部分。

File Trailer只有一个FIL_PAGE_END_LSN部分，占用8个字节。前四个字节代表该页的checksum值，后四个字节于File Header 中的FIL_PAGE_LSN相同。

将File Trailer记录的这两个值于File Header中的FIL_PAGE_SPACE_OR_CHKSUM和FIL_PAGE_LSN值进行比较(checksum的比较需要通过InnoDB的checksum函数来进行比较，而不是简单的等值比较)，看是否一致，以此来保证页的完整性

在默认配置下，InnoDB每次从磁盘读取一个页就检测一次该页的完整性，即页是否发生了Corrupt，这就是通过File Trailer部分进行检测的。这样的检测有一定的开销，可以通过`innodb_checksums`来开启或关闭对页完整性的检查。

MySQL5.6.6版本开始新增参数`innodb_checksum_algorithm`用来控制检测checksum函数的算法，默认值为`crc32`，可以设置的值有innodb、crc32、none、strict_innodb、strict_crc32、strict_none.

* innodb是兼容之前版本的算法

* crc32是5.6.6版本引进的新checksum算法，有着较高的性能

* none表示不对页启用checksum检查
* strict_*表示严格地按照设置的checksum算法进行页的检测

# Named File Formats机制

随着InnoDB引擎版本的迭代，新的页数据结构有时用来支持新的功能特性。例如InnoDB1.0.x版本提供了新的页数据类型来支持表压缩功能，完全溢出的大字段的存储。这些新的页数据结构和之前版本的页并不兼容，因此从InnoDB1.0.x开始，引入了Named File Formats机制来解决不同版本下页结构兼容性的问题。

InnoDB1.0.x之前版本的文件格式定义为Antelope，而InnoDB1.0.x版本支持的文件格式定义为Barracuda

新的文件格式总是包含于之前的版本的页格式。即Barracuda包含了Antelope中的所有文件格式。它们的结构如图所示：

![NamedFileFormats](https://gitee.com/wangziming707/note-pic/raw/master/img/NamedFileFormats.png)

后续如果有新的文件格式，将会继续依次定义新的文件格式命，如过定义了`Cheetah`，则除了Cheetah特有的文件格式，它还将包含Barracuda的文件格式。

参数`innodb_file_format`用来指定文件格式。

参数`innodb_file_format_check`用来检测当前InnoDB引擎文件格式的支持读，默认为ON，如果出现不支持的文件格式，错误日志将打印错误。

# 约束

## 数据完整性

关系型数据库提供约束(constraint)机制，来保证数据库中数据的完整性。一般来说，数据完整性有以下三种形式：

* 实体完整性保证表中有一个主键。可以通过下面方式来保证：
  * 通过定义主键和唯一键约束
  * 通过编写触发器
* 域完整性保证表中每列数据满足特定的条件，可以通过下面几种途径来保证：
  * 选择合适的数据类型来保证数据值满足特定条件
  * 外键约束
  * 编写触发器
  * 考虑用default约束作为强制域完整性的一个方面
* 参照完整性保证两张表之间的关系，可以通过下面几种途径来保证：
  * 定义外键约束
  * 编写触发器

而对于InnoDB本身，提供了以下几种约束：

* Primary Key
* Unique Key
* Foreign Key
* Default
* Not Null

## 约束的创建和查找

约束的创建可以采用以下两种方式：

* 建表时就进行约束定义
* 利用alter table命令进行创建约束

在建表时创建约束的完整指令如下：

~~~mysql
列名 列的类型 unique; # 唯一约束
列名 列的类型 not null; # 非空约束
列名 列的类型 primary key; # 主键约束（唯一且非空）
列名 列的类型 auto_increment; #自增长
列名 列的类型 default 默认值# 设置默认值
~~~

使用alert table 创建约束的完整命令如下：

~~~mysql
alter table table_name add index_type index_name( column_name );
~~~

例如：

~~~mysql
create table u (
	id int primary key ,
	name varchar(20),
	id_card char(18),
	unique key (name)
);
alter table u add unique key uk_id_card( id_card);
~~~

### 外键约束

而外键约束需要两张表的参与，其语法：

~~~mysql
[constraint [symbol]] foreign key
[index_name] (index_col_name,...)
references tbl_name (index_col_name,...)
[on delete reference_option]
[on update reference_option]
reference_option: restrict| cascade | set null | no action

~~~

使用场景是：

~~~mysql
#表存在时：
alter table 从表 add constraint 外键约束名 foreign key(从表的列) references 主表(主表的主键列)
#表创建时；
[constraint 外键约束名] foreign key(从表的列) references 主表(主表的主键列)
#直接在属性后：
references 主表(主表的主键列)
s
#解除外键约束
alter table 表名 drop foreign key 外键约束名;
~~~

一个示例：

~~~mysql
create table p(
	id int,
    U_id int,
    primary key (id),
    foreign key (u_id) references u(id)
);
~~~

### 查看约束信息

可以通过`information_schema`架构下的`table_constraints`表查看MySQL库下的所有约束信息。

对于外键的约束信息，可以通过表`referential_constraints`表查看。

## 对错误数据的约束

在某些默认设置下，MySQL允许非法的或者不正确的数据的插入和更新，又或者可以在数据库内部将其转换为一个合法的值，例如向not null的字段插入一个null值，数据库会将其改为0再进行插入。

这种行为是通过参数`sql_mode`来控制的，用来控制数据约束的严格程度，这是一个多值参数，每个值通过`,`逗号隔开，其可选的常用值有：

| 参数值                           | 说明                                                         |
| -------------------------------- | ------------------------------------------------------------ |
| ONLY_FULL_GROUP_BY               | GROUP BY聚合查询中如果SELECT中的列没在GROUP BY子句中，那么这个SQL是非法的 |
| NO_AUTO_VALUE_ON_ZERO            | 在自增列上插入数值0时，实际插入的值为0。如果不设置该模式则在自增列上插入数值0或NULL时都会插入实际自增的值 |
| NO_ENGINE_SUBSTITUTION           | 指定的存储引擎不存在则报错，如果不设置该模式则在指定的存储引擎不存在时使用InnoDB引擎 |
| ANSI                             | 宽松模式，会更改不符合条件的数据。也就是说数据如果不符合定义的类型或长度，会对数据的类型进行调整或截断保存，报warning警告。对于以除数为0的计算结果为值的字段值，数据库会用NULL值代替 |
| STRICT_TRANS_TABLES              | 支持事务的引擎（如InnoDB）严格检查数据类型，不支持事务的引擎（如MyISAM）批量操作时，根据第1条数据是否成功决定后面的数据类型检查失败时是否使用宽松模式处理。也就是说：如果第1条执行成功，那么后面的操作即使数据类型检查失败也使用宽松模式处理；如果第1条执行失败，那么即使后面的操作数据类型检查成功也不执行 |
| STRICT_ALL_TABLES 或 TRADITIONAL | 支持事务的引擎（如InnoDB）严格检查数据类型，不支持事务的引擎（如MyISAM）批量操作时，数据类型检查失败的那条数据之后的所有数据操作都不执行，即使数据类型检查失败的那条数据之后有检查成功的数据，这些成功的数据也不执行 |
| NO_ZERO_IN_DATE                  | 在STRICT模式下，日期中的月、日不能为0，但0000-00-00除外      |
| NO_ZERO_DATE                     | 在STRICT模式下，日期不能设置为0000-00-00                     |
| ERROR_FOR_DIVISION_BY_ZERO       | 除数不能为0，如果不设置该模式则返回NULL                      |
| NO_AUTO_CREATE_USER              | 禁止创建密码为空的新用户                                     |
| PIPES_AS_CONCAT                  | 将"\|\|"视为字符串的连接操作符而非或运算符                   |
| ANSI_QUOTES                      | 可以用双引号来括数据库的对象名，比如表名，列表，这样就不能用双引号来引用字符串了 |

## ENUM和SET

MySQL数据库不支持传统的CHECK约束，但可以通过enum和set类型达到部分check的效果。

例如表中有一个性别类型，规定域的范围只能是male或者female，这种情况下可以用enum类型进行约束：

~~~mysql
create table a(
	id int,
	sex enum('male','female')
);
~~~

## 触发器于约束

可以通过触发器来实现数据完整性，触发器的作用是在执行insert、delete和update命令之前或之后自动调用SQL命令或者存储过程。

其声明格式如下：

~~~mysql
create
[definer = {user | current_user} ]
trigger trigger_name before|after insert|update|delete
on tbl_name for each row trigger_stmt
~~~

* `trigger_name`：标识触发器名称，用户自行指定；
* `tbl_name`：标识建立触发器的表名，即在哪张表上建立触发器；
* `trigger_stmt`：触发器程序体，可以是一句SQL语句，或者用 BEGIN 和 END 包含的多条语句。

before和after表示触发时机，表示是再每行操作前触发还是后触发。

而支持的操作为insert|update|delete

# 视图

MySQL数据库中，视图（view）是命名的虚表，它由一个SQL查询来定义，可以当作表来使用。

于持久表不同的是，视图中的数据没有物理存储。

~~~sql
#创建或更新视图
create [or replace]
[algorithm = {undefined|merge|temptable}]
[definer = {user | current_user}]
[sql security {definer |invoker}]
view view_name [(column_list)] 
as select_statement;
[with [cascaded | local] check option]
# 查看视图
show create view viewName;
# 删除视图
drop view viewName;

#查询视图
select viewName ;
#更新视图
insert | update viewName;
#通常情况下视图是可更新的，更新一个视图将更新其基表
~~~

视图的规则和限制：

* 与表一样，视图必须唯一命名（不能给视图取与别的视图或表相同的名字）。
* 对于可以创建的视图数目没有限制。
* 为了创建视图，必须具有足够的访问权限。这些限制通常由数据库管理人员授予。
* 视图可以嵌套，即可以利用从其他视图中检索数据的查询来构造一个视图。
* ORDER BY可以用在视图中，但如果从该视图检索数据SELECT中也含有ORDER BY，那么该视图中的ORDER BY将被覆盖。
* 视图不能索引，也不能有关联的触发器或默认值。
* 视图可以和表一起使用。例如，编写一条联结表和视图的SELECT语句。  

* 通常情况下视图是可更新的，更新一个视图将更新其基表
* 如果视图定义中有以下操作，则不能进行视图的更新：  
  * 分组（使用GROUP BY和HAVING）
  * 联结；
  * 子查询；
  * 并；
  * 聚集函数（ Min()、 Count()、 Sum()等）；  
  * DISTINCT；
  * 导出（计算）列  

对于可更新的视图，可以用视图定义中的`with check option`命令来决定更新的值是否需要检查。

先看一个例子：

~~~mysql
create table t (
	id int 
);
create view v_t as
select * from t where id < 10;
insert into v_t select 20;
select * from v_t; #empty
select * from t; # row(20)
~~~

创建一个表t，并创建一个id<10的视图v_t,然后向视图插入id为20的值，插入操作并没有报错，但是数据已经成功插入了t。

按照常理，通过视图插入的数据应该满足视图的查询条件id<10.想要达到这样的效果，可以更改视图定义，加上`with check option`选项：

~~~mysql
create view v_t as
select * from t where id < 10
with check option;
insert into v_t select 20; #报错：CHECK OPTION failed 'xxx.v_t'
~~~

此时插入一个不符合视图sql where 条件的数据，将报错。

`show table`命名会将表和视图都显示出来，如果想要只看物理表，可以通过`information_schema`下的`table`表来查询添加条件`where table_type='BASE TABLE'`

如果想要看视图下的一些元数据，可以访问`information_schema`下的views表

# 分区表

