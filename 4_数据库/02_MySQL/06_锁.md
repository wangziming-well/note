# 概述

锁的机制帮助数据库在并发环境下，保证数据的线程安全。锁也是数据库系统区别于文件系统的一个关键特性。

锁机制用于管理对共享资源的并发访问。除了对表数据上锁，InnoDB也会在数据库内部的其他很多地方使用锁，例如：LRU列表。

InnoDB锁提供一致性的非锁定读、行级锁支持。行级锁没有相关额外开销，可以同时得到并发性和一致性。

# lock和latch

在数据库中latch和lock都可以被成为额锁，但是两者含义不同。

latch一般称为闩锁(轻量级的锁),其要求锁定的时间必须非常短。否则，应用的性能会非常差。在InnoDB中，latch又可以分为mutex(互斥量)和rwlock(读写锁),用来保证并发线程操作临界资源的正确性，并且通常没有死锁检测的机制。

lock的对象是事务，用来锁定的是数据库中的对象，如表，页，行。并且一般lock对象仅在事务commit或rollback后进行释放。此外lock一般有死锁检测机制。

可以通过命令`show engine innodb mutex`来观察InnoDB中的latch

可以通过命令`show engin innodb status`及`information_schema`下的表`innodb_trx`、`innodb_locks`、`innodb_lock_waits`来观察锁的信息

# InnoDB存储引擎中的锁

## 锁的类型

InnoDB实现了如下两种标准的行级锁

* 共享锁:(S Lock)，可以由多个事务持有，允许事务读行数据
* 排他锁:(X Lock)，同一时刻只能由一个事务持有，允许事务删除或更新行数据

如果在数据项上有了类型为A的锁，此时仍然可以有事务在该数据项上申请类型为B的锁。我们就称A和B相容。否则称为不相容。

显然，排他锁和任何类型的锁都不相容，共享锁和共享锁相容。

另外，InnoDB支持多粒度的锁定。可以将上锁的对象看作一棵树，比如：树根是整个数据库，第二层是模块，第三层是表，第四层是行数据。总是越下层的粒度越细。

如果想要锁定整个数据库，不需要为所有表上的所有行添加行级锁。只需要将树根上锁即可。但是上锁前，需要判断是否可以上锁，比如希望对表t上排他锁，我们必须保证表t上没有其他锁，并且表t的下一层，所有的行上也没有其他锁。我们可以搜索要上锁节点的所有后代节点来判断是否可以上锁，但这就违背了多粒度锁的初衷。

所以引入了意向锁。当要对一个节点N上锁时，需要同时对这个节点的所有父节点添加上意向锁，以通知父节点，其子节点上锁了。这样当事务在父节点上申请锁时，只需要判断当前节点是否有意向锁即可，而不需要遍历所有子节点。

如果要在子节点上申请S锁，那么它的所有父节点需要添加上IS意向锁，如果要在子节点上申请X锁，那么需要在它所有的父节点上添加上IX意向锁

在InnoDB中，意向锁只支持到表级，及意向锁就是表级别的锁，支持的两种意向锁为：

* 意向共享锁(IS Lock):表示事务想要获取表中某几行的共享锁
* 意向排他锁(IX Lock):表示事务想要获取表中某几行的排他锁

从InnoDB1.0开始，我们可以通过`information_schema`下的表`innodb_trx`、`innodb_locks`、`innodb_lock_waits`来观察锁的信息

在MySQL8.0.13版本，`performance_schema.data_locks `取代了`innodb_locks`表；`performance_schema.data_lock_waits`取代了`innodb_lock_waits`表

我们来看下innodb_locks的表结构：

* ENGINE: 存储引擎（INNODB）

* ENGINE_LOCK_ID  存储引擎内部的锁ID，该值会发生动态变化，外部系统不应该依赖该值

* ENGINE_TRANSACTION_ID:  2578 (`information_schema.innodb_trx`中的`trx_id`)

* THREAD_ID: 持有锁的线程ID

* EVENT_ID: 29

* OBJECT_SCHEMA:  数据库名（lock_test）

* OBJECT_NAME: 表名（first_table）

* PARTITION_NAME:  分区名

* SUBPARTITION_NAME:  子分区名

* INDEX_NAME: 索引名

* OBJECT_INSTANCE_BEGIN: 锁的内存空间起始地址

* LOCK_TYPE: 锁类型（TABLE/RECORD）

* LOCK_MODE: 锁模式
  * S: 
    * LOCK_TYPE=TABLE时，表示表级共享锁
    * LOCK_TYPE=RECORD, 表示行级共享锁和间隙锁构成的next-key lock
  * S, GAP: 间隙锁
  * S, REC_NOT_GAP: 行级共享锁
  * IS: 意向共享锁
  * X:
    *  LOCK_TYPE=TABLE时，表示表级排他锁；
    * LOCK_TYPE=RECORD, 表示行级排他锁和间隙锁构成的next-key lock
  * X, GAP: 间隙锁
  * X, REC_NOT_GAP: 行级排他锁
  * X,GAP,INSERT_INTENTION: 插入意向锁。
  * IX: 意向排他锁

* LOCK_STATUS: `GRANTED`、`WAITING`

* LOCK_DATA： 锁对应的数据，如果锁定的是主键索引，值为加锁的主键值；锁定的是非主键索引，值为`[索引值, 对应主键值]`

## 一致性非锁定读

一致性非锁定读(consistent nonlocking read)指InnoDB通过多版本控制的方式来读取当前执行时间数据库中行的数据。

如果读取的行正在执行delete或者update操作，这时读取操作不会等待行上的锁释放。而是去读取行的一个快照数据。

快照数据指该行之前版本的数据，是通过undo段实现的。而undo本身就需要使用以在事务中回滚数据，因此快照数据本身没有额外的开销。此外，快照数据不需要上锁，因为没有事务会对历史的数据进行修改操作。

这种技术称为行多版本技术。由此带来的并发控制称为多版本并发控制(Multi Version Concurrency Control,MVCC)

在读已提交和可重复读的事务隔离级别下，InnoDB会使用非锁定一致性读。但是在这两种隔离级别下，对快照的定义却不同：

* read committed下：非锁定一致性读总是读取被锁定行的最新一份快照数据
* repeatable read下：非锁定一致性读总是读取事务开始时的行数据版本

## 一致性锁定读

InnoDB对select操作默认使用一致性非锁定读。但是在某些情况下，需要显式地对读取操作进行加锁以保证数据逻辑的一致性。这就要求支持对读取操作的加锁语句。InnoDB对select语句支持两种一致性的锁定读(locking read)操作：

* `select ... for update`,对读取的行记录加一个X锁
* `select ... lock in share mode`，对读取的行记录加一个S锁

这两种语句必须在事务中，当事务提交了，锁也就释放了。所以在使用上述两种语句时，必须加上`begin`、`start transaction`或者`set autocommit=0`

# 锁的算法

InnoDB中有三种行锁的算法，分别是：

* Record Lock：单个行记录上的锁
* Gap Lock：间隙锁，锁定一个范围，但不含记录本身
* Next-Key Lock ：Gap Lock+Recordd Lock,锁定一个范围，并且锁定记录本身

举例来说，假如一个索引有数据1，3，5那么：

* Record Lock可以锁定 1，3，5数据本身
*  Gap Lock可以锁定  (-∞,1),(1,3),(3,5),(5,+∞)的区间
* Next-Key Lock 可以锁定   (-∞,1],(1,3],(3,5],(5,+∞)的区间

Record Lock锁定的是索引记录，如果表没有任何索引，InnoDB会隐式使用主键来进行锁定。

InnoDB对行的查询都采用了Next-Key Lock的算法。然后当查询的索引列还有唯一属性时，InnoDB会对Next-Key Lock 进行优化，将其降级为Record Lock，从而提高并发性。

InnoDB会对辅助索引的下一个键值加上gap lock，以保证不会发生幻读问题

