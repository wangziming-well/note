# 概述

索引是应用程序设计和开发的一个重要方面。若索引太多，应用程序的性能可能会收到影响。而索引太少，对查询性能又会产生影响。所以需要找到一个合适的平衡点。

InnoDB支持以下常见的索引：

* B+树索引
* 全文索引
* 哈希索引

InnoDB中哈希索引是自适应的，会更具表的使用情况自动为表生成哈希索引，不能人为干预。

B+树索引就是传统意义上的索引，这是目前关系型数据库中最为常用和有效的索引。注意B+树只能找到被查找数据行所在的页。然后把页读入内存，再在内存中进行查找。

# B+树索引

B+树索引的本质就是B+树数据结构在数据库中的实现。B+索引在数据库中的一个特点就是高扇出性，因此在数据库中，B+树的高度一般都在2~4层，也就是查找某一键值的行记录时最多只需要2到4次IO。

数据库中的B+树索引可以分为聚集索引和辅助索引(或者聚簇索引和非聚簇索引)

## 聚集索引

之前已经介绍过，InnoDB存储引擎表时索引组织表，即表中数据按照主键顺序存放。

而聚集索引(clustered index)就是按照每张表的主键构造一棵B+树，同时叶子节点中存放的即为整张表的行记录数据，也将聚集索引的叶子节点称为数据页。

### 特点

在聚集索引的结构中，非叶子节点对应索引页，叶子节点对应数据页。数据页中存放的是完整的行记录，而索引页仅存放键值和指向数据页的指针(偏移量)，而不是完整的行记录

聚集索引的这个特性决定了索引组织表中数据也是索引的一部分。同B+树数据结构一样，每个数据页都通过一个双向链表进行链接。

很显然，每张表只能拥有一个聚集索引，因为每张表的主键逻辑存储顺序只有一个，而聚集索引是按照这个主键顺序来组织的。

聚集索引的叶子节点是按照主键顺序排序的，这里的排序顺序并不是指数据按照特定的顺序物理地存储在硬盘上。而是指叶子节点在逻辑上是连续排序的，这体现在：

* 页通过双向链表链接，在链表中按照主键顺序排序
* 页中的记录也是通过双向链表维护的

而实际的物理存储上可以不按照主键存储

### 优点

在多数情况下，查询优化器倾向于采用聚集索引，因为聚集索引能在B+树的叶子节点上直接找到数据。此外，因为定义了数据的逻辑顺序，聚集索引能特别快地访问针对范围值的查询和排序的查询。

首先创建一张表用于演示，它有一个主键。并插入几行数据：

~~~mysql
create table t (
	id int primary key,
	name varchar(40) not null,
	age int not null
) engine = innodb;

insert into t values
(1,"a",10),
(2,"b",40),
(5,"c",30),
(10,"d",20),
(154,"e",55);
~~~

接下来对主键排序查询，并查看执行计划：

~~~mysql
explain
select * from t order by id limit 2;
~~~

结果如下：

![对主键排序查询的执行计划](https://gitee.com/wangziming707/note-pic/raw/master/img/%E5%AF%B9%E4%B8%BB%E9%94%AE%E6%8E%92%E5%BA%8F%E6%9F%A5%E8%AF%A2%E7%9A%84%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92.png)

可以看到，extra中没有类似`Using filesort`的展示。这就是因为聚集索引的特点。

拎一个是范围查询，通过叶子节点的上层中间节点就可以得到页的范围，之后直接读取数据页即可,例如：

~~~mysql
explain
select * from t
where id >=10 and id <=1000;
~~~

其结果为：

![主键范围查询执行计划的结果](https://gitee.com/wangziming707/note-pic/raw/master/img/%E4%B8%BB%E9%94%AE%E8%8C%83%E5%9B%B4%E6%9F%A5%E8%AF%A2%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%E7%9A%84%E7%BB%93%E6%9E%9C.png)

可以看到这里查询的类型是`range`，并且使用了主键进行。

## 辅助索引

辅助索引(Secondary Index,也称非聚集索引)的叶子节点不包含行记录的全部数据。其叶子节点除了包含键值以外，每个叶子节点中的索引行还包含一个书签，用于告诉InnoDB哪里可以找到于索引相对应的行数据。由于InnoDB是索引组织表，所以辅助索引的书签就是相应行数据的聚集索引键。

辅助索引的存在并不改变数据在聚集索引中的组织，每张表上可以有多个辅助索引。当通过辅助索引来寻找数据时，需要遍历辅助索引找到其叶子节点上对应的书签。然后再根据书签提供的键通过主键索引来找到完整的行记录。

即如果在一颗高度为3的辅助索引树种查找数据，那么需要进行3次IO找到指定主键，如果聚集索引树的高度也为3，那么还需要对聚集索引进行查找，同样需要3次IO。最终找到一个完整行数据所在的页。一共需要6次逻辑IO。

## 管理B+树索引

索引的创建和删除可以通过两个办法，一种是`alter table`另一种是`create/drop index`。

通过`alter table`创建索引的语法为：

~~~mysql
#创建索引
alter table tbl_name
add {index|key} [index_name]
[index_type] (index_col_name,...) [index_option]

#删除索引
alter table tbl_name
drop primary key
| drop {index|key} index_name;
~~~

通过`create/drop index`创建索引的语法为：

~~~mysql
create [unique] index index_name
[index_type]
on tbl_name (index_col_name,...);

drop index index_name on tbl_name;
~~~

可以设置对整个列的数据进行索引，也可以只索引一个列的开头部分数据，如假设表t的列b为`varchar(8000)`，我们可以只索引前100个字段：

~~~mysql
alter table t
add key idx_b (b(100));
~~~

### 查看表的索引

可以通过`show index`命令查看表中索引的信息，例如

~~~mysql
show index from t;
~~~

接下来阐述`show index`命名结果中每列的含义：

* table：索引所在的表名
* non_unique:非唯一索引， 0表示唯一索引
* key_name:索引名
* seq_in_index：索引中该列的位置，通常是在复合索引中有意义
* column_name:索引列的名称
* collation:列是否以排序方式存储在索引中，A表示排序的，NULL表示不排序
* cardinality：表示索引中唯一值的数目的估计值。如果这个值很小，那么需要考虑删除这个索引
* sub_part:是否是列的部分被索引，如上例中的idx_b索引，如果索引整个列，则显示为NULL
* packed：关键字如何被压缩，如果没有压缩，则为NULL
* null，是否索引的列含有null值
* index_type:索引类型，通常都是BTREE
* comment：注释

cardinality这个值非常关键，优化器会根据这个值来判断是否使用这个索引。但这个值不是实时更新的，因为这样做代价太大了。所以这个值就是一个滞后的大概值。如果要更新索引的`Cardinality`值，可以使用`analyze table tbl_name`命令

### Fast Index Creation

