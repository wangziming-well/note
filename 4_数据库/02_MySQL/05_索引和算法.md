# 概述

索引是应用程序设计和开发的一个重要方面。若索引太多，应用程序的性能可能会收到影响。而索引太少，对查询性能又会产生影响。所以需要找到一个合适的平衡点。

InnoDB支持以下常见的索引：

* B+树索引
* 全文索引
* 哈希索引

InnoDB中哈希索引是自适应的，会更具表的使用情况自动为表生成哈希索引，不能人为干预。

B+树索引就是传统意义上的索引，这是目前关系型数据库中最为常用和有效的索引。注意B+树只能找到被查找数据行所在的页。然后把页读入内存，再在内存中进行查找。

# B+树索引

B+树索引的本质就是B+树数据结构在数据库中的实现。B+索引在数据库中的一个特点就是高扇出性，因此在数据库中，B+树的高度一般都在2~4层，也就是查找某一键值的行记录时最多只需要2到4次IO。

数据库中的B+树索引可以分为聚集索引和辅助索引(或者聚簇索引和非聚簇索引)

## 聚集索引

之前已经介绍过，InnoDB存储引擎表时索引组织表，即表中数据按照主键顺序存放。

而聚集索引(clustered index)就是按照每张表的主键构造一棵B+树，同时叶子节点中存放的即为整张表的行记录数据，也将聚集索引的叶子节点称为数据页。

### 特点

在聚集索引的结构中，非叶子节点对应索引页，叶子节点对应数据页。数据页中存放的是完整的行记录，而索引页仅存放键值和指向数据页的指针(偏移量)，而不是完整的行记录

聚集索引的这个特性决定了索引组织表中数据也是索引的一部分。同B+树数据结构一样，每个数据页都通过一个双向链表进行链接。

很显然，每张表只能拥有一个聚集索引，因为每张表的主键逻辑存储顺序只有一个，而聚集索引是按照这个主键顺序来组织的。

聚集索引的叶子节点是按照主键顺序排序的，这里的排序顺序并不是指数据按照特定的顺序物理地存储在硬盘上。而是指叶子节点在逻辑上是连续排序的，这体现在：

* 页通过双向链表链接，在链表中按照主键顺序排序
* 页中的记录也是通过双向链表维护的

而实际的物理存储上可以不按照主键存储

### 优点

在多数情况下，查询优化器倾向于采用聚集索引，因为聚集索引能在B+树的叶子节点上直接找到数据。此外，因为定义了数据的逻辑顺序，聚集索引能特别快地访问针对范围值的查询和排序的查询。

首先创建一张表用于演示，它有一个主键。并插入几行数据：

~~~mysql
create table t (
	id int primary key,
	name varchar(40) not null,
	age int not null
) engine = innodb;

insert into t values
(1,"a",10),
(2,"b",40),
(5,"c",30),
(10,"d",20),
(154,"e",55);
~~~

接下来对主键排序查询，并查看执行计划：

~~~mysql
explain
select * from t order by id limit 2;
~~~

结果如下：

![对主键排序查询的执行计划](https://gitee.com/wangziming707/note-pic/raw/master/img/%E5%AF%B9%E4%B8%BB%E9%94%AE%E6%8E%92%E5%BA%8F%E6%9F%A5%E8%AF%A2%E7%9A%84%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92.png)

可以看到，extra中没有类似`Using filesort`的展示。这就是因为聚集索引的特点。

拎一个是范围查询，通过叶子节点的上层中间节点就可以得到页的范围，之后直接读取数据页即可,例如：

~~~mysql
explain
select * from t
where id >=10 and id <=1000;
~~~

其结果为：

![主键范围查询执行计划的结果](https://gitee.com/wangziming707/note-pic/raw/master/img/%E4%B8%BB%E9%94%AE%E8%8C%83%E5%9B%B4%E6%9F%A5%E8%AF%A2%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%E7%9A%84%E7%BB%93%E6%9E%9C.png)

可以看到这里查询的类型是`range`，并且使用了主键进行。

## 辅助索引

辅助索引(Secondary Index,也称非聚集索引)的叶子节点不包含行记录的全部数据。其叶子节点除了包含键值以外，每个叶子节点中的索引行还包含一个书签，用于告诉InnoDB哪里可以找到于索引相对应的行数据。由于InnoDB是索引组织表，所以辅助索引的书签就是相应行数据的聚集索引键。

辅助索引的存在并不改变数据在聚集索引中的组织，每张表上可以有多个辅助索引。当通过辅助索引来寻找数据时，需要遍历辅助索引找到其叶子节点上对应的书签。然后再根据书签提供的键通过主键索引来找到完整的行记录。

即如果在一颗高度为3的辅助索引树种查找数据，那么需要进行3次IO找到指定主键，如果聚集索引树的高度也为3，那么还需要对聚集索引进行查找，同样需要3次IO。最终找到一个完整行数据所在的页。一共需要6次逻辑IO。

但是需要注意，当进行范围查找是，如果查找到的结果非常大，那么优化器就会放弃使用辅助索引，因此虽然辅助索引中是数据是顺序存储的，但是再一次通过书签查找数据是无需的，这会变为磁盘上的离散读操作。而顺序读要远远快于离散读。

## 管理B+树索引

索引的创建和删除可以通过两个办法，一种是`alter table`另一种是`create/drop index`。

通过`alter table`创建索引的语法为：

~~~mysql
#创建索引
alter table tbl_name
add {index|key} [index_name]
[index_type] (index_col_name,...) [index_option]

#删除索引
alter table tbl_name
drop primary key
| drop {index|key} index_name;
~~~

通过`create/drop index`创建索引的语法为：

~~~mysql
create [unique] index index_name
[index_type]
on tbl_name (index_col_name,...);

drop index index_name on tbl_name;
~~~

可以设置对整个列的数据进行索引，也可以只索引一个列的开头部分数据，如假设表t的列b为`varchar(8000)`，我们可以只索引前100个字段：

~~~mysql
alter table t
add key idx_b (b(100));
~~~

### 查看表的索引

可以通过`show index`命令查看表中索引的信息，例如

~~~mysql
show index from t;
~~~

接下来阐述`show index`命名结果中每列的含义：

* table：索引所在的表名
* non_unique:非唯一索引， 0表示唯一索引
* key_name:索引名
* seq_in_index：索引中该列的位置，通常是在复合索引中有意义
* column_name:索引列的名称
* collation:列是否以排序方式存储在索引中，A表示排序的，NULL表示不排序
* cardinality：表示索引中唯一值的数目的估计值。如果这个值很小，那么需要考虑删除这个索引
* sub_part:是否是列的部分被索引，如上例中的idx_b索引，如果索引整个列，则显示为NULL
* packed：关键字如何被压缩，如果没有压缩，则为NULL
* null，是否索引的列含有null值
* index_type:索引类型，通常都是BTREE
* comment：注释

cardinality这个值非常关键，优化器会根据这个值来判断是否使用这个索引。但这个值不是实时更新的，因为这样做代价太大了。所以这个值就是一个滞后的大概值。如果要更新索引的`Cardinality`值，可以使用`analyze table tbl_name`命令

### Fast Index Creation

在MySQL5.5之前，MySQL对索引的添加和删除操作具体过程如下：

* 首先创建一张新的临时表，表结构为通过命令`alter table`新定义的结构
* 然后把原表中的数据导入到临时表
* 然后删除原表
* 把临时表重命名为原来的表名

如果对一张大表进行索引的添加和删除操作，那么会需要很长的时间。在此期间这张表将不可用。还需要注意，临时表的创建路径是通过参数`tmpdir`进行设置的，必须保证它有足够的空间存放临时表，否则索引将创建失败。

从InnoDB1.0.x版本开始支持`Fast Index Creation`快速索引创建方式，简称FIC：

对于辅助索引的创建，InnoDB会对创建索引的表上加上要给S共享锁。在创建的过程中，不需要重建表，因此速度较之前提高了很多。

而删除索引只需要更新内部视图，并将辅助索引的空间标记为可用，同时删除MySQL数据库内部视图上对该表的索引定义即可。

由于FIC在索引的创建过程中加上了共享锁，因此在此期间可以进行读操作。但不能写。

此外FIC方式只限定于辅助索引，对主键的创建和删除同样需要重建一张表

### Online DDL

虽然FIC避免了创建临时表，从而提高了创建索引的效率。但是它仍然会阻塞表上的DML操作。

MySQL5.6版本开始支持Online DDL(在线数据定义)操作，允许创建辅助索引的同时，进行insert、update、delete等DML操作，这大大提高了MySQL在生产环境中的可用性。

此外，不止是辅助索引，下面基几类DDL操作都可以通过这种在线的方式进行操作：

* 辅助索引的创建和删除
* 改变自增长值
* 添加和删除外键约束
* 列的重命名

通过`alter table`语法，可以选择创建索引的方式：

~~~mysql
alter table tbl_name
drop | add {index|key} [index_name]
[index_type] (index_col_name,...)  [index_option]
algorithm [=] (default|inplace|copy)
lock [=] {default|none|shared|exclusive}
~~~

algorithm指定创建或删除索引的算法：

* copy：表示按照MySQL5.1版本之前的方式，即创建临时表的方式
* inplace表示创建或删除索引不需要创建临时表
* default表示根据参数`old_alter_table`来判断是通过inplace还是copy的算法，这个参数默认值为off，表示采用inplace的方式

lock部分为索引创建和删除时对表添加锁的情况，可选的参数有：

* none：对表不添加锁
* share：添加共享锁
* exclusive：添加排他锁
* default：首先判断当前操作是否可以使用none，如果能则直接使用none，如果不能则判断是否可以使用share模式，如果能则使用，如果不能拿，则判断是否可以使用exclusive模式。

InnoDB实现Online DDL的原理是在执行创建和删除操作的同时，将insert、update、delete这类DML操作日志写入一个缓存中。待完成索引创建后再将重做应用到表上，达成数据的一致性。这个缓存大小由参数`innodb_online_alter_log_max_size`控制，默认为128mb

# Cardinality值

并不是查询条件中出现的所有的列都需要添加索引的。

一般情况下，再访问表中很少一部分时使用B+树索引才有意义。

对性别、地区、类型字段，它们的可选值的范围很小，称为低选择性。比如按照性别进行查询时，可选范围通常只有M和F，因此这种查询的结果可能是表中的一半数据。此时添加B+树索引完全没有必要。

而如果某个字段的取值范围很广，几乎没有重复，即属于高选择性，则使用B+树索引才是最合适的。例如姓名

而`show index`命令结果中的Cardinality值就反映了索引是否是高选择性的。它表示索引中不重复记录数量的预估值。

在实际应用中`Cardinality/n_rows_in_table`应该尽量接近1。否则可以考虑删除这个索引。

## Cardinality的统计

MySQL中Cardinality值的统计是放到存储引擎层进行的。

需要考虑到：在生产环境中，对索引的更新操作是很频繁的，如果每次在发送操作时就对其进行一次Cardinality的统计，将会给数据库带来很大的负担。另外如果一张表的数据很大，那么统计一次Cardinality信息需要的时间可能非常长。这在生产环境下是不可接受的。

因此，不是每次更新索引就需要更新Cardinality信息，且数据库是通过采样(Sample)的方式来统计Cardinality信息的。

在InnoDB中，Cardinality统计信息的更新发生在两个操作中：insert和update。当然不是每次操作都更新。其更新Cardinality信息的策略为：

* 表中1/16的数据已发生变化
* `stat_modified_counter>2000000000`

第一种策略是自上次统计Cardinality信息后，表中的1/16的数据发生过变化，此时需要更新Cardinality信息。

第二种情况考虑的是，如果对表中某一行数据进行频繁的更新操作，实际变化的还是一行数据，无法触发第一个策略。所以在InnoDB中有一个计数器`stat_modified_counter`,用来表示发生变化的次数，当其大于2000000000时，同样需要更新Cardinality信息。

对Cardinality信息的统计是通过采样方法的。默认InnoDB对8个叶子节点(Leaf Page)进行采样，采用过程如下：

* 取得B+树索引中叶子节点的数量，记为A
* 随机取B+树索引种的8个叶子节点，统计每个页不同记录的个数，记为P1，P2，...，P8
* 算出Cardinality的预估值：$cardinality = (P1+P2+...+P8)*A/8$

所以需要记住`show index`命令中的 Cardinality只是一个估计值。

在InnoDB1.2版本之前，可以通过参数`innodb_stats_sample_pages`控制统计Cardinality时每次采用的页的数量，默认值为8。

参数`innodb_stats_method`来判断在统计Cardinality时，如何对待索引中出现的Null值记录，其可选值为：

* nulls_equal:默认值，将null值视为相等的记录
* nulls_unequal:将null值视为不同的记录
* nulls_ignored:忽略null值记录

在InnoDB1.2版本提供了更多的参数来对Cardinality的统计行为进行控制，其参数如下：

| 参数                                 | 说明                                                         |
| ------------------------------------ | ------------------------------------------------------------ |
| innodb_stats_persistent              | 是否将命令`analyze table`计算得到的Cardinality值存放到硬盘上，即持久化存储。默认为OFF<br />如果为ON，那么下次数据库重启时就不需要立即统计所有表的Cardinality值 |
| innodb_stats_on_metadata             | 在执行`analyze table`、`show table status`、`show index`以及访问`information_schema`下的`tables`和`statistics`时，是否需要重新计算索引的Cardinality值。默认为OFF |
| innodb_stats_persistent_sample_pages | 若参数innodb_stats_persistent设置为on，该参数表示analyze table 更新Cardinality值时每次采样页的数量。 |
| innodb_stats_transient_sample_pages  | 取代之前版本的参数`innodb_stats_sample_pages`，表示每次采样页的数量。默认值为8 |

# B+树索引的使用

我们需要考虑怎样正确的使用B+树索引，但是这里只能给出一个大概的方向，具体如何使用需要结合实际的生产环境情况决定。

数据库存在两种类型的应用：

* OLAP:(Online Analytical Processing) 在线数据分析系统
* OLTP(Online Transaction Processing) 在线事务处理系统

在OLTP应用中，查询操作通常只取得一小部分数据，比如根据主键值来获取用户信息，根据订单号获取订单信息。这种情况下，B+树索引很有用处。

对OLAP应用，情况更复杂一些。在LOAP应用中，都需要访问表中的大量的数据，根据查询到的大量数据来进行分析。很少查询单条或少量数据。这种时候往往不需要添加索引。但是如果涉及多张表之间的join操作，索引的添加仍然有意义。(如果有索引，并且连接条件合适，那么优化器就可以选择高效的算法，如归并算法来进行join操作)。但是如果join操作使用的是hash join，那么索引可能又不是很必要。

所以这需要开发人员研究判断是否需要添加索引。不过在OLAP中，通常会对时间字段添加索引，因为大多数统计都需要根据时间维度对数据进行筛选。

## 联合索引(复合索引)

之前我们只讨论了索引列只有一个的情况。而联合索引的索引列有多个；联合索引也是一个B+树，只是其索引的键值数量不是1，而是大于等于2。

例如，表t的索引`idx_a_b`是联合索引，它的索引列是a和b，其索引键可以表示为`(a,b)`

~~~mysql
create table t(
	a int primary key,
	b int,
	key idx_a_b (a,b)
)
~~~

索引中依旧按照键`(a,b)`的值顺序逻辑排列，如顺序：(1,1),(1,2),(2,1),(2,4),(3,1),(3,2).

所以对于上表t的查询`select * from t where a= xxx and b=xxx`的查询就可以使用这个`(a,b)`索引。

并且对a列的查询`select * from t where a =xxx`，同样可以使用`(a,b)`这个联合索引。

但是对b列的查询`select * from t where b = xxx`，就使用不到`(a,b)`索引了。

联合索引的第二个好处是已经对第二个键进行了排序处理。所有在涉及到两个列或多个列的条件查询或排序会比单个索引列更快。

例如对于联合索引`(a,b,c)`，下联语句可以直接通过这个索引获取结果，不用经过多余的排序：

~~~mysql
select * from t where a = xxx order by b
select * from t where a = xxx and b =xxx order by c
~~~

但是对于下面语句，这个索引就不能直接得到结果，必须执行一次filesort排序操作，因为`(a,c)`并未排序

~~~sql
select * from t where a = xxx order by c 
~~~

## 覆盖索引

InnoDB支持覆盖索引(covering index)，即从辅助索引中就可以得到查询的记录，而不需要查找聚集索引中的记录。使用覆盖索引的一个好处是辅助索引不包含行记录的所有信息，故其大小要远小于聚集索引，因此可以减少大量的IO操作。

辅助索引的叶子节点包含的是行的主键信息，即类似(primary key1,primary key2,...,key1,key2,...).所以下面语句都可以使用一次辅助联合索引来完成查询，而不需要使用聚集索引：

~~~mysql
select key2 from t where key1=xxx;
select primary key2,key2 from t where key1 = xxx;
select primary key1,key2 from t where key1 = xxx;
select primary key1,primary key2,key2 from t where key1 = xxx;
~~~

覆盖所有可以提高某些统计问题的查询性能，例如`count()`的查询：

~~~mysql
select count(*) from t; # 假设表上有辅助索引和聚集索引
~~~

此时InnoDB不会选择使用聚集索引来进行统计。而是表上的辅助索引来统计。因为辅助索引远小于聚集索引，这样可以减少IO操作。

对于带条件的统计查询，如果辅助索引中有对应的键，那么就可以使用辅助索引来查询，而不需访问聚集索引：

~~~mysql
select * from t  where a >=10 and b <=100; # 假设有 (a,b)联合索引
~~~

## 强制索引和索引提示

如果你确认使用某个索引可以带来更好的性能，而优化器没有使用该索引，那么可以使用关键字`force index`来强制使用某个索引，例如：

~~~mysql
select * from t  force index(a)
where a > 1000 and b <1000 ;
~~~

MySQL支持索引提示(index hint)，显式地告诉优化器使用哪个索引，以下是可能需要用到索引提示的场景：

* MySQL数据库的优化器错误地选择了某个索引，导致SQL语句运行很慢(这种情况很少出现)
* 某SQL语句可以选择的索引非常多，这时优化器选择执行计划时间的开销可能会大于SQL语句本身。此时可以直接告诉优化器使用什么索引，来节省选择索引的这部分开销

index hint的语法如下：

~~~mysql
tbl_name [[AS] alias] [index_hint_list]

index_hint_list:
index_hint [,index_hint] ...

index_hint:
use {index | key}[for {join|order by | group by}] ([index_list]) 
| {ignore|force} {index|key} [for {join|order by | group by}] (index_list) 

index_list:
index_name[,index_name]...
~~~

下面演示一个示例：，首先根据下面代码创建测试表t，并填充数据

~~~mysql
create table t(
	a int ,
	b int ,
	key(a),
	key(b)
);

insert into t values
(1,1),
(1,2),
(2,3),
(2,4),
(1,2);
~~~

下面执行如下的SQL语句：

~~~mysql
explain
select * from t where a=1 and b = 2;
~~~

可以看到执行计划：

![索引提示示例的执行计划结果](https://gitee.com/wangziming707/note-pic/raw/master/img/%E7%B4%A2%E5%BC%95%E6%8F%90%E7%A4%BA%E7%A4%BA%E4%BE%8B%E7%9A%84%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%E7%BB%93%E6%9E%9C.png)

图中的列possible_keys显示了上述SQL语句可使用的索引为a,b，而实际所用的索引为列key所示，同样为a,b。也就是MySQL使用a,b两个索引来完成这1个查询。列Extra提示的Using intersect(b,a)表示根据这两个索引得到的结果进行求交的数据运算，最后得到结果。

如果我们使用`use index` 的索引提示来使用a这个索引，如：

~~~mysql
explain
select * from t use index(a) where a=1 and b = 2;
~~~

其执行计划结果为：

![索引提示示例的执行计划结果1](https://gitee.com/wangziming707/note-pic/raw/master/img/%E7%B4%A2%E5%BC%95%E6%8F%90%E7%A4%BA%E7%A4%BA%E4%BE%8B%E7%9A%84%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%E7%BB%93%E6%9E%9C1.png)

可以看到possible_keys指示的可用索引变成了只有a，然后优化器实际会在其中选择是否要使用这个a，这里显示的结果是使用了a。

在某些情况下优化器也可能不选择我们指定的索引，而选择全盘扫描，此时我们可以使用`force index`命令，强制优化器使用指定索引。

## Multi-Range Read优化

MySQL5.6版本开始支持Multi-Range Read (MRR)优化，以减少磁盘的随机访问，并且将随机访问转化为较为顺序的数据访问。

Multi-Range Read优化适用于range，ref，eq_ref类型的查询

MRR优化有以下好处：

* 使数据访问变得较为顺序。
* 减少缓冲池中页被替换的次数
* 批量处理对键值的查询操作

对InnoDB和MyISAM的范围查找和join查询操作，MRR的工作方式如下：

* 将查询得到的辅助索引键值存放于一个缓冲中，这时缓冲中的数据是按照辅助索引键值排序的
* 将缓存中的键值根据RowID进行排序
* 根据RowID的排序顺序来访问实际的数据文件

如果缓冲池不够大，不足以存放下一张表中的所有数据，那么频繁的离散读取操作会导致缓冲中的页被替换出缓冲池，又不断被写入缓冲池。若按照主键顺序进行访问，则可以将这种重复行为频率降为最低

当启用了MRR优化配置后，执行如下范围查询：

~~~mysql
explain
select * from t  where b > 2 and b< 10000;
~~~

其执行计划结果为：

![MRR优化示例执行计划结果](https://gitee.com/wangziming707/note-pic/raw/master/img/MRR%E4%BC%98%E5%8C%96%E7%A4%BA%E4%BE%8B%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%E7%BB%93%E6%9E%9C.png)

可以看到extra中显示Use MRR,表示使用了MRR优化

是否启用MMR优化可以通过参数`optimizer_scitch`中的标记flag来控制，这个参数值可以由多个flag组成，每个flag通过逗号`,`分隔，其相关的标记如下：

* mrr:为on表示启用MRR优化
* mrr_cost_based:表示是否通过cost based的方式来选择是否启用mrr，如果为off，表示总是启用MRR优化

我们可以用下面语句将MRR优化设置为总是开启：

~~~sql
set @@optimizer_switch='mrr=on,mrr_cost_based=off';
~~~

## Index Condition Pushdown (ICP)优化

