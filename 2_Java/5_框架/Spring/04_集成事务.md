# Spring事务简述

Java平台提供了许多能够管理数据库事务管理的API，例如：

* JDBC事务管理
* 基于JTA的分布式事务管理

这些API提供的事务管理与数据访问是强耦合的

以JDBC为例，通过Connection对象获取语句访问数据库，同时通过Connection对象进行事务管理，这导致数据访问代码和事务管理的迪马的可重用性降低，并且事务管理的代码在数据访问层和业务服务层到处散落。

针对直接使用这些事务管理API带来的弊端，Spring提供了事务框架，让事务管理的关注点和数据访问的关注点分离。

Spring的事务框架将 connection通过ThreadLocal绑定到当前线程上，让处在同一事务中的不同dao数据访问方法公用同一个connection对象，保证它们处于同一事务下。

Spring的事务后向包括三个主要接口：

* `PlatformTransactionManager`：界定事务边界
* `TransactionDefinition`：负责定义事务相关属性，如隔离级别、传播行为等
* `TransactionStatus`：负责的事务状态

# TransactionDefinition

`TransactionDefinition`定义如下:

~~~java
public interface TransactionDefinition {
	int PROPAGATION_REQUIRED = 0;
	int PROPAGATION_SUPPORTS = 1;
	int PROPAGATION_MANDATORY = 2;
	int PROPAGATION_REQUIRES_NEW = 3;
	int PROPAGATION_NOT_SUPPORTED = 4;
	int PROPAGATION_NEVER = 5;
	int PROPAGATION_NESTED = 6;
	int ISOLATION_DEFAULT = -1;
	int ISOLATION_READ_UNCOMMITTED = 1;
	int ISOLATION_READ_COMMITTED = 2;
	int ISOLATION_REPEATABLE_READ = 4;
	int ISOLATION_SERIALIZABLE = 8;
	int TIMEOUT_DEFAULT = -1;

	default int getPropagationBehavior() {
		return PROPAGATION_REQUIRED;
	}

	default int getIsolationLevel() {
		return ISOLATION_DEFAULT;
	}

	default int getTimeout() {
		return TIMEOUT_DEFAULT;
	}

	default boolean isReadOnly() {
		return false;
	}


	default String getName() {
		return null;
	}

	static TransactionDefinition withDefaults() {
		return StaticTransactionDefinition.INSTANCE;
	}
}
~~~

## 事务属性

`TransactionDefinition`主要定义了可以指定的事务属性：

* 事务的传播行为
  * ISOLATION_DEFAULT：数据库的默认隔离级别，通常是读已提交
  * ISOLATION_READ_UNCOMMITTED:读未提交
  * ISOLATION_READ_COMMITTED :读已提交
  * ISOLATION_REPEATABLE_READ:不可重复读
  * ISOLATION_SERIALIZABLE :可串行化
  
* 事务隔离级别
  * PROPAGATION_REQUIRED：如果当前存在一个事务，则加入当前事务。如果不存在任何事务，则创建一个新的事务。总之当前i业务处于事务中。
  
    通常为默认的事务传播行为
  
  * PROPAGATION_SUPPORTS：如果当前存在一个事务，则加入当前事务。如果当前不存在事务，则直接执行。
  
    这种传播行为适合一些查询方法：如果当前查询方法直接执行，则不需要事务，如果当前查询方法别其他的方法调用，而其他方法开启了事务，则能加入该事务，并能获取当前事务对数据的更新。
  
    如果没加入改事务的话，查询方法就不能获取事务中的最新更新的数据(除非隔离级别时读未提交)
  
  * PROPAGATION_MANDATORY：强制要求当前存在一个事务。如果不存在，则抛出异常。
  
    如果一个方法需要事务的支持，但自身又不管理事务提交或回滚，则适合使用该隔离级别。
  
  * PROPAGATION_REQUIRES_NEW：不管当前是否存在事务，都会创建新的事务。如果当前存在事务，会将当前的事务挂起。
  
    如果某个业务对象所作的事情不想影响到外层事务，则适合该传播行为
  
    例如：当前业务方法的错误回滚不想影响到外层事务时
  
  * PROPAGATION_NOT_SUPPORTED：不支持当前事务，再没有事务的情况下执行。如果存在当前事务，当前事务原则上会被挂起。
  
  * PROPAGATION_NEVER：不需要当前存在事务，如果存在事务，则抛出异常
  
  * PROPAGATION_NESTED：如果存在当前事务，则在当前事务的一个嵌套事务(在进入该方法是，设置一个外部事务的savepoint)中执行，如果不存在当前事务，则创建新的事务，再新创建的事务中执行。
  
    该传播行为创建的嵌套事务时外层事务的子事务，当子事务活动时，外层事务不会挂起，而是继续活动
  
* 是否为只读事务:isReadOnly()

* 事务的超时时间:TIMEOUT_DEFAULT

## 继承体系

![TransactionAttribute](https://gitee.com/wangziming707/note-pic/raw/master/img/TransactionAttribute.png)

`TransactionDefinition`的实现类根据使用场景可以划分为两类：

* 适用于编程式事务场景:`DefaultTransactionDefiniton`
* 适用于声明式事务场景:`TransactionAttribute`

### 编程式事务场景

* `DefaultTransactionDefiniton`是`TransactionDefiniton`的默认实现类，它提供了各事务属性的默认值，并可以通过它的setter方法改变这些默认值

* `TransactionTemplate`是Spring提供的进行编程式事务管理的模板方法类，它直接继承了`DefaultTransactionDefiniton`

### 声明式事务场景

* `TransactionAttribute`是继承自`TransactionDefinition`的接口定义，主要面向使用Spring AOP进行声明式事务管理的场合。它自己定义了一个rollbackOn方法：

  ```java
  boolean rollbackOn(Throwable ex);
  ```

  可以指定在抛出哪些异常的情况下可以回滚事务。

* `DefaultTransactionAttribute`是`TransactionAttribute`接口的默认实现类，并同时继承了`DefaultTransactionDefiniton`

* `RuleBasedTransactionAttribute`：允许我们同时指定多个回滚规则

  内部维护了一个`List<RollbackRuleAttribute> rollbackRules;`

  它在调用rollbackOn方法时，传入的异常类型会先和rollbackRules中的回滚规则进行匹配，再决定是否要回滚事务。

* `DelegatingTransactionAttribute `是抽象类，它的目的就是为了被子类化。

# TransactionStatus

TransactionStatus表示整个事务处理过程中的事务状态，我们更多的在编程式事务中使用它

它的继承体系如下：

![TransactionStatus](https://gitee.com/wangziming707/note-pic/raw/master/img/TransactionStatus.png)

* SavepointManager:为Savepoint的支持提供抽象
* TransactionStatus：
  * 继承了SavepointManager，所以也获得了管理Savepoint的能力，从而支持创建内部嵌套事务。
  * 提供了相应的方法查询事务的状态
  * 通过`setRollbackOnly()`方法标记当前事务以使其回滚
* AbstractTransactionStatus：是TransactionStatus的抽象类实现，为其他实现子类提供一些公共设施
* DefaultTransactionStatus：是Spring事务框架内部使用的主要TransactionStatus实现类
* SimpleTransactionStatus：没有使用，仅测试用

# PlatformTransactionManager

PlatformTransactionManager是Spring事务抽象框架的核心组件，通过它来开启事务和提交回滚事务以界定事务边界。

它的定义如下:

~~~java
public interface PlatformTransactionManager extends TransactionManager {

	TransactionStatus getTransaction(@Nullable TransactionDefinition definition)
			throws TransactionException;

	void commit(TransactionStatus status) throws TransactionException;

	void rollback(TransactionStatus status) throws TransactionException;

}
~~~

## 继承体系

PlatformTransactionManager的整个抽象体系基于策略模式，由PlatformTransactionManager对事务界定进行统一抽象，而具体的界定策略的实现由具体的实现类。它的实现类可以划分为面向局部事务和分布式事务两个分支，而它的具体实现类基本会先继承AbstractPlatformTransactionManager抽象类，间接继承PlatformTransactionManager

## 概念

* transaction object :承载了当前事务的必要信息，PlatformTransactionManager实现类可以根据transaction object所提供的信息来决定如何处理当前事务
* TransactionSynchronization：是可以注册到事务处理过程中的回调接口，像是事务处理的事件监听器，当事务发生回滚，提交等事件时，会调用TransactionSynchronization上的一些方法来执行相应的回调逻辑
* TransactionSynchronizationManager:通过它来管理和持有TransactionSynchronization、当前事务状态以及具体的事务资源。

## AbstractPlatformTransactionManager

AbstractPlatformTransactionManager作为PlatformTransactionManager实现类的抽象父类，以模板方法的方式封装了固定的事务处理逻辑，它替各个子类实现了以西固定的事务内部处理逻辑：

* 判断是否存在当前事务，根据判断结果执行不同的处理逻辑
* 结合当前是否存在当前事务的情况，根据TransactionDefinition中指定的传播行为的不同语义执行后续逻辑
* 根据情况挂起或者恢复事务
* 提交事务之前检查readOnly字段是否被设置，如果是的话，以事务的回滚代替事务的提交；
* 在事务回滚的情况下，清理并恢复事务状态
* 如果事务的Synchronization处于active状态，在事务处理的指定节点触发注册的Synchronization回调接口

这些固定的事务内部处理逻辑大都体现在以下几个主要的模板方法中：

~~~java
public final TransactionStatus getTransaction( TransactionDefinition definition)
public final void rollback(TransactionStatus status) ;
public final void commit(TransactionStatus status);

protected final SuspendedResourcesHolder suspend(Object transaction)
protected final void resume( Object transaction,  SuspendedResourcesHolder resourcesHolder)
~~~

### getTransaction()

该方法的主要目的是开启一个事务，在这之前需要判断之前是否存在事务。根据情况根据传播行为的具体语义处理事务状态。

该方法的主要处理逻辑如下：

~~~java
@Override
public final TransactionStatus getTransaction(@Nullable TransactionDefinition definition)
    throws TransactionException {

    TransactionDefinition def = (definition != null ? definition : TransactionDefinition.withDefaults());//1

    Object transaction = doGetTransaction();//2
    boolean debugEnabled = logger.isDebugEnabled();

    if (isExistingTransaction(transaction)) {//3
        return handleExistingTransaction(def, transaction, debugEnabled);
    }

    if (def.getTimeout() < TransactionDefinition.TIMEOUT_DEFAULT) {
        throw new InvalidTimeoutException("Invalid transaction timeout", def.getTimeout());
    }

    if (def.getPropagationBehavior() == TransactionDefinition.PROPAGATION_MANDATORY) {
        throw new IllegalTransactionStateException(
            "No existing transaction found for transaction marked with propagation 'mandatory'");
    }
    else if (def.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRED ||
             def.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW ||
             def.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) {
        SuspendedResourcesHolder suspendedResources = suspend(null);
        if (debugEnabled) {
            logger.debug("Creating new transaction with name [" + def.getName() + "]: " + def);
        }
        try {
            return startTransaction(def, transaction, debugEnabled, suspendedResources);
        }
        catch (RuntimeException | Error ex) {
            resume(null, suspendedResources);
            throw ex;
        }
    }
    else {
        if (def.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT && logger.isWarnEnabled()) {
            logger.warn("Custom isolation level specified but no actual transaction initiated; " +
                        "isolation level will effectively be ignored: " + def);
        }
        boolean newSynchronization = (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS);
        return prepareTransactionStatus(def, null, true, newSynchronization, debugEnabled, null);
    }
}
~~~

~~~java
private TransactionStatus handleExistingTransaction(
    TransactionDefinition definition, Object transaction, boolean debugEnabled)
    throws TransactionException {
	
    if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NEVER) {//4
        throw new IllegalTransactionStateException(
            "Existing transaction found for transaction marked with propagation 'never'");
    }

    if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NOT_SUPPORTED) {//5
        if (debugEnabled) {
            logger.debug("Suspending current transaction");
        }
        Object suspendedResources = suspend(transaction);
        boolean newSynchronization = (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS);
        return prepareTransactionStatus(
            definition, null, false, newSynchronization, debugEnabled, suspendedResources);
    }

    if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW) {
        if (debugEnabled) {
            logger.debug("Suspending current transaction, creating new transaction with name [" +
                         definition.getName() + "]");
        }
        SuspendedResourcesHolder suspendedResources = suspend(transaction);
        try {
            return startTransaction(definition, transaction, debugEnabled, suspendedResources);
        }
        catch (RuntimeException | Error beginEx) {
            resumeAfterBeginException(transaction, suspendedResources, beginEx);
            throw beginEx;
        }
    }

    if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) {
        if (!isNestedTransactionAllowed()) {
            throw new NestedTransactionNotSupportedException(
                "Transaction manager does not allow nested transactions by default - " +
                "specify 'nestedTransactionAllowed' property with value 'true'");
        }
        if (debugEnabled) {
            logger.debug("Creating nested transaction with name [" + definition.getName() + "]");
        }
        if (useSavepointForNestedTransaction()) {
            DefaultTransactionStatus status =
                prepareTransactionStatus(definition, transaction, false, false, debugEnabled, null);
            status.createAndHoldSavepoint();
            return status;
        }
        else {
            return startTransaction(definition, transaction, debugEnabled, null);
        }
    }
    if (debugEnabled) {
        logger.debug("Participating in existing transaction");
    }
    if (isValidateExistingTransaction()) {
        if (definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT) {
            Integer currentIsolationLevel = TransactionSynchronizationManager.getCurrentTransactionIsolationLevel();
            if (currentIsolationLevel == null || currentIsolationLevel != definition.getIsolationLevel()) {
                Constants isoConstants = DefaultTransactionDefinition.constants;
                throw new IllegalTransactionStateException("Participating transaction with definition [" +definition + "] specifies isolation level which is incompatible with existing transaction: " +(currentIsolationLevel != null ?isoConstants.toCode(currentIsolationLevel, DefaultTransactionDefinition.PREFIX_ISOLATION) :"(unknown)"));
            }
        }
        if (!definition.isReadOnly()) {
            if (TransactionSynchronizationManager.isCurrentTransactionReadOnly()) {
                throw new IllegalTransactionStateException("Participating transaction with definition [" +definition + "] is not marked as read-only but existing transaction is");
            }
        }
    }
    boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER);
    return prepareTransactionStatus(definition, transaction, false, newSynchronization, debugEnabled, null);
}
~~~

1. 检查参数合法性，如果definition参数为空，则创建一个默认的TransactionDefinition实例以提供默认的事务定义数据
2. 获取transaction object
   * 获取的transaction object类型由具体的实现类来决定
   * doGetTransaction()方法是需要子类来实现的abstract

3. 根据获取的transaction object判断是否存在当前事务；isExistingTransaction()方法由实现类实现，判断当前是否存在事务

* 如果isExistingTransaction()方法返回true，即存在事务，调用handleExistingTransaction()方法统一处理存在当前事务的情况
  4. 如果definition定义的传播行为是PROPAGATION_NEVER，将抛出异常并退出
  5. 如果definition定义的传播行为是PROPAGATION_NOT_SUPPORTED，则挂起当前事务，并返回



* 如果isExistingTransaction()方法返回false继续向下走







## 面向局部事务

Spring为各种数据访问框架技术提供了现成的PlatformTransactionManager支持：

| 数据访问技术 | PlatformTransactionManager实现类 |
| ------------ | -------------------------------- |
| JDBC         | DataSourceTransactionManager     |
| JPA          | JpaTransactionManager            |
| JMS          | JmsTransactionManager            |
| ……           | ……                               |

## 面向分布式事务

JtaTransactionManager是Spring提供的支持分布式事务

==todo==





# 其他

## maven依赖

~~~xml
<!--做spring事务用到的-->
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-tx</artifactId>
    <version>5.2.5.RELEASE</version>
</dependency>
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-jdbc</artifactId>
    <version>5.2.5.RELEASE</version>
</dependency>
~~~



## 非注解配置

~~~xml
<!--配置事务管理器类-->
<bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
    <!--这里为事务管理器类提供数据源，数据源会在mybatis与spring整合时，由spring提供-->
    <property name="dataSource" ref=""/>
</bean>

<!--配置事务aop-->
<aop:config>
    <!--配置切点-->
    <aop:pointcut id="allMethodPointcut" expression="execution(* com.bjpn..service.*.*(..))"/>
    <!--配置通知器-->
    <aop:advisor advice-ref="txAdvice" pointcut-ref="allMethodPointcut"/>
</aop:config>

<!--配置事务传播行为-->
<tx:advice id="txAdvice">
    <tx:attributes>
        <tx:method name="add*" propagation="REQUIRED" rollback-for="Exception"/>
        <tx:method name="save*" propagation="REQUIRED" rollback-for="Exception"/>
        <tx:method name="edit*" propagation="REQUIRED" rollback-for="Exception"/>
        <tx:method name="update*" propagation="REQUIRED" rollback-for="Exception"/>
        <tx:method name="delete*" propagation="REQUIRED" rollback-for="Exception"/>
        <tx:method name="remove*" propagation="REQUIRED" rollback-for="Exception"/>
        <tx:method name="modify*" propagation="REQUIRED" rollback-for="Exception"/>
        <tx:method name="get*" propagation="SUPPORTS" read-only="true"/>
        <tx:method name="find*" propagation="SUPPORTS" read-only="true"/>
    </tx:attributes>
</tx:advice>
~~~



## 注解配置

~~~xml
<!-- 可通过注解控制事务 -->
<tx:annotation-driven transaction-manager="transactionManager" />
<bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
    <property name="dataSource" ref="" />   
</bean>
~~~



~~~java
//标示当前类需要事务
@Transactional
@Service
public class UserServiceImpl implements UserService {
    @Override
     @Transactional(propagation = Propagation.REQUIRED,rollbackFor = {Exception.class})
    public boolean transferMoney(String code, String code1, double money) {
        //加钱  修改数据库
        //减钱  修改数据库
        //同时完成  业务才完成
        return false;
    }

    @Override
    //配置当前方法的事务  查询事务  可以有  也可以没有
    @Transactional(propagation = Propagation.SUPPORTS,readOnly = true)
    public void findAll() {

    }

    @Override
    //没有事务会创建事务  有多个事务会合并事务
    @Transactional(propagation = Propagation.REQUIRED,rollbackFor = {Exception.class})
    public void addMoney() {

    }
}
~~~









