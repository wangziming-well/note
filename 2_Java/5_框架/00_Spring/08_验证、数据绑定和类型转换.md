# 验证

Spring提供一个 `org.springframework.validation.Validator` 接口，它通过下面两个方法为类提供验证：

- `supports(Class)`: 指示提供的`Class`实例是否可以被这个 `Validator` 验证
- `validate(Object, org.springframework.validation.Errors)`: 验证给定的对象，如果出现验证不通过，则用给定的 `Errors` 对象登记不通过原因。

考虑下面对象：

~~~java
public class Person {
    private String name;
    private int age;
    // the usual getters and setters...
}
~~~

实现一个对`Person`实例验证的 `Validator`：

~~~java
public class PersonValidator implements Validator {

    /**
     * This Validator validates only Person instances
     */
    public boolean supports(Class clazz) {
        return Person.class.equals(clazz);
    }

    public void validate(Object obj, Errors e) {
        ValidationUtils.rejectIfEmpty(e, "name", "name.empty");
        Person p = (Person) obj;
        if (p.getAge() < 0) {
            e.rejectValue("age", "negativevalue");
        } else if (p.getAge() > 110) {
            e.rejectValue("age", "too.darn.old");
        }
    }
}
~~~

我们可以通过`Errors`的多个重载方法`reject()`和`rejectValue()`方法登记拒绝信息；`rejectValue()`表示对象的某个指定字段验证不通过，而`reject()`表示整个对象全局验证不通过。

`ValidationUtils`工具类为我们验证时登记拒绝信息提供方便，例如 `rejectIfEmpty(..)` 在指定属性为`null`或者空字符串时进行拒绝。

对于有对象属性的对象，即嵌套对象。当然可以用一个`Validator`来验证它，但是最好为每个嵌套类对象单独设计一个`Validator`实现。

例如对于下面嵌套对象：

~~~java

public class Customer {
    String firstName;
    String surname;
    Address address;
    //......
}
~~~

其中`Address`也是一个独立对象，并且已经有一个独立的 `AddressValidator`实现。可以在 `CustomerValidator` 中重用 `AddressValidator` ，具体方法如下：

~~~java
public class CustomerValidator implements Validator {

    private final Validator addressValidator;

    public CustomerValidator(Validator addressValidator) {
        if (addressValidator == null) {
            throw new IllegalArgumentException("The supplied [Validator] is " +
                "required and must not be null.");
        }
        if (!addressValidator.supports(Address.class)) {
            throw new IllegalArgumentException("The supplied [Validator] must " +
                "support the validation of [Address] instances.");
        }
        this.addressValidator = addressValidator;
    }

    /**
     * This Validator validates Customer instances, and any subclasses of Customer too
     */
    public boolean supports(Class clazz) {
        return Customer.class.isAssignableFrom(clazz);
    }

    public void validate(Object target, Errors errors) {
        ValidationUtils.rejectIfEmptyOrWhitespace(errors, "firstName", "field.required");
        ValidationUtils.rejectIfEmptyOrWhitespace(errors, "surname", "field.required");
        Customer customer = (Customer) target;
        try {
            errors.pushNestedPath("address"); //将路径上下文切换到子路径address上
            ValidationUtils.invokeValidator(this.addressValidator, customer.getAddress(), errors); //使用addressValidator对属性address验证
        } finally {
            errors.popNestedPath(); //将路径上下文切回到父路径
        }
    }
}
~~~

# PropertyEditor

Spring使用 java内置的`PropertyEditor` 来实现 `Object` 和 `String` 之间的转换。它属于JavaBean规范。`PropertyEditor`属性编辑器的主要功能就是将外部的设置值转换为JVM内部的对应类型，所以属性编辑器其实就是一个类型转换器。它主要通过下面方法实现外部设置值(String字符串)和类Class的转换：

~~~java
public interface PropertyEditor {
	void setValue(Object value); //以Class形式设置属性
    Object getValue(); //以Class形式获取属性
    String getAsText(); //以String形式获取属性
    void setAsText(String text) throws java.lang.IllegalArgumentException; //以String形式设置属性
}
~~~

例如想要通过`ClassEditor`实现`String`到`Class`的转换，可以先调用`setAsText()`再调用`getValue()`：

~~~java
ClassEditor classEditor = new ClassEditor();
classEditor.setAsText("org.springframework.web.servlet.mvc.support.DefaultHandlerExceptionResolver");
Class value =(Class) classEditor.getValue();
System.out.println(value);
~~~

类似的，要实现`Class`到`String`的转换，就先调用`setValue()`再调用`getAsText()`。

在Spring中可能在以下场景使用`PropertyEditor`：

* 通过`PropertyEditor`在Bean上设置属性，我们在Spring的XML配置文件上使用`String`字符串为bean对象设置属性，那么Spring会尝试用`PropertyEditor`将字符串转换为需要的属性
* 在Spring MVC中，解析HTTP请求参数(字符串)是通过使用各种 `PropertyEditor` 实现完成

Spring在`org.springframework.beans.propertyeditors`包中内置了许多 `PropertyEditor` 实现：

| 类                        | 说明                                                         |
| :------------------------ | :----------------------------------------------------------- |
| `ByteArrayPropertyEditor` | 字节数组的编辑器。将字符串转换为其相应的字节表示。默认由 `BeanWrapperImpl` 注册。 |
| `ClassEditor`             | 将代表类的字符串解析为实际的类，反之亦然。当没有找到一个类时，会抛出一个 `IllegalArgumentException`。默认情况下，通过 `BeanWrapperImpl` 注册。 |
| `CustomBooleanEditor`     | 用于 `Boolean` 属性的可定制的属性编辑器。默认情况下，由 `BeanWrapperImpl` 注册，但可以通过注册它的一个自定义实例作为自定义编辑器来重写。 |
| `CustomCollectionEditor`  | 集合的属性编辑器，将任何源 `Collection` 转换为一个给定的目标 `Collection` 类型。 |
| `CustomDateEditor`        | `java.util.Date` 的可定制属性编辑器，支持自定义 `DateFormat`。默认情况下没有注册。必须根据需要由用户注册适当的格式（format）。 |
| `CustomNumberEditor`      | 可定制的属性编辑器，用于任何 `Number` 子类，如 `Integer`、`Long`、`Float` 或 `Double`。默认情况下，由 `BeanWrapperImpl` 注册，但可以通过注册它的一个自定义实例作为自定义编辑器来重写。 |
| `FileEditor`              | 将字符串解析为 `java.io.File` 对象。默认情况下，由 `BeanWrapperImpl` 注册。 |
| `InputStreamEditor`       | 单向属性编辑器，可以接受一个字符串并产生（通过中间的 `ResourceEditor` 和 `Resource`）一个 `InputStream`，这样 `InputStream` 属性可以直接设置为字符串。注意，默认用法不会为你关闭 `InputStream`。默认情况下，由 `BeanWrapperImpl` 注册。 |
| `LocaleEditor`            | 可以将字符串解析为 `Locale` 对象，反之亦然（字符串格式为 `[language]_[country]_[variant]`，与 `Locale` 的 `toString()` 方法相同）。也接受空格作为分隔符，作为下划线的替代。默认情况下，由 `BeanWrapperImpl` 注册。 |
| `PatternEditor`           | 可以将字符串解析为 `java.util.regex.Pattern` 对象，反之亦然。 |
| `PropertiesEditor`        | 可以将字符串（格式为 `java.util.Properties` 类的javadoc中定义的格式）转换为 `Properties` 对象。默认情况下，由 `BeanWrapperImpl` 注册。 |
| `StringTrimmerEditor`     | trim 字符串的属性编辑器。可选择允许将空字符串转换为 `null` 值。默认情况下没有注册 - 必须由用户注册。 |
| `URLEditor`               | 可以将一个 URL 的字符串表示解析为一个实际的 `URL` 对象。默认情况下，由 `BeanWrapperImpl` 注册。 |

如果如果 `PropertyEditor` 类与它们所处理的类在同一个包中，并且 `PropertyEditor`名称是该类名后缀一个 `Editor`，那么Spring会自动发现这些类。例如：如果有以下的类和包结构，那么可以让 `SomethingEditor` 类被识别并作为 `Something` 类型属性的 `PropertyEditor` 使用：

~~~java
com
  chank
    pop
      Something
      SomethingEditor // the PropertyEditor for the Something class
~~~

## 注册自定义`PropertyEditor`

在将配置字符串设置为Bean属性时， Spring IoC容器会使用标准JavaBeans `PropertyEditor` 实现把这些字符串转换成属性的复杂类型。Spring 预先注册了一些自定义的`PropertyEditor`（例如，将表示为字符串的类名转换为 `Class` 对象）

若要注册其他自定义的 `PropertyEditors`，一种方法时手动调用`ConfigurableBeanFactory.registerCustomEditor()`注册，这种方法通常不方便，也不推荐。

### 使用`CustomEditorConfigurer`

稍微方便一些的方式是使用`CustomEditorConfigurer`，它是一个`BeanFactoryPostProcessor`，可以在容器初始化时注册指定的`PropertyEditors`

一个注册`PropertyEditor`自定义的例子,考虑下面Bean类：

~~~java
package example;

public class ExoticType {

    private String name;

    public ExoticType(String name) {
        this.name = name;
    }
}

public class DependsOnExoticType {

    private ExoticType type;

    public void setType(ExoticType type) {
        this.type = type;
    }
}
~~~

如果需要注册一个`DependsOnExoticType`,需要下面配置：

~~~xml
<bean id="sample" class="example.DependsOnExoticType">
    <property name="type" >
        <bean class="example.ExoticType">
            <property name="name" value="aNameForExoticType" />
        </bean>
    </property>
</bean>
~~~

为了简化这种配置，可以实现一个`ExoticType`对应的`PropertyEditor`:

~~~java
package example;

import java.beans.PropertyEditorSupport;

// converts string representation to ExoticType object
public class ExoticTypeEditor extends PropertyEditorSupport {

    public void setAsText(String text) {
        setValue(new ExoticType(text.toUpperCase()));
    }
}
~~~

将其通过`CustomEditorConfigurer`注册到容器中：

~~~xml
<bean class="org.springframework.beans.factory.config.CustomEditorConfigurer">
    <property name="customEditors">
        <map>
            <entry key="example.ExoticType" value="example.ExoticTypeEditor"/>
        </map>
    </property>
</bean>
~~~

这样此时想要注册一个`DependsOnExoticType`,只需要下面配置：

~~~xml
<bean id="sample" class="example.DependsOnExoticType">
    <property name="type" value="aNameForExoticType"/>
</bean>
~~~

### 使用 `PropertyEditorRegistrar`

另一种在Spring 容器中注册`PropertyEditor`的机制是创建和使用`PropertyEditorRegistrar`,特别是需要在几种不同的情况下使用同一组`PropertyEditor`的场景下，这种机制会很有用。此时可以实现一个`PropertyEditorRegistrar`，并在多种情况下重复使用这个注册器。

这个`PropertyEditorRegistrar`注册器和 `PropertyEditorRegistry`注册表协同工作。`PropertyEditorRegistrar`负责向`PropertyEditorRegistry`中注册指定的多个`PropertyEditor`。`BeanWrapper`和`DataBinder`都实现了`PropertyEditorRegistry`,都是属性编辑器的注册表。

可以通过`CustomEditorConfigurer.setPropertyEditorRegistrars(..)`向其中设置一个`PropertyEditorRegistrar` 实例。以这种方式添加到 `CustomEditorConfigurer` 的 `PropertyEditorRegistrar` 实例可以很容易地与 `DataBinder` 和Spring MVC控制器共享。

此外若使用 `PropertyEditorRegistrar` ，那么`PropertyEditor`就不需要考虑同步情况，因为 `PropertyEditorRegistrar` 会为每个bean build 创建新的 `PropertyEditor` 实例。

一个自定义 `PropertyEditorRegistrar` 的实现示例：

~~~java
package com.foo.editors.spring;

public final class CustomPropertyEditorRegistrar implements PropertyEditorRegistrar {

    public void registerCustomEditors(PropertyEditorRegistry registry) {

        // it is expected that new PropertyEditor instances are created
        registry.registerCustomEditor(ExoticType.class, new ExoticTypeEditor());

        // you could register as many custom property editors as are required here...
    }
}
~~~

下面例子通过 `CustomEditorConfigurer`，来配置 `CustomPropertyEditorRegistrar` 实例，以配置到容器：

~~~xml
<bean class="org.springframework.beans.factory.config.CustomEditorConfigurer">
    <property name="propertyEditorRegistrars">
        <list>
            <ref bean="customPropertyEditorRegistrar"/>
        </list>
    </property>
</bean>
<bean id="customPropertyEditorRegistrar" class="com.foo.editors.spring.CustomPropertyEditorRegistrar"/>
~~~

# Spring类型转换

`org.springframework.core.convert`包提供了一个通用的类型转换框架。在Spring容器中，这个框架可以作为 `PropertyEditor` 实现的替代，将外部配置的字符串转换为Bean所需的属性类型。

## `Converter`

Spring类型转换的核心接口是`Converter`，其定义如下：

~~~java
package org.springframework.core.convert.converter;

public interface Converter<S, T> {

    T convert(S source);
}
~~~

其中泛型`S`为转换的原类型，泛型`T`为转换的目标类型。

 `StringToInteger` 类，它是一个典型的 `Converter` 实现：

~~~java
package org.springframework.core.convert.support;

final class StringToInteger implements Converter<String, Integer> {

    public Integer convert(String source) {
        return Integer.valueOf(source);
    }
}
~~~

## `ConverterFactory`

如果需要整个类层次结构的转换逻辑时（例如，当从 `String` 转换到 `Enum` 对象时），可以实现`ConverterFactory`，其定义为：

~~~java
package org.springframework.core.convert.converter;

public interface ConverterFactory<S, R> {

    <T extends R> Converter<S, T> getConverter(Class<T> targetType);
}
~~~

泛型`S`要转换的类型，`R` 是定义可以转换的类的范围的基类型。实现 `getConverter(Class<T>)`，其中T是R的一个子类。

以 `StringToEnumConverterFactory` 为例：

~~~java
package org.springframework.core.convert.support;

final class StringToEnumConverterFactory implements ConverterFactory<String, Enum> {

    public <T extends Enum> Converter<String, T> getConverter(Class<T> targetType) {
        return new StringToEnumConverter(targetType);
    }

    private final class StringToEnumConverter<T extends Enum> implements Converter<String, T> {

        private Class<T> enumType;

        public StringToEnumConverter(Class<T> enumType) {
            this.enumType = enumType;
        }

        public T convert(String source) {
            return (T) Enum.valueOf(this.enumType, source.trim());
        }
    }
}
~~~

## ``GenericConverter``
