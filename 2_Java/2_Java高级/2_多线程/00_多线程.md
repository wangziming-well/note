

# 线程同步

* 多线程经常会用于操作共享的资源，而线程之间对资源的抢夺会造成数据的安全问题。

    有多条线程操作更新共享数据，且操作共享数据的语句不止一条。

* 原因：当某个线程的任务还没有执行结束，其他线程就进入线程任务代码造成的

* 解决方案，上锁：
    * synchronized同步代码块
    * synchronized同步方法
    * Lock锁(用ReentrantLock类结合Condition实例可以实现选择性通知)

## Synchronized关键字

* 同步代码块

~~~java
synchronized (锁对象){
    //........
}
~~~

* 同步方法

当方法中的所有代码都是操作共享数据时再使用（为了效率）

~~~java
public [static] synchronized methodName(){
    //操作共享数据的代码；
}
~~~

同步方法有一个默认的锁对象，不需要手动指定；

## Lock接口

### 描述

Lock能替代synchronized方法与synchronized代码块，实现代码同步

同时能实现代码同步和等待唤醒解耦

### 方法

* `void lock() `
    获取锁。 

* `void unlock() `
    释放锁。 
* `Condition newCondition() `
    返回绑定到此 Lock 实例的新 Condition 实例。 

### 实现类

ReentrantLock

ReentrantReadWriteLock.ReadLock

ReentrantReadWriteLock.WriteLock

## Condition 接口

### 描述

Condition替代了对象监视器（即锁对象）方法（等待、唤醒）

并提供了精准唤醒服务

### 方法

* `void await() `
        造成当前线程在接到信号或被中断之前一直处于等待状态。 

* `void signal() `
        唤醒一个等待线程。 

* `void signalAll() `
        唤醒所有等待线程。 

## 死锁

线程的任务没有执行结束，但是线程对象基于某些原因无法继续执行任务，而导致线程阻塞

进入死锁的情况：

* 两个线程需要两把锁才能执行任务时，每个线程只抢到了一把锁
* 在线程等待唤醒中，因为唤醒时随机的，可能会出现所有线程都等待在线程常量池中的情况

# 多线程下的单例模式

## 饿汉式

多线程下仍然保持单例

~~~java
public class Single{
    private Single(){}
    oruvate static final Single s = new Single();
    public static Single getInstance(){
        return s;
    }
}
~~~

## 懒汉式

多线程模式下不能保证唯一，

~~~JAVA
public class Single {
    private Single(){}
    private static Single s;
    public static Single getInstance(){
        if (s ==null){
            s = new Singel();
        }
        return s;
    }
}
~~~

需要加锁:

~~~java
public class Single {
    private Single(){}
    private static Single s;
    public static Single getInstance(){
        if(s ==null){
            synchronized(lock){
                if (s ==null){
            		s = new Singel();
        		}
            }
        }
        return s;
    }
}
~~~



# 生产消费模拟

资源类：

~~~java
public class Resource {
    
    private String[] goods = new String[1];
    private int counter = 0;
    
    Lock lock = new ReentrantLock();
    Condition get_con = lock.newCondition();
    Condition set_con = lock.newCondition();

    public void get() throws InterruptedException {
        while (true) {
            try {
                lock.lock();
                if(goods[0]==null){
                    get_con.await();
                }
                System.out.println(Thread.currentThread().getName() 
                                   + "获得商品" + goods[0]);
                goods[0] = null;
                Thread.sleep(1);
                set_con.signal();
            }finally {
                lock.unlock();
            }
        }
    }

    public void set() throws InterruptedException {
        while (true) {
            try {
                lock.lock();
                if(goods[0] !=null){
                    set_con.await();
                }
                counter++;
                System.out.println(Thread.currentThread().getName() 
                                   + "补充商品:" + "饮料" + counter);
                goods[0] = "饮料" + counter;
                Thread.sleep(1);
                get_con.signal();
            }finally {
                lock.unlock();
            }
        }
    }
}
~~~

消费者类

```java
public class Consumer implements Runnable{
    private Resource resource;
    public Consumer() {
    }
    public Consumer(Resource resource) {
        this.resource = resource;
    }
    @Override
    public void run() {
        try {
            resource.get();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```

生成者类

```java
public class Producer implements  Runnable {
    private Resource resource;
    public Producer() { }
    public Producer(Resource resource) {
        this.resource = resource;
    }

    @Override
    public void run() {
        try {
            resource.set();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```

测试单元

```java
public static void test() {
    Resource resource = new Resource();

    Producer producer1 = new Producer(resource);
    Producer producer2 = new Producer(resource);
    Consumer consumer1 = new Consumer(resource);
    Consumer consumer2 = new Consumer(resource);
    
    Thread t_producer1 = new Thread(producer1, "producer1");
    Thread t_producer2 = new Thread(producer2, "producer2");
    Thread t_consumer1 = new Thread(consumer1, "consumer1");
    Thread t_consumer2 = new Thread(consumer2, "consumer2");
    
    t_consumer1.start();
    t_consumer2.start();
    t_producer1.start();
    t_producer2.start();
}
```

# 线程池

## 描述

* 一个用于保存线程对象的容器

* 线程池中的线程对象可以复用，当有需要执行的线程任务是，只需要从线程池中调用处于闲置状态下的线程对象执行任务，当任务执行结束后，将线程再加载进线程池

* 线程池底层是队列数据结构

## 优点

* 降低资源消耗，不需要频繁地创建和销毁线程
* 提高响应速度（节省了创建线程对象的时间）

* 方便对线程对象的统一管理

## 问题

* 对SingleThread和FixedThread来说，他们有阻塞队列无界，队列很大，很有可能导致JVM出现OOM（Out Of Memory）异常，即内存资源耗尽

* 对ScheduledThread和CachedThread来说， 线程数量无上界，会导致创建大量的线程，从而导致OOM

## 线程池继承关系

* Executor接口
    * ExecutorService

* Executors类：线程池工厂类

## Executor接口

### 描述

是线程池的顶层父接口

因为提供的功能少，所以我们一般不使用

## ExecutorService

### 描述

使用线程池的主要类

### 方法

* Future<?> submit(Runnable task) 
              提交一个 Runnable 任务用于执行，并返回一个表示该任务的 Future。 

## Executors

### 描述

生成线程池executor的工厂类

### 方法

* `static ExecutorService newSingleThreadExecutor()  `

    创建单线程化线程池

    特点：

    - 单线程化的线程池中的任务是按照提交的次序顺序执行的
    - 只有一个线程的线程池
    - 池中的唯一线程的存活时间是无限的
    - 当池中的唯一线程正繁忙时，新提交的任务实例会进入内部的阻塞队列中，并且其阻塞队列是无界的

    适用场景：

    * 任务按照提交次序，一个任务一个任务地逐个执行的场景

* `static ExecutorService newFixedThreadPool(int nThreads) `
        创建一个可重用固定线程数的线程池

    特点：

    * 如果线程数没有达到“固定数量”，每次提交一个任务线程池内就创建一个新线程，直到线程达到线程池固定的数量
    * 线程池的大小一旦达到“固定数量”就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程
    * 在接收异步任务的执行目标实例时，如果池中的所有线程均在繁忙状态，新任务会进入阻塞队列中（无界的阻塞队列）

    适用场景：

    - 需要任务长期执行的场景
    - CPU密集型任务

* `static ExecutorService newCachedThreadPool() `

    可缓存线程池

    特点：

    * 在接收新的异步任务target执行目标实例时，如果池内所有线程繁忙，此线程池就会添加新线程来处理任务
    * 线程池不会对线程池大小进行限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小
    * 如果部分线程空闲，也就是存量线程的数量超过了处理任务数量，就会回收空闲（60秒不执行任务）线程

    适用场景：

    * 需要快速处理突发性强、耗时较短的任务场景

* `static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) `
          
          可调度线程池
          
          - 延时性
          - 周期性
