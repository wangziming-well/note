# 线程组

线程组用来表示一组相似(相关)的线程。线程与线程组之间的关系类似于文件与文件夹之间的关系：一个文件总是位于特定的文件夹中，而一个文件夹可以包含多个文件以及其他文件夹。

类似地，一个线程组可以包含多个线程以及其他线程组。一个线程组包含其他线程组时，该线程组被称为这些线程组的父线程组。Thread类有几个构造器允许我们在创建线程的时候指定线程所属的线程组。如果创建线程组的时候没有指定线程组，那么这个线程就属于其父线程所属的线程组。

由于JVM在创建main线程时会为其指定一个线程组，所以Java平台中任何一个线程都有一个线程组与之关联，这个线程组可以通过`Thread.getThreadGroup()`调用来获取

`ThreadGroup`最初是出于安全考虑被设计用来隔离区分一个JVM中不同的小应用程序的。但是它没有实现这一目标，它所实现的许多方法是有缺陷的，另外这些方法也不是很常用

实际上如果我们需要将一些线程归为一组，可以考虑直接将这些线程存入一个数组或者集合对象中，这样的处理需要注意内存泄露问题。如果仅仅是为了将一些线程与其他线程区分开来，可以通过线程的命名来实现。

多数情况喜爱，我们可以忽略线程组这一概念以及线程组的存在。

# 线程的未捕获异常与监控

如果线程的`run`方法抛出未被捕获的异常(Uncaught Exception),那么`run`方法将退出，相应线程也提前终止。

对于这种情况，JDK提供了回调以监控/补救`run`方法的异常退出：

JDK1.5引入`Thread.UncaughtExceptionHandler`函数式接口：

~~~java
@FunctionalInterface
public interface UncaughtExceptionHandler {
    void uncaughtException(Thread t, Throwable e);
    //t:异常终止的线程本身
    //e:导致线程提前终止的异常
}
~~~

我们在`uncaughtException()`方法中可以做一些有意义的事，比如将异常终止的相关信息记录到日志文件中，或者未异常终止的线程创建并启动一个替代线程。

我们可以在一个线程启动前调用`Thread.setUncaughtExceptionHandler(UncaughtExceptionHandler)`方法为当前线程关联一个`UncaughtExceptionHandler`实例。当线程因为异常提前终止时，JVM会调用该`UncaughtExceptionHandler`实例的`uncaughtException()`方法

实际上JVM会在线程抛出未捕获异常终止时调用`Thread`类的下面方法：

~~~Java
//Dispatch an uncaught exception to the handler. This method isintended to be called only by the JVM.
private void dispatchUncaughtException(Throwable e) {
    getUncaughtExceptionHandler().uncaughtException(this, e);
}
~~~

而`Thread.getUncaughtExceptionHandler()`定义如下：

~~~java
public UncaughtExceptionHandler getUncaughtExceptionHandler() {
    return uncaughtExceptionHandler != null ?
        uncaughtExceptionHandler : group;
}
~~~

也就说如果线程启动时没有调用`setUncaughtExceptionHandler()`关联`UncaughtExceptionHandler`时，那么将调用该线程所属的线程组`ThreadGroup`的`uncaughtException()`，因为`ThreadGroup`签名如下：

~~~java
public ThreadGroup implements Thread.UncaughtExceptionHandler
~~~

所以`ThreadGroup`也是一个`UncaughtExceptionHandler`，它的`uncaughtException()`定义如下：

~~~java
public void uncaughtException(Thread t, Throwable e) {
    if (parent != null) {
        parent.uncaughtException(t, e);
    } else {
        Thread.UncaughtExceptionHandler ueh =
            Thread.getDefaultUncaughtExceptionHandler();
        if (ueh != null) {
            ueh.uncaughtException(t, e);
        } else if (!(e instanceof ThreadDeath)) {
            System.err.print("Exception in thread \""
                             + t.getName() + "\" ");//操作1
            e.printStackTrace(System.err);//操作2
        }
    }
}
~~~

该方法逻辑如下：

* 如果该线程组有父线程组，则调用父线程组的`uncaughtException()`方法
* 否则，如果有设置默认的`defaultUncaughtExceptionHandler`，则调用其`uncaughtException()`方法
* 否则，如果抛出的异常类型不是`ThreadDeath`,将在`System.err`管线打印错误的堆栈信息

平时我们看到的错误信息就是由操作1,2打印出来的。

所以一旦我们设置的自定义的`UncaughtExceptionHandler`,或者设置了默认的`defaultUncaughtExceptionHandler`；那么JVM将只执行`uncaughtException()`方法，而不会再执行操作1、2了

~~~java
public class UncaughtExceptionDemo {
    public static void main(String[] args) {
        Thread.currentThread().setUncaughtExceptionHandler((t,e)-> System.err.println("哈哈:"+e.getMessage()));
        throw new NullPointerException("111");
    }
}
//将输出: 哈哈:111
~~~

# 线程工厂

JDK1.5开始，Java标准库类支持创建线程的工厂方法，`ThreadFactory`接口：

~~~java
public interface ThreadFactory {
    Thread newThread(Runnable r);
}
~~~

通过工厂方法`newThread()`，我们可以为线程工厂生产的每一个线程对象添加统一的处理逻辑，例如为线程关联`UncaughtExceptionHandler`，为线程设置有意义的名字，线程创建时打印日志等，以下是一个示例：

~~~java
public class MyThreadFactory implements ThreadFactory {
    final static Logger logger = Logger.getAnonymousLogger();
    private final Thread.UncaughtExceptionHandler ueh;
    private final AtomicInteger threadNumber = new AtomicInteger(1);
    private final String namePrefix;

    public MyThreadFactory(Thread.UncaughtExceptionHandler ueh, String namePrefix) {
        this.ueh = ueh;
        this.namePrefix = namePrefix;
    }

    @Override
    public Thread newThread(@NotNull Runnable r) {
        Thread thread = new Thread(r);
        thread.setUncaughtExceptionHandler(ueh);
        thread.setName(namePrefix + "-" + threadNumber.getAndIncrement());
        logger.fine("new thread created" + thread.getName());
        return thread;
    }
}
~~~

# 线程池

线程是一种昂贵的资源，其开销主要包括以下几个方面：

* 线程的创建和启动开销：与普通对象相比，线程还占用额外的栈空间，线程启动会产线线程调度的开销
* 线程的销毁，销毁也有开销
* 线程调度的开销：会导致上下文切换

* 一个系统能创建的线程总是受限于该系统所拥有的处理器数量

所以我们需要一种有效使用线程的方式——线程池

常见的对象池，如数据库连接池，的实现方式是对象池内部维护一定数量的对象；客户端代码需要对象时就向对象池申请一个对象，用完之后再将对象返还给对象池。这样就实现了对象池中对象的复用:一个对象可以先后为多个客户端提供服务











