多线程中线程不是孤立的，一个线程往往需要其他线程的协作才能完成其待执行的任务。这需要线程有通知其他线程，改变其状态的能力

# 等待与通知

在单线程编程中，程序要执行的操作如果需要满足一定的条件才能执行，那么我们可以将该操作放入if语句体中，这使得目标动作只有在保护条件得以满足的时候才会被执行。

在多线程中这种情形我们有另外一种选择：保护条件未满足可能是暂时的，稍后其他线程可能更新了保护条件涉及的共享变量而使其成立，因此我们可以将当前线程暂停，直到其所需的保护条件得以成立时将其唤醒，如以下伪代码所示：

~~~java
//原子操作
atomic{
    while(保护条件不成立){
		暂停当前线程;
    }
    // 执行目标动作
    doAction();
}
~~~

等待：一个线程因其执行目标动作所需的保护条件未满足而被暂停的过程就被称为等待

通知：一个线程更新了系统状态，使得其他线程所需的保护条件得以满足的时候唤醒哪些被暂停的线程的过程就被称为通知

## wait/notify的作用和用法

在Java中`Object`提供的方法`wait()/wait(long)`和`notify()/notifyAll()`可用于实现等待和通知；`Object`是任意对象的父类，所以使用Java中任意对象都能实现等待和通知

`Object.wait()`的作用是使其执行线程被暂停(生命周期变更未WAITING)

`Object.notify()`的作用是随机唤醒一个被暂停的线程(存在Object对象对应的等待队列中的线程)

### `Object.wait()`

使用`Object.wait()`实现等待的代码模板如下伪代码所示：

~~~java
synchronized(someObject){
    //保护条件是一个包含共享变量的布尔表达式。当这些共享变量被其他线程更新后使相应的保护条件成立时，这些线程会通知等待线程。
    while(保护条件不成立){
        someObject.wait();//暂停当前线程
    }
    //代码执行到这里说明保护条件已满足，执行目标动作
    doAction();
}
~~~

包含上述模板代码的方法被称为受保护方法(Guarded Method)。受保护方法有三个要素:保护条件、暂停当前线程和目标动作

**等待线程**：因执行`someObject.wait()`而被暂停的线程被称为对象的等待线程；someObject上的等待线程可以通过其他线程执行`someObject.notify()/norifyAll()`来唤醒。

**在临界区中调用**：由于一个线程只有在持有一个对象的内部锁的情况下才能调用该对象的wait方法(否则`wait()`会抛出`IllegalMonitorStateException`异常)因此`Object.wait()`调用总是放在相应对象所引导的临界区中；另外等待线程对保护条件的判断以及目标动作的执行必须是个原子操作，否则可能产生竞态。所以目标动作的执行必须和保护条件的判断和`Object.wait()`的调用放在同一个对象所引导的临界区。

**等待线程的唤醒**：其他线程在该线程所需的保护条件成立的时候执行相应的notify方法(即`someobject.notify()`)可以唤醒someObject上的一个任意的等待线程。被唤醒的等待线程在其占用处理器继续运行的时候，需要再次申请someObject对应的内部锁。被唤醒的线程在其再次持有someObject对应的内部锁的情况下继续执行someObject.wait()中剩余的指令，直到wait方法返回。

**在循环中调用**：等待线程只有在保护条件不成立的情况下才会执行`Object.wait()`进行等待，即在执行`Object.wait()`前需要判断保护条件是否成立。另外，等待线程在其被唤醒、继续运行到其再次持有相应对象的内部锁期间，由于其他线程可能抢先获得了内部锁并更新了相关共享变量而导致该线程所需的保护条件又再次不成立，因此`Object.wait()`调用返回之后需要再次判断此时保护田间是否成立。所以对保护条件的判断以及`Object.wait()`调用应该放在循环语句中，以确保目标动作只有在保护条件成立的情况下才能被执行。

### `Object.notify()`

·