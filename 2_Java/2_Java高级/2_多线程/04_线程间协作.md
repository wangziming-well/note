多线程中线程不是孤立的，一个线程往往需要其他线程的协作才能完成其待执行的任务。这需要线程有通知其他线程，改变其状态的能力

# 等待与通知

在单线程编程中，程序要执行的操作如果需要满足一定的条件才能执行，那么我们可以将该操作放入if语句体中，这使得目标动作只有在保护条件得以满足的时候才会被执行。

在多线程中这种情形我们有另外一种选择：保护条件未满足可能是暂时的，稍后其他线程可能更新了保护条件涉及的共享变量而使其成立，因此我们可以将当前线程暂停，直到其所需的保护条件得以成立时将其唤醒，如以下伪代码所示：

~~~java
//原子操作
atomic{
    while(保护条件不成立){
		暂停当前线程;
    }
    // 执行目标动作
    doAction();
}
~~~

等待：一个线程因其执行目标动作所需的保护条件未满足而被暂停的过程就被称为等待

通知：一个线程更新了系统状态，使得其他线程所需的保护条件得以满足的时候唤醒哪些被暂停的线程的过程就被称为通知

## wait/notify的作用和用法

在Java中`Object`提供的方法`wait()/wait(long)`和`notify()/notifyAll()`可用于实现等待和通知；`Object`是任意对象的父类，所以使用Java中任意对象都能实现等待和通知

`Object.wait()`的作用是使其执行线程被暂停(生命周期变更未WAITING)

`Object.notify()`的作用是随机唤醒一个被暂停的线程(存在Object对象对应的等待队列中的线程)

### `Object.wait()`

使用`Object.wait()`实现等待的代码模板如下伪代码所示：

~~~java
synchronized(someObject){
    //保护条件是一个包含共享变量的布尔表达式。当这些共享变量被其他线程更新后使相应的保护条件成立时，这些线程会通知等待线程。
    while(保护条件不成立){
        someObject.wait();//暂停当前线程
    }
    //代码执行到这里说明保护条件已满足，执行目标动作
    doAction();
}
~~~

包含上述模板代码的方法被称为受保护方法(Guarded Method)。受保护方法有三个要素:保护条件、暂停当前线程和目标动作

**等待线程**：因执行`someObject.wait()`而被暂停的线程被称为对象的等待线程；someObject上的等待线程可以通过其他线程执行`someObject.notify()/norifyAll()`来唤醒。

**在临界区中调用**：由于一个线程只有在持有一个对象的内部锁的情况下才能调用该对象的wait方法(否则`wait()`会抛出`IllegalMonitorStateException`异常)因此`Object.wait()`调用总是放在相应对象所引导的临界区中；另外等待线程对保护条件的判断以及目标动作的执行必须是个原子操作，否则可能产生竞态。所以目标动作的执行必须和保护条件的判断和`Object.wait()`的调用放在同一个对象所引导的临界区。

**等待线程的唤醒**：其他线程在该线程所需的保护条件成立的时候执行相应的notify方法(即`someobject.notify()`)可以唤醒someObject上的一个任意的等待线程。被唤醒的等待线程在其占用处理器继续运行的时候，需要再次申请someObject对应的内部锁。被唤醒的线程在其再次持有someObject对应的内部锁的情况下继续执行someObject.wait()中剩余的指令，直到wait方法返回。

**在循环中调用**：等待线程只有在保护条件不成立的情况下才会执行`Object.wait()`进行等待，即在执行`Object.wait()`前需要判断保护条件是否成立。另外，等待线程在其被唤醒、继续运行到其再次持有相应对象的内部锁期间，由于其他线程可能抢先获得了内部锁并更新了相关共享变量而导致该线程所需的保护条件又再次不成立，因此`Object.wait()`调用返回之后需要再次判断此时保护田间是否成立。所以对保护条件的判断以及`Object.wait()`调用应该放在循环语句中，以确保目标动作只有在保护条件成立的情况下才能被执行。

### `Object.notify()`

使用`Object.notify()`实现通知的代码模板伪代码如下：

~~~java
synchronized(someObject){
    updateSharedState();//更新等待线程保护条件涉及的共享变量
    someObject().notify();//唤醒其他线程
}
~~~

包含上述模板代码的方法被称为通知方法，它包含两个要素：更新共享变量、唤醒其他线程

**在临界区中调用**：因为一个线程只有在持有一个对象的内部锁的情况下才能执行该对象的notify方法，因此`Object.notify()`调用总是放在相应对象内部锁所引导的临界区之中。

**`notify/wait`和锁**:也正是`Object.notify()`要求其执行线程必须持有该方法所属对象的内部锁，因此`Object.wait()`在暂停其执行线程的同时必须释放相应的内部锁；否则通知线程无法获得相应的内部锁，也就无法执行notify方法来通知等待线程。`Object.notify()`本身并不会释放对应的内部锁。只有等到临界区执行完成后，通知线程才会释放锁。所以为了使等待线程在其被唤醒之后能够尽快再次获得相应的内部锁，我们应该尽可能地将`Object.notify()`调用放在靠近临界区结束的地方。否则等待线程被唤醒后占用处理器继续运行时，因为没有内部锁，这个等待线程可能会被再次暂停，这将导致上下文切换

**`Object.notifyAll()`**:调用`Object.notify()`所唤醒的线程仅是相应对象上的一个任意等待线程，不一定是我们希望唤醒的那个线程。所以我们可以使用`Object.notifyAll()`，它可以唤醒相应对象上的所有等待线程。

因为等待线程和通知线程在其实现等待和通知时必须调用同一个对象上的`wait()/notify()`方法，而这两个方法都要求其执行线程必须持有该方法所属对象的内部锁，所以等待线程和通知线程是同步在同一个对象上的两个线程。

### `Object.wait()/notify()`的内部实现

我们知道JVM会为每个对象维护一个入口集(Entry Set)用于存储申请该对象内部锁的线程。

此外，JVM还会为每个对象维护一个被称为等待集(Wait Set)的队列，该队列用于存储该对象上的等待线程。

`Object.wait()`将当前线程暂停并释放相应内部锁的同时会将当前线程存入该方法所属对象的等待集中。

执行一个对象的notify方法会使该对象的等待集中的一个任意线程被唤醒。被唤醒的线程仍然会停留在相应对象的等待集中，知道该线程再次持有相应内部锁的时候(此时wait调用尚未返回)`Object.wait()`会使当前线程从其所在的等待集移除，接着wait的调用就放回了。

等待/通知的实现中的几个关键动作，包括 当前线程加入等待集、暂停当前线程、释放锁、将唤醒后的等待线程移除等待集都是在`Object.wait()`中实现的，`Object.wait()`的部分内部实现相当于下面伪代码：

~~~java
public void wait(){
    //执行线程必须持有当前对象对应的内部锁
    if(!Thread.holdsLock(this)){
        throw new IllegalMonitorStateException();
    }
    if(当前对象不在等待集中){
        //将当前线程加入对象的等待集中
        addToWaitSet(Thread.currentThread());
    }
    atomic{//进行原子操作
        releaseLock(this);//释放锁
        block(Thread.currentThread());//暂停当前线程
    }
    acquireLock(this);//再次申请当前对象的内部锁
    removeFromWaitSet(Thread.currentThread());//将当前线程从当前对象的等待集中移除
}
~~~

## wait/notify的开销和问题

### 过早唤醒

在同一个对象someObject的一组等待/通知线程；各个等待线程的保护条件可能不同；当一个通知线程更新共享变量需要唤醒特定的保护条件成立的等待线程时，它为了能一定唤醒特定的等待线程，会执行`notifyAll()`唤醒该对象上的所有等待线程；此时除了它想唤醒的特定等待线程外；还唤醒了其他本无需唤醒的等待线程；这些等待线程的保护条件很可能不成立，从而造成资源的浪费。

过早唤醒的问题可以使用`Condition`接口来解决

### 信号丢失问题







