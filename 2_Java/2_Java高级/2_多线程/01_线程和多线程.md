# 线程概念

进程(Process)是程序的运行实例；是系统进行资源分配和调度的基本单位，是操作系统结构的基础。比如打开IDEA程序会在操作系统中生成一个IDEA的进程，运行一个Java程序就是一个Java虚拟机进程。

线程(Thread)是进程中可独立执行的最小单位。一个进程可以包含多个线程。同一个进程中的所有线程共享该进程中的资源，如空间、文件句柄等。

线程所要完成的计算就成为任务，特定的线程总是执行特定的任务。任务代表线程所要完成的工作。

函数式编程中函数是基本抽象单位，面向对象编程中类是基本抽象单位。类似地，多线程编程就是以线程为基本抽象单位的编程范式。多线程编程和面向对象编程是可以相容的，即我们可以在面向对象编程的基础上实现多线程编程，Java平台上一个线程就是一个对象。

# Thread

Java标准库类`java.lang.Thread`就是Java对线程的实现。Thread类或其子类的一个实例就是一个线程。

## 创建线程

Thread类有两个常用的构造器：

~~~java
public Thread();
public Thread(Runnable target);
~~~

相应地，Java中创建线程有两种方式：

使用第一个构造器，定义Thead类的子类，重写Thread中的run()方法：

~~~java
public class MyThread extends Thread {
    @Override
    public void run() {
        System.out.println("Run MyThread");
    }
}
MyThread myThread = new MyThread();
~~~

使用第二个构造器，实现并创建Runnable接口实例，在实例的run方法实现任务处理落地；以该Runnable接口实例作为构造器的参数直接创建一个Thread类的实例。而Thread的run方法默认将调用target的run方法：

~~~java
@Override
public void run() {
    if (target != null) {
        target.run();
    }
}
~~~

如：

~~~java
Thread thread = new Thread(() -> System.out.println("Run by Runnable"));
~~~

线程对象和其他普通对象的创建一样，需要内存空间的分配。但线程对象和其他普通对象不同的是，Java虚拟机会为每个线程分配调用栈所需的内存空间(调用栈用于跟踪Java方法间的调用关系以及Java代码对本地代码的调用)。此外，Java平台中的每个线程可能还有一个内核线程与之对应。所以创建线程对象要比创建其他类型的对象的成本要高一些

### 使用哪种方式创建线程

之前介绍了两种方式来创建线程，需要理解它们直接的区别，以在合适的场景选择合适的方式创建线程：

从面向对象编程的角度：直接继承Thread类使用继承的方式；而创建Runnable接口实例并传入Thread构造器创建Thread实例使用组合的方式。组合相对于继承来说，类于类之间的耦合对更低，也更灵活。所以在由选择的情况下，优先选用组合技术。

从对象创建成本的角度：直接创建Thread类需要JVM为其分配栈空间，内核线程等资源。相比较于创建一个普通的Runnable实例，成本更加昂贵。所以如果没有一定要创建Thread类的必要，则可以使用Runnable接口以节省JVM的资源开支(如需创建线程实例给其他对象使用,有可能该对象不会被用到，那么就可以创建Runnable接口实例，以供其他对象使用。)



## 线程的运行和启动

每个线程都有其要执行的任务。线程的任务处理逻辑可以在在`Thread`类实例的`run()`实例方法中直接实现或者通过`run()`方法调用。所以run方法相当于线程的任务处理逻辑的入口方法。它由Java虚拟机在运行相应线程时直接调用。而不是由应用代码进行调用。

运行一个线程实际上就是让Java虚拟机执行该线程的run方法，从而使相应线程的任务处理逻辑代码得以执行。为了运行线程，我们首先需要启动线程。Thread类的`start()`方法的作用是启动相应的线程。启动一个线程的实质是请求Java虚拟机运行相应的线程，而这个线程具体何时能运行是由操作系统的线程调度器(Scheduler)决定的。因此，start方法调用结束并不意味着线程已经开始运行了，这个线程可能稍后才会被运行，甚至可能永远不会被运行。

~~~java
public void run();
//如果此线程是使用单独的Runnable对象构造的，则调用该 Runnable 对象的 run 方法;否则，此方法不执行任何操作并返回。线程的子类应重写此方法。
public synchronized void start();
//使此线程开始执行;JVM调用此线程的 run 方法。结果是两个线程同时运行：当前线程（调用start()方法的线程）和另一个线程（执行其 run 方法）。
~~~

一旦线程的run方法执行(有JVM调用)结束，相应的线程的运行也就结束了。当然run方法结束包括正常结束和抛出异常而终止。运行结束的线程所占用的资源(如内存空间)会如同其他Java对象一样被GC回收

线程属于一次性用品。启动线程的`start()`方法只能被调用一次。多次调用同一个Thread实例的start方法将导致其抛出IllegalThreadStateException

run方法总是由Java虚拟机直接调用。但是Java并不阻止我们直接调用。但是大多数情况下我们不能这样做，因为这样做有违创建线程对象的初衷：直接调用run不会创建出新的线程：

~~~Java
Thread thread = new Thread(() -> System.out.println("Current Thread Name:" + Thread.currentThread().getName()));
System.out.println("Main Thread Name:" + Thread.currentThread().getName());
thread.run();
thread.start();
/**
输出为：
Main Thread Name:main
Current Thread Name:main
Current Thread Name:Thread-0
*/
~~~

由此可见：直接调用run方法不会创建新线程；而是在当前线程执行run的代码逻辑

## 线程属性

Thread拥有属性，以区分/标识不同线程和设置线程特性

### ID

ID属性用以标识不同的线程，不同的线程拥有不同的编号。对应Thread内部维护字段：

~~~java
private long tid;
~~~

并提供了访问方法：

~~~java
public long getId();
~~~

ID是只读的，创建Thread实例后ID不可更改。

Thread的ID生成逻辑如下：

~~~java
//提供一个静态变量threadSeqNumber，在堆中所以有默认值0
private static long threadSeqNumber;
//返回下一个ThreadID，将threadSeqNumber加一后返回
private static synchronized long nextThreadID() {
    return ++threadSeqNumber;
}
~~~

`nextThreadID()`方法会在Thread的`init()`方法的最后调用，而`init()`方法最终会在构造器中被调用。所以是在创建线程时，生成的ID。并且默认情况下ID是随一个JVM进程中创建的Thread实例数量自然增长的。

### Name

Name是面向人区分不同线程的属性：

~~~java
private volatile String name;
~~~

除了在创建线程时设置name，Thread也提供了创建线程后访问和设置name的方法：

~~~java
public final synchronized void setName(String name);
public final String getName();
~~~

线程的默认name为`Thread-X` X为线程ID，如`Thread-0`

Java不禁止我们将不同线程的name属性设置成相同的。但是设计时，我们应该将不同线程的name设置成不同的，这有助于代码调试和问题定位。

### Deamon

~~~java
private boolean daemon = false;
~~~

daemon值为true表示该线程为守护线程，否则表示该线程为用户线程。

Thread同样允许我们访问和设置deamon属性：

~~~java
public final void setDaemon(boolean on);
public final boolean isDaemon();
~~~

但是`setDaemon()`方法的调用必须在在启动线程之前。如果在调用`start()`方法后调用了`setDaemon()`方法，将抛出`IllegalThreadStateException`异常

按照线程是否会阻止JVM正常停止来区分用户线程和守护线程：

(JVM正常停止指不是通过`System.exit()`调用，也不是通过强制终止进程实现的JVM停止)

* 用户线程(User Thread):会阻止JVM的正常停止，即一个Java程序只有在所有用户线程都运行结束的情况下才能正常停止。
* 守护线程(Daemon Thread):不会阻止JVM的正常停止，即应用程序中有守护线程的运行也不影响Java程序的正常停止。

所以守护线程通常执行一些重要性不是很高的任务或者生命周期贯穿程序始终的任务，如监视其他线程、垃圾回收任务等。

### Priority

优先级是给线程调度器的提示，用于表示应用线程希望哪个线程能够优先得到执行：

~~~java
private int priority;
~~~

Thread定义三个静态常量供选择通常的优先级：

~~~java
public final static int MIN_PRIORITY = 1;//最低优先级
public final static int NORM_PRIORITY = 5;//默认值，普通优先级
public final static int MAX_PRIORITY = 10;//最高优先级
~~~

优先级的取值范围是1到10；

一般使用默认优先级即可，不恰当地设置该值可能导致严重的问题(线程饥饿)

## Thread其他常用方法

~~~java
public final void join();
//等待相应线程死亡；若线程A调用线程B的join方法，那么线程A的运行会被暂停，知道线程B运行结束
public static native void yield();
//使当前线程主动放弃其对处理器的占用，这可能导致当前线程被暂停；这种方法是不可靠的。该方法被调用时当前线程可能仍然继续运行(视系统当前的运行状况而定)
public static native void sleep(long millis);
//使当前线程休眠(暂停运行)指定的时间
public static native Thread currentThread();
//返回执行当前代码的线程。同一段代码对该方法的调用可能返回不同的线程对象
~~~

# 线程与多线程编程

## 线程的层次关系

Java中的线程不是孤立的，线程与线程之间总存在一些联系。如果线程A所执行的代码创建了线程B。那么，习惯上我们称线程B为线程A的子线程，相应地线程A就被成为线程B的父线程。父线程、子线程是一个相对的称呼：一个线程是某个线程的父线程的同时也可能是另外线程的子线程。

线程间的这种父子关系就被称为线程的层次关系。由JVM创建的main线程(也叫主线程)负责执行Java程序的入口方法mian方法；因此main方法中直接创建的线程都是main线程的子线程。这些子线程的代码也有可能创建其他线程。形成了Java程序的线程层次关系。

在Java程序中，一个线程默认的优先级和是否是守护线程取决于其父线程；如果没有设置和更改一个线程的priority和daemon；那么它的这两个属性会默认使用父线程的对应属性值；这个逻辑具体实现是在`Thread.init()`方法中：

通过`Thread.currentThread()`方法获取父线程：

~~~java
Thread parent = currentThread();
~~~

因为创建该线程的方法就是父线程；所以调用该线程构造器，并最终调用`init()`方法中代码的就是父线程；所以可以用`currentThread()`方法来获取父线程。

然后将父线程的priority和daemon设置为子线程的；

## 线程的生命周期

Java中，一个线程从创建、启动到运行结束整个生命周期可能经历若干状态：

![img](https://gitee.com/wangziming707/note-pic/raw/master/img/ThreadStateMachine.png)

线程的状态可以使用监控工具查看，也可以通过`Thread.getState()`访问。它的返回l类型是`Thread.State`枚举，它的定义如下状态：

* `NEW`:新建状态：一个已创建但未启动(被调用start()方法)的线程处于该状态。由于要给线程实例只能被启动一次，因为一个线程只可能有一次处于该状态

* `RUNNABLE`可执行状态：这个状态可以看作一个复合状态，它有两个子状态：

  * `READY`就绪状态：表示可以被线程调度器(Scheduler)进行调度而使之处于RUNNING状态，处于READY子状态的线程也被称为活跃线程。
  * `RUNNING`运行状态：表示线程正在运行， 即相应线程对象的run犯法所对应的指令正在由处理器执行。

  执行`Thread.yield()`的线程，其状态可能由RUNNING转换未READY

* `BLOCKED`阻塞状态：一个线程发起一个阻塞式I/O(Blocking I/O)操作后，或者申请要给由其他线程持有的独占资源(比如锁)是，相应的线程就会处于该状态。处于BLOCKED状态的线程不会占用处理器的资源。当阻塞式I/O操作完成后，或者线程获得了其申请的资源，该线程的状态又可以转换为RUNNABLE

* `WAITING`等待状态：一个线程执行了某些特定方法之后就会处于等待其他线程执行另外一些特定操作的状态。

  * 能使其执行线程变为WAITING状态的方法有`Object.wait()`, `Thread.join()`, `LockSupport.park(Object)`

  * 能使相应线程从WAITING变更为RUNNABLE的相应方法有`Object.notify()/notifyAll()`和`LockSupport.unpark(Object)`

* `TIMED_WAITING`限时等待状态：该状态和WAITING类似，差别在于处于该状态的线程并非无限制地等待其他线程执行特定操作，而是处于带有时间限制的等待状态。当其他线程没有在指定时间内执行该线程所期望的特定操作时，该线程的状态自动转换为RUNNABLE

* `TERMINATED`终止状态：已经执行结束的线程处于该状态。由于一个线程实例只能被启动一次，因此一个线程也只可能有一次处于该状态`Thread.run()`正常返回或者抛出异常而提前终止都会导致相应线程处于该状态。

## 多线程编程的利弊

多线程编程有以下优势：

* 提高系统的吞吐率(Throughput)
* 提高响应性(Responsiveness)
* 充分利用多核(Multicore)处理器资源
* 最小化队系统资源的使用
* 简化程序的结构

多线程编程同时也有自身的问题和风险

* 线程安全问题：多个线程共享资源，如果没有对应的并发控制。那么将产生数据一致性问题
* 线程活性问题：因为线程设计产生的线程死锁，和因为处理器资源稀少产生的线程饥饿问题。
* 上下文切换开销：处理器从执行一个线程转向执行另一个线程的时候操作系统所需要做的一个动作被称为上下文切换。它增加了系统的消耗
* 可靠性

# 多线程基本概念

## 串行、并发和并行

串行：按顺序依次完成任务，一个时刻只能有一个任务在执行中

并行：同时执行多个任务，一个时刻有多个任务在执行中

并发：以交替的方式利用等待任务所需资源的时间来完成其他任务，一个时刻只能有一个任务在执行中，但以时间段观察，像是在同时执行多个任务。

从硬件的角度来说，在一个处理器一次只能运行一个线程的情况下，由于处理器可以使用时间片分配技术来实现同一段时间内运行多个线程，因此一个处理器就可以实现并发。而并行需要靠多个处理器在同一时刻各自运行一个线程来实现。

多线程编程的实质就是将任务的处理方式由串行改为并发，即实现并发化，以发挥并发又是。

如果一个任务的处理方式可以由串行改为并发(或者并行)，那么我们就称这个任务是可并发化(或者可并行化)

## 竞态

一个计算结果的正确性与时间有关的现象被称为竞态(RaceCondition).即一个问题对相同的输入，程序的输出有时是正确的有时却是错误的



### 模拟竞态

设计一个单例的ID生成器；生成的ID由当前的时间戳和三位在000~999之间自然增长循环的后缀组成

~~~java
public class IDGenerator {

    private final static IDGenerator INSTANCE = new IDGenerator();
    private final static short SEQ_LIMIT = 999;
    private short sequence = -1;
    
    private short nextSeq() {
        if (sequence >= SEQ_LIMIT)
            sequence = 0;
        else
            sequence++;
        return sequence;
    }
    
    public String nextID() {
        SimpleDateFormat formatter = new SimpleDateFormat("yyMMddHHmmss");
        String timestamp = formatter.format(new Date());
        DecimalFormat df = new DecimalFormat("000");
        short sequenceNo = nextSeq();
        return timestamp + df.format(sequenceNo);
    }
    
    public static IDGenerator getInstance(){
        return INSTANCE;
    }
}
~~~

在单线程调用该生成器是，没有问题：

~~~java
IDGenerator idGenerator = IDGenerator.getInstance();
IDGenerator idGenerator = IDGenerator.getInstance();
for (int i = 0; i < 20; i++) {
    System.out.print(idGenerator.nextID()+";");
}
//230706091939000;230706091939001;230706091939002;230706091939003;230706091939004;230706091939005;230706091939006;230706091939007;230706091939008;230706091939009;230706091939010;230706091939011;230706091939012;230706091939013;230706091939014;230706091939015;230706091939016;230706091939017;230706091939018;230706091939019;
~~~

接下来我们用多线程模拟实际调用情况

首先创建一个使用生成器的工作者线程，一个工作者线程调用10次生成器；调用间隔随机：

~~~java
public class WorkerThread extends Thread {

    private static final Random random = new Random();
    @Override
    public void run() {
        IDGenerator idGenerator = IDGenerator.getInstance();
        for (int i = 0; i < 10; i++) {
            randomPause();
            System.out.println(getName()+" got ID:"+ idGenerator.nextID());
        }
    }
    private void randomPause(){
        try {
            Thread.sleep(random.nextInt(50));
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
    }
}
~~~

然后模拟4个工作线程；尽量同时启动

~~~java
//预先创建线程,然后再启动;这样保证尽量同时启动
Thread[] threads = new Thread[4];
for (int i = 0; i < 4; i++) {
    threads[i] = new WorkerThread("worker-"+ (i+1));
}
for (int i = 0; i <4; i++) {
    threads[i].start();
}
~~~

结果输出如下：

~~~java
worker-2 got ID:230706102408001
worker-1 got ID:230706102408001
worker-3 got ID:230706102408000
worker-1 got ID:230706102408002
···········
worker-4 got ID:230706102408037
worker-4 got ID:230706102408038
~~~

可以看到，本应该自然增长的最后三位出现了重复,并且40次调用最后应该输出的后缀预期是039，但实际最后的输出是038

`IDGenerator.nextID()`方法本应该每次调用都输出不同的ID；但是在这种情况下出现了两次调用的ID相同的现象。

### 竞态现象分析

以上面的demo为例，来分析多线程环境下出现竞态的原因：

因为是ID后缀出现重复，可以看出问题出在`nextSeq()`方法，`nextSeq()`的`sequence++`这一行代码代表着下面三个指令

①`load(sequence,r)`：将变量sequence的值从内存读到寄存器r

②`increment(r)`：将寄存器r的值增加1

③`store(sequence,r)`：将寄存器r的内容重新写入变量sequence所对应的内存空间

假设worker-1，worker-2使用的寄存器分别时r1,和r2

而示例的四个线程在执行以上三个指令时可能按照下面表格的顺序交错进行：

| 时刻  | worker-1                          | worker-2                          |
| ----- | --------------------------------- | --------------------------------- |
| $t_1$ | [sequence=0]，执行指令1，[r1=0]   | 其他操作                          |
| $t_2$ | [r1=0],执行指令2，[r1=1]          | [sequence=0]，执行指令1,[r2=0]    |
| $t_3$ | [r1=1]，执行指令3，[sequence = 1] | [r2=0],执行指令2，[r2=1]          |
| $t_4$ | nextID返回结果1                   | [r2=1]，执行指令3，[sequence = 1] |
| $t_5$ | 其他操作                          | nextID返回结果1                   |

按照这种顺序：在$t_2$时刻worker-1读取了sequence内存的数据但还未计算完成重写写回内存的时机，worker-2；执行了指令一，再次读取了sequence=0的数据。接下来$t_5$时刻worker-2执行指令3覆盖了worker-1写入的数据。按照这样的顺序；两个线程调用的`nextID()`方法都返回了1.

通过上面的分析。竞态往往是因为多线程环境下，一个线程读取了脏数据，即一个线程读取到一个过时的数据(对应worker-2在$t_2$时刻的操作)，和丢失更新的问题

#### 竞态的两种模式

产生竞态的两种模式如下：

* read-modifyj-write(读-改-写)：在多线程环境下可能因为线程执行顺序而导致脏读，更新丢失
* check-then-act(检测后执行)：在多线程环境下可能一个线程检测后还未执行时，可能因为其他线程导致检测条件变动，此时原线程再执行检测后任务时已经不符合该任务的执行条件

## 线程安全性

如果一个类在单线程环境下能运作正常，并且在多线程环境下，在其使用方不做任何改变的情况下也能运行正常，那么我们就称其是线程安全的(Thread-safe)，相应地我们称这个类具有线程安全性(Thread Safety)

反之，如果一个类在单线程环境下运行正常而在多线程环境下无法正常运作，那么这个类就是非线程安全的

使用一个类是我们必须弄清楚这个类是否是线程安全的。Java标准库中的一些类HashMap、ArrayList和SimpleDateFormat都是非线程安全的，在多线程环境下直接使用可能会导致一些非预期的甚至是灾难性的结果。比如多线程环境下多个线程共享一个HashMap实例(不采取任何控制措施)可能会导致死循环和内存泄漏。

一个类需要是线程安全的和它预期的被使用的方式有关，如果希望一个类只能被一个线程单独使用，那么就没有必要将这个类设计成线程安全的。另外，把一个类线程安全的往往是有额外的代价的。

线程安全表现为三个方面：原子性、可见性和有序性

## 原子性

原子(Atomic)的字面意思是不可分割的(Indivisible)。对于涉及共享变量访问的操作，若该操作从其执行线程以外的任意线程来看是不可分割的，那么该操作就是原子操作，相应地我们称该操作具有原子性(Atomicity)

所谓“不可分割”的原子操作有两重含义：

* 其中一个含义是指访问(读写)某个共享变量的操作从其执行线程以外的任何线程来看，该操作要么已经执行结束要么尚未方式，即其他线程不会“看到”该操作执行了部分的中间效果。

* 另外一个含义是访问同一组共享变量的原子操作是不能被交错的，假设O1和O2是访问共享变量V的两个原子操作，那么一个线程执行O1期间(开始执行而未执行完毕),其他线程无法执行O2.这就排除了一个线程执行操作期间另一个线程读取或者更新该操作所访问的共享变量而导致的干扰(脏读)和冲突(丢失更新)的可能。由此可见，使一个操作具备原子性也就消除了这个操作导致竞态的可能性。

另外：

* 原子操作是正对访问共享变量的操作而言的。也就是说，仅涉及局部变量访问的操作无所谓是否是原子的
* 原子操作是从该操作的执行线程以外的线程来描述的，也就是说它只有在多线程环境下有意义。

### 实现原子性

总的来说，Java中有两种方式来实现原子性：

* 一是使用锁(Lock)。锁具有排他性，即它能够保障要给共享变量在任意一个时刻只能被一个线程访问。这就消除了竞态
* 另一种是利用处理器提供的专门CAS(Compare and Swap)指令，CAS执行实现原子性的方式和锁实现原子性方式实质上是相同的，差别在于锁通常是在软件这一层次实现的，而CAS是直接在硬件(处理器和内存)这一层次实现的，它可以被看作“硬件锁”

### Java中的原子操作

在Java中，long和double类型以外的任何类型的变量的写操作都是原子操作，即对long和double以外的基础类型和任意引用类型的写操作都是原子的。这是由Java语言规范规定，由JVM具体实现的。

而long和double类型的非原子性是因为32位的操作系统单次操作能处理的最长长度为32bit；而long和double都是64bit的；所以对long和double的读写在32位操作系统中需要两条指令才能完成(先写低32位，再写高32位)

Java语言规范特别规定对于volatile关键字修饰的long/double型变量的写操作具有原子性：

~~~java
volatile long value;
~~~

Java中针对任何变量的读操作都是原子操作

## 可见性

如果一个线程对某个共享变量进行更新后，后续访问该变量的线程可以读取到该更新的结果，那么我们就称这个线程多该共享变量的更新对其他线程可见，否则我们就称这个线程对该共享变量的更新对其他线程不可见。

可见性就是指一个线程对共享变量的更新的结果对于读取相应共享变量的线程而言是否可见的问题。

一个可见性的Demo：

~~~java
public class VisibilityDemo {

    public static void main(String[] args) throws InterruptedException {
        Task task = new Task();
        Thread thread = new Thread(task);
        thread.start();
        Thread.sleep(1000);
        task.shutDown();
    }

    private static class Task implements Runnable {
        public int i = 0;
        public boolean isRunning = true;

        @Override
        public void run() {
            while(isRunning){
                i++;
            }
            System.out.println(i);
        }

        public void shutDown(){
            isRunning = false;
            System.out.println("shutDown");
        }
    }
}
~~~

当我们调用`Task.shutDown()`方法后，预期isRunning变为false；`run()`方法中的while循环结束，打印i后task对应的线程结束。但实际上启动该demo后程序没有如预期的那样，在1s后程序结束。所以判断子线程没有读取到main线程对isRunning变量的更新，仍然读取的旧值true。

### 可见性问题原因

#### JIT编译器优化

==存疑存疑存疑存疑？？？？？？==

JIT编译器对编码有循环提升(Loop Hoisting)的优化：为了避免在循环中重复读取JIT认为不会改变的变量，它会将循环判断条件提到循环外进行，如:

~~~java
while(bValue){
    .......
}
~~~

编译后的机器码实际上执行的是如下逻辑：

~~~java
if(bValue){
    while(bValue){
        .......
    }
}
~~~

如果循环开始后变量bValue在当前线程中没有改变，而可能被其他线程改变；那么这种改变将不会被当前线程读取到，陷入了死循环。

#### 多核处理器缓存

产生可见性问题与计算机的存储系统相关。因为处理器的处理速度和主内存的速度差距十分巨大，所以处理器往往不直接访问主内存，而是通过寄存器(Register)、高速缓存(Cache)、写缓冲器(Store Buffer)和无效化队列(Invalidate Queue)等部件执行内存的读写操作，以提高整体效率。为了方便描述，接下来我们将这个部件统一简称为处理器缓存。

##### 寄存器

程序中的变量可能被分配到寄存器而不是主内存中进行存储。多于多处理器系统，每个处理器都有对应的寄存器，一个处理器无法读取另一个处理器上的寄存器中的内容。所以如果两个线程分别运行在不同的处理器上，而这两个线程的共享变量被分配到了寄存器上进行存储。那么一个线程对共享变量的更新只有在当前处理器上的线程能访问，因为另一个线程在另外的cpu上，所以另外的线程无法访问到更新后的共享变量。就产生了可见性问题。

#####  高速缓存系统

另外，即使某个共享变量被分配到寄存器上进行存储，也不能保证变量的可变性。

一个处理器上运行的线程对变量的更新可能只有更新到该处理器的写缓冲器中，还没有到达处理器的高速缓存区，更不用说主内存。而一个处理器的写缓冲器中的内容无法没另外一个处理器读取，因此此时一个处理器上运行的线程对共享变量的更新无法被另一个处理器上的线程读取。

即使该处理器将这个变量的更新结果被写入该处理器的高速缓存，由于该处理器将这个变量的结果通知给其他处理器时，其他处理器可能仅仅将这个更新通知的内容存入无效化队列中，而不是根据更新通知的内容更新其高速缓存的相应内容，此时仍然有可见性问题。

#### 单核处理器上下文切换

多线程运行在单核处理器上也有可能出现可见性问题，因为发生上下文切换的时候，一个线程对寄存器变量的修改会被该线程的线程上下文保存起来，导致另外线程无法访问到该线程对这个变量的修改

### 可见性问题的解决方案

#### 缓存一致性协议

虽然一个处理器的高速缓存中的内容不能被其他处理器直接读取，但是一个处理器可以通过缓存一致性协议(Cache Coherence Protocol)来读取其他处理器的高速缓存中的数据，并将读取到的数据更新到该处理器的高速缓存中。这个过程称为缓存同步，缓存同步使得一个处理器上的线程可以读取到另外一个处理器上的线程对共享变量的更新，即保障了可见性。

所以为了保障可见性，首先我们必须使一个处理器对共享变量所做的更新最终被写入该处理器的高速缓存或主内存中，而不是始终停留在写缓冲器中；这个将写缓存器中的数据最终写入高速缓存/主内存的过程被称为冲刷处理器缓存(flush cache)；然后一个处理器对共享变量的更新需要通过缓存同步写入其他处理器的高速缓存；这个过程被称为刷新处理器缓存(reflash cache)

所以处理器保障可见性是通过使更新共享变量的处理器执行冲刷处理器缓存并刷新处理器缓存的动作实现的。

#### volatile保证可见性

使用volatile修饰变量，有如下作用：

* 提示JIT编译器被修饰的变量可能被多线程共享，以阻止JIT编译器做出可能导致程序异常的优化
* 读取一个volatile关键字修饰的变量之前会使相应的处理器执行刷新处理器缓存的动作
* 写入一个volatile关键字修饰的变量之后会使相应的处理器执行冲刷处理器缓存的动作

从而保证了可见性。所以在上面的demo中，我们只要用`volatile`修饰isRunning变量就能保证他的可见性，使程序得到预期的结果

### 即使保障了可见性

相对新值：对于同一个共享变量而言，一个线程更新了该变量的值之后，其他线程能够读取到这个更新后的值，那么这个值就被称为该变量的相对新值

最新值：如果读取这个共享变量的线程在读取并使用该变量的时候其他线程无法更新该变量的值，那么该线程读取到的相对新值就被称为该变量的最新值。

可见性仅能保障一个线程能够读到共享变量的相对新值，而不能保障该线程能读到相应变量的最新值。

### 线程的启动、停止与可见性

Java语言规范保证：

* 父线程在启动子线程之前对共享变量的更新对子线程来说是可见的
* 一个线程终止后该线程对共享变量的更新对于调用该线程的join方法的线程而言是可见的。

## 有序性

有序性(Ordering)指在什么情况下一个处理器上运行的线程所执行的内存访问操作在另一个处理器上运行的其他线程看起来是乱序的。乱序指内存访问操作的顺序看起来像是发生了变化。

为了方便 讨论，假定每个线程都运行在各自的处理器，即不考虑一个处理器上基于时间片分时实现的多线程

### 重排序

顺序结构是结构化编程中的一种基本结构，它表示我们希望某个操作必须先于另一个操作得以执行。两个操作总有先后顺序。

但是在多核处理器的环境下，这种操作执行顺序可能是没有保障的：编译器可能改变两个操作的先后顺序；处理器可能不是完全依照程序的目标代码所指定的顺序执行命令；一个处理器上执行的多个操作，从其他处理器的角度来看其顺序可能与目标代码所指定的顺序。这种现象就叫重排序。

重排序是对内存访问有关操作(读和写)所做的一种优化，它可以在不影响单线程程序正确性的情况下提升程序的性能。但是，它可能对多线程程序的正确性产生影响，即它可能导致线程安全问题。

重排序的潜在来源有许多，包括JIT编译器，处理器和存储子系统(包括写缓冲器、高速缓存)

需要定义几个与内存操作顺序有关的术语：

* 源代码顺序(Source Code Order):源代码中所执行的内存访问操作顺序

* 程序顺序(Program Order):在给定处理器上运行的目标代码所执行的内存访问操作顺序

  尽管Java虚拟机执行Java代码有两种方式：解释执行(被执行的是字节码)和编译执行(被执行的是机器码)。为了便于讨论，这里仅将目标代码定义位字节码

* 执行顺序(Execution Order):内存访问操作在给定处理器上的时机执行顺序

* 感知顺序(Perceived Order):给定处理器所感知到/看到的该处理器及其他处理器的内存访问操作发生的顺序。

在此基础上，将重排序细分为指令重排序和存储子系统重排序，如表：

<table>
  <tr>
    <th>重排序类型</th>
    <th>重排序表现</th>
    <th>重排序来源(主题)</th>
  </tr>
  <tr>
    <td rowspan="2">指令重排序</td>
    <td>程序顺序与源代码顺序不一致</td>
    <td>编译器</td>
  </tr>
  <tr>
    <td>执行顺序与程序顺序不一致</td>
    <td>JIT编译器、处理器</td>
  </tr>
  <tr>
    <td>存储子系统重排序</td>
    <td>源代码顺序、程序顺序、执行顺序三者保持一致，<br>但感知顺序与执行顺序不一致</td>
    <td>高速缓存、写缓冲器</td>
  </tr>
</table>
#### 指令重排序

在源代码顺序和程序顺序不一致，或者程序顺序与执行顺序不一致的情况下，我们就说发生了指令重排序。

Java平台包含两种编译器：

* 静态编译器(javac):将Java源代码(.java)编译为字节码(.class)，它是在代码编译阶段介入的。
* 动态编译器(JIT编译器)：将字节码动态编译为Java虚拟机宿主机的本地代码(机器码),它是在Java程序运行过程中介入的。

编译器处于性能考虑，在其认为不影响程序(单线程程序)正确性的情况下可能会对源代码顺序进行调整，造成程序顺序与源代码顺序不一致。

静态编译器基本上不会执行指令重排序，而JIT编译器则可能执行执行重排序。

以下Demo中有可能出现指令重排序：

~~~java
public class ReorderingDemo {
    static int x = 0, y = 0;
    static int a = 0, b = 0;

    public static void main(String[] args) throws InterruptedException {
        while (true) {
            reSort();
        }
    }
    static void reSort() throws InterruptedException {
        Thread t1 = new Thread(() -> {
            a = 1; //操作1
            x = b; //操作2
        });
        Thread t2= new Thread(() -> {
            b = 1; //操作3
            y = a;  //操作4
        });
        t1.start();
        t2.start();
        t1.join();
        t2.join();
        if (x == 0 && y ==0){
            System.out.println("(" + x + "," + y + ")");
        }
        x = 0;
        y = 0;
        a = 0;
        b = 0;
    }
}
~~~

两个线程t1,t2各自对四个变量a,b,x,y进行一次更新，如果更新后x,y都为0，则输出结果；

我们先分析一些，以上代码预期的输出：对变量执行的操作1，2，3，4；按照源代码顺序，操作1一定在操作2之前，操作3一定在操作4之前；那么这四个操作只可能是以下顺序：

* 1,2,3,4 ->(0,1)
* 1,3,2,4->(1,1)
* 1,3,4,2->(1,1)
* 3,4,1,2->(1,0)
* 3,1,4,2->(1.1)
* 3,4,1,2->(1,1)

可以看出只要按照1在2之前，3在4之前的次序；那么这个程序是永远不会有输出的，但经过一段时间的运行后，我们确可能看到程序输出了(0,0);那么可以推断代码经过了指令重排序，使操作2在操作1之前，或者操作4在操作3之前了。









