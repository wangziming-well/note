# 多线程相关概念

进程(Process)是程序的运行实例；是系统进行资源分配和调度的基本单位，是操作系统结构的基础。比如打开IDEA程序会在操作系统中生成一个IDEA的进程，运行一个Java程序就是一个Java虚拟机进程。

线程(Thread)是进程中可独立执行的最小单位。一个进程可以包含多个线程。同一个进程中的所有线程共享该进程中的资源，如空间、文件句柄等。

线程所要完成的计算就成为任务，特定的线程总是执行特定的任务。任务代表线程所要完成的工作。

函数式编程中函数是基本抽象单位，面向对象编程中类是基本抽象单位。类似地，多线程编程就是以线程为基本抽象单位的编程范式。多线程编程和面向对象编程是可以相容的，即我们可以在面向对象编程的基础上实现多线程编程，Java平台上一个线程就是一个对象。

# Thread

Java标准库类`java.lang.Thread`就是Java对线程的实现。Thread类或其子类的一个实例就是一个线程。

## 创建线程

Thread类有两个常用的构造器：

~~~java
public Thread();
public Thread(Runnable target);
~~~

相应地，Java中创建线程有两种方式：

使用第一个构造器，定义Thead类的子类，重写Thread中的run()方法：

~~~java
public class MyThread extends Thread {
    @Override
    public void run() {
        System.out.println("Run MyThread");
    }
}
MyThread myThread = new MyThread();
~~~

使用第二个构造器，实现并创建Runnable接口实例，在实例的run方法实现任务处理落地；以该Runnable接口实例作为构造器的参数直接创建一个Thread类的实例。而Thread的run方法默认将调用target的run方法：

~~~java
@Override
public void run() {
    if (target != null) {
        target.run();
    }
}
~~~



~~~java
Thread thread = new Thread(() -> System.out.println("Run by Runnable"));
~~~

线程对象和其他普通对象的创建一样，需要内存空间的分配。但线程对象和其他普通对象不同的是，Java虚拟机会为每个线程分配调用栈所需的内存空间(调用栈用于跟踪Java方法间的调用关系以及Java代码对本地代码的调用)。此外，Java平台中的每个线程可能还有一个内核线程与之对应。所以创建线程对象要比创建其他类型的对象的成本要高一些

### 使用哪种方式创建线程

之前介绍了两种方式来创建线程，需要理解它们直接的区别，以在合适的场景选择合适的方式创建线程：

从面向对象编程的角度：直接继承Thread类使用继承的方式；而创建Runnable接口实例并传入Thread构造器创建Thread实例使用组合的方式。组合相对于继承来说，类于类之间的耦合对更低，也更灵活。所以在由选择的情况下，优先选用组合技术。

从对象创建成本的角度：直接创建Thread类需要JVM为其分配栈空间，内核线程等资源。相比较于创建一个普通的Runnable实例，成本更加昂贵。所以如果没有一定要创建Thread类的必要，则可以使用Runnable接口以节省JVM的资源开支(如需创建线程实例给其他对象使用,有可能该对象不会被用到，那么就可以创建Runnable接口实例，以供其他对象使用。)



## 线程的运行和启动

每个线程都有其要执行的任务。线程的任务处理逻辑可以在在`Thread`类实例的`run()`实例方法中直接实现或者通过`run()`方法调用。所以run方法相当于线程的任务处理逻辑的入口方法。它由Java虚拟机在运行相应线程时直接调用。而不是由应用代码进行调用。

运行一个线程实际上就是让Java虚拟机执行该线程的run方法，从而使相应线程的任务处理逻辑代码得以执行。为了运行线程，我们首先需要启动线程。Thread类的`start()`方法的作用是启动相应的线程。启动一个线程的实质是请求Java虚拟机运行相应的线程，而这个线程具体何时能运行是由操作系统的线程调度器(Scheduler)决定的。因此，start方法调用结束并不意味着线程已经开始运行了，这个线程可能稍后才会被运行，甚至可能永远不会被运行。

~~~java
public void run();
//如果此线程是使用单独的Runnable对象构造的，则调用该 Runnable 对象的 run 方法;否则，此方法不执行任何操作并返回。线程的子类应重写此方法。
public synchronized void start();
//使此线程开始执行;JVM调用此线程的 run 方法。结果是两个线程同时运行：当前线程（调用start()方法的线程）和另一个线程（执行其 run 方法）。
~~~

一旦线程的run方法执行(有JVM调用)结束，相应的线程的运行也就结束了。当然run方法结束包括正常结束和抛出异常而终止。运行结束的线程所占用的资源(如内存空间)会如同其他Java对象一样被GC回收

线程属于一次性用品。启动线程的`start()`方法只能被调用一次。多次调用同一个Thread实例的start方法将导致其抛出IllegalThreadStateException

run方法总是由Java虚拟机直接调用。但是Java并不阻止我们直接调用。但是大多数情况下我们不能这样做，因为这样做有违创建线程对象的初衷：直接调用run不会创建出新的线程：

~~~Java
Thread thread = new Thread(() -> System.out.println("Current Thread Name:" + Thread.currentThread().getName()));
System.out.println("Main Thread Name:" + Thread.currentThread().getName());
thread.run();
thread.start();
/**
输出为：
Main Thread Name:main
Current Thread Name:main
Current Thread Name:Thread-0
*/
~~~

由此可见：直接调用run方法不会创建新线程；而是在当前线程执行run的代码逻辑

## 线程属性

Thread拥有属性，以区分/标识不同线程和设置线程特性

### ID

ID属性用以标识不同的线程，不同的线程拥有不同的编号。对应Thread内部维护字段：

~~~java
private long tid;
~~~

并提供了访问方法：

~~~java
public long getId();
~~~

ID是只读的，创建Thread实例后ID不可更改。

Thread的ID生成逻辑如下：

~~~java
//提供一个静态变量threadSeqNumber，在堆中所以有默认值0
private static long threadSeqNumber;
//返回下一个ThreadID，将threadSeqNumber加一后返回
private static synchronized long nextThreadID() {
    return ++threadSeqNumber;
}
~~~

`nextThreadID()`方法会在Thread的`init()`方法的最后调用，而`init()`方法最终会在构造器中被调用。所以是在创建线程时，生成的ID。并且默认情况下ID是随一个JVM进程中创建的Thread实例数量自然增长的。

### Name

Name是面向人区分不同线程的属性：

~~~java
private volatile String name;
~~~

除了在创建线程时设置name，Thread也提供了创建线程后访问和设置name的方法：

~~~java
public final synchronized void setName(String name);
public final String getName();
~~~

线程的默认name为`Thread-X` X为线程ID，如`Thread-0`

Java不禁止我们将不同线程的name属性设置成相同的。但是设计时，我们应该将不同线程的name设置成不同的，这有助于代码调试和问题定位。

### Deamon

~~~java
private boolean daemon = false;
~~~

daemon值为true表示该线程为守护线程，否则表示该线程为用户线程。

Thread同样允许我们访问和设置deamon属性：

~~~java
public final void setDaemon(boolean on);
public final boolean isDaemon();
~~~

但是`setDaemon()`方法的调用必须在在启动线程之前。如果在调用`start()`方法后调用了`setDaemon()`方法，将抛出`IllegalThreadStateException`异常

按照线程是否会阻止JVM正常停止来区分用户线程和守护线程：

(JVM正常停止指不是通过`System.exit()`调用，也不是通过强制终止进程实现的JVM停止)

* 用户线程(User Thread):会阻止JVM的正常停止，即一个Java程序只有在所有用户线程都运行结束的情况下才能正常停止。
* 守护线程(Daemon Thread):不会阻止JVM的正常停止，即应用程序中有守护线程的运行也不影响Java程序的正常停止。

所以守护线程通常执行一些重要性不是很高的任务或者生命周期贯穿程序始终的任务，如监视其他线程、垃圾回收任务等。

### Priority

优先级是给线程调度器的提示，用于表示应用线程希望哪个线程能够优先得到执行：

~~~java
private int priority;
~~~

Thread定义三个静态常量供选择通常的优先级：

~~~java
public final static int MIN_PRIORITY = 1;//最低优先级
public final static int NORM_PRIORITY = 5;//默认值，普通优先级
public final static int MAX_PRIORITY = 10;//最高优先级
~~~

优先级的取值范围是1到10；

一般使用默认优先级即可，不恰当地设置该值可能导致严重的问题(线程饥饿)

## 线程方法









## 线程静态方法







# Thread类

## 描述

实现多线程的类

1. 线程都有优先级，范围是1-10，默认为5，优先级越高，被执行的几率越高
2. 线程分为：
   * 用户线程[默认]:表示普通线程，线程任务结束后自动释放
   * 守护线程[设置]：用于服务用户线程，当程序中没有执行的用户线程时，守护线程会自动结束。 Java中的垃圾回收机制，和日志的记录都是典型的守护线程

## 构造方法

* `Thread(String name) `
      分配新的 Thread 对象，并指定线程名称
* `Thread(Runnable target) `
  分配新的 Thread 对象。

## 非静态方法

### 核心方法

* `void run() `

  线程任务方法，指定多线程想需要调用的方法          如果该线程是使用独立的 Runnable 运行对象构造的，则调用该 Runnable 对象的 run 方法；否则，该方法不执行任何操作并返回。 

### 获取线程信息

*  `long getId() `
       返回该线程的标识符。 
*  `String getName() `
       返回该线程的名称。 
*  `int getPriority() `
       返回线程的优先级。 
*  `Thread.State getState() `
       返回该线程的状态。 

### 设置线程

* `void setName(String name) `
  改变线程名称，使之与参数 name 相同。 
* `void setPriority(int newPriority) `
  更改线程的优先级。 

* `void setDaemon(boolean on) `
  将该线程标记为守护线程或用户线程。 



### 判断线程状态

* `boolean isAlive() `
  测试线程是否处于活动状态。 
* `boolean isDaemon() `
  测试该线程是否为守护线程。 
* `boolean isInterrupted() `
  测试线程是否已经中断。 

### 操作线程

* `void checkAccess() `
  判定当前运行的线程是否有权修改该线程。

* `void start() `
  使该线程开始执行；Java 虚拟机调用该线程的 run 方法。 线程只能启动一次（一个对象只能调用一次start()) 

* `void interrupt() `
  中断线程。 

* `void join() `
  等待该线程终止。

  在该线程终止前，执行权都在该线程手中，直到该线程终止 其他的线程才能参与线程执行

* `void join(long millis) `
  等待该线程终止的时间最长为 millis 毫秒。 

  在该线程终止前，或者指定的时间内，执行权都在该线程手中，直到线程结束或者指定时间结束其他的线程才能参与线程执行

* `void join(long millis, int nanos) `
  等待该线程终止的时间最长为 millis 毫秒 + nanos 纳秒。 同上



## 静态方法

* `static int activeCount() `
      返回当前线程的线程组中活动线程的数目。 

* `static Thread currentThread() `
  返回对当前正在执行的线程对象的引用。 

* `static void sleep(long millis) `
  在指定的毫秒数内让当前正在执行的线程休眠（暂停执行），此操作受到系统计时器和调度程序精度和准确性的影响。 

* `static void sleep(long millis, int nanos) `
  在指定的毫秒数加指定的纳秒数内让当前正在执行的线程休眠（暂停执行），此操作受到系统计时器和调度程序精度和准确性的影响。 

* `static void yield() `

  暂停当前正在执行的线程对象，并执行其他线程。 

  让出当先线程的执行权，但会继续参与线程执行权的抢夺

  也就是说让线程进入就绪状态，而不是阻塞

* `static boolean interrupted() `
      测试当前线程是否已经中断。 



# TEMP

* 并行：同一个时刻点，有多个任务同时执行。
* 并发：同一个时间段，有多个任务同时执行。
* 
* 多线程：多个线程并发执行的技术
* 主线程：负责应用程序运行入口的线程。java程序的运行入口是main方法。
* 在java 中每个一个.class文件的运行，都需要独立得分配一个JVM。在一个.class程序中可以运行多个线程。
* 线程的调度策略(算法)：
  * 分时调度：平均分配任务时间
  * 时间片抢占式调度：多个线程抢夺执行权
* 在java中每一个线程会分配一个独立的栈内存，但堆内存是线程共享的
* 同步：一个进程在执行某个任务时，必须等该任务完成，才会继续执行下去
* 异步：进程在执行任务时，不必等任务执行完成，可以直接立刻继续执行其他操作

概念对比：

* 并行与并发：区别在于时间，一个是时间点，一个是时间段，并行是真正的有多个任务在同时执行，而并发不一定，并发可能是多个任务某个时间点只有一个在执行，在一个时间段来看，像是多个任务在同时执行
* 线程与进程：
  * 进程包含线程，一个进程可以有多个线程，线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。
  * 同一进程的线程共享本进程的地址空间和资源，而进程之间的地址空间和资源是相互独立的
* 异步与多线程：多线程是实现异步的一种技术。异步是一种技术功能要求，多线程是实现异步的一种手段。

## 生命周期

![线程生命周期](https://gitee.com/wangziming707/note-pic/raw/master/img/%E7%BA%BF%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png)

* 新建状态：当程序使用new关键字创建了一个线程之后，该线程就处于 新建状态(初始化阶段)
* 就绪状态：线程对象调用了start()方法之后，该线程处于 就绪状态

* 运行状态：当CPU开始调度处于 就绪状态 的线程时，此时线程获得了CPU时间片才得以真正开始执行run()方法的线程执行体，则该线程处于 运行状态。

* 阻塞状态：阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。阻塞的情况大概三种：
  * 等待阻塞：运行的线程执行wait()方法，JVM会把该线程放入等待池中。(wait会释放持有的锁)
  * 同步阻塞：运行的线程在获取对象的同步锁(synchronized)时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池中。
  * 其他阻塞：运行的线程执行sleep()或join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。（注意,sleep是不会释放持有的锁）。
* 死亡状态：线程会以下三种方式之一结束，结束后就处于死亡状态：
  *  run()或call()方法执行完成，线程正常结束。
  *  线程抛出一个未捕获的Exception或Error。
  *  直接调用该线程的stop()方法来结束该线程，该方法容易导致死锁，通常不推荐使用。



## 线程通信

让某个线程在某些条件下改变状态，比如从运行变为阻塞，从阻塞变为就绪等

* 等待唤醒机制：Object提供了 wait() 和 notify() 方法

  wait()/notify() 方法只能在同步方法或同部块中调用

  执行 wait() 方法后，当前线程立即释放锁

  notify() 方法可以随机唤醒等待队列中等待同一共享资源的一个（随机的，仅仅一个）线程，并使该线程退出等待队列，进入可运行状态。

  notifyAll() 方法可以使所有正在等待队列中等待同一资源的全部线程从等待状态进入可运行状态。

* Thread类提供方法：

  * join() 可以理解成线程合并，当在一个线程调用另一个线程的 join() 方法时，当前线程阻塞等待被调用 join() 方法的线程执行完毕才能继续执行，所以 join() 的好处能够保证线程的执行顺序，具有使线程排队的作用

* volatile 关键字，被这个关键字修饰的变量：

  * 保证此变量对所有的线程的可见性(，当一个线程修改了这个变量的值，volatile 保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新)
  * 禁止指令重排序（CPU采用了允许将多条指令不按程序规定的顺序分开发送给各相应电路单元处理）

  通过volatile关键字的特性，我们可以实现比sychronized关键字更轻量级的同步机制