# 同步计算和异步计算

从多个任务的角度看，任务可以是串行执行的，也可以是并发执行的。

从单个任务的角度看，任务的执行方式可以是同步的(Synchronous)也可以是异步的(Asynchronous)

 同步任务是以同步方式执行的任务：同步任务的发起和任务的执行是串行的

异步任务是以异步方式执行的任务：异步任务的发起和任务的执行是并行的

同步方式和异步方式是相对的概念：

* 同一个任务既可以是异步任务也可以是同步任务：对于一个`Runnable`实例`task`表示的任务
  * 如果调用`task.run()`执行该任务，就可以称该任务为同步任务；
  * 如果我们通过`new Thread(task).start()`调用创建并启动一个专门的工作者线程来执行该任务，或者将该任务提交给一个`Executor`实例执行，就可以称该任务是异步任务
* 同步/异步任务还取决于观察角度：如果将task提交给线程池执行
  * 从该任务提交线程的角度来看，它是一个异步任务
  * 从线程池的工作者线程的角度来看，该任务可能是一个同步任务

同步任务的执行线程可能是同步任务的发起线程，也可能不是：

* 如果同步任务的执行线程就是同步任务的发起线程，那么天然保障了任务的发起和任务执行的串行性
* 如果同步任务的执行线程和同步任务的发起线程不是一个线程，那么同步任务的发起线程在发起同步任务后必须等待该任务执行完才能执行其他任务，实现这种等待的方式通常由两种：
  * 阻塞：任务的发起线程将被暂停，直到同步任务执行结束
  * 轮询：任务发起线程发起同步任务后，会轮询任务执行结果，直到同步任务执行结束

异步任务的执行线程和发起线程必须不是同一个线程，多线程是实现异步计算的方法

# Executor框架

`Runnable`接口和`Callable`接口都是对任务处理逻辑的抽象，这种抽象使我们在使用任务时无需关注其任务的具体处理逻辑。

而`Executor`接口则时对任务的执行进行的抽象：

~~~java
public interface Executor {
    void execute(Runnable command);//command代表需要执行的任务
}
~~~

`Executor`接口使得任务的提交放只需要直到它调用`Executor.execute()`方法便可以使指定的任务被执行，而无需关注任务具体的执行细节。

为了实现`Executor`，往往需要在其实现类内部维护一些工作者线程，并在不需要的时候结束工作者线程并释放相应的接口。并且`Executor`只提供了提交任务的方法，无法将任务的处理结果返回给客户端代码

为此有了`ExecutorService`接口，它继承自`Executor`接口，它定义了几个`submit()`方法，这些方法能接受`Callable`接口或者`Runnable`接口表示的任务并返回相应的`Future`实例，以使客户端可以获得任务的执行结果

其还定义了`shutdown()/shutdownNow()`方法来关闭相应的服务

`ThreadPoolExecutor`是`ExecutorService`的默认实现类

## Executors

它定义了一些能够返回`ExecutorService`实例的快捷方法，使我们不必手动创建`ThreadPoolExecutor`

### `newCachedThreadPool()`

~~~java
public static ExecutorService newCachedThreadPool() {
    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                  60L, TimeUnit.SECONDS,
                                  new SynchronousQueue<Runnable>());
}
~~~

这个方法返回一个核心线程池大小为0，最大线程池大小不受限，工作者线程允许的最大空闲时间为60s，内部以`SynchronousQueue`为工作队列的一个线程池。

我们知道`SynchronousQueue`内部实际没有维护缓存队列元素的实际存储空间，假设它的一个实例`q`,当一个线程调用`q.offer()`时，如果没有其他线程在调用`q.take()`，那么`q.offer()`方法将入队失败，并返回false

所以这样的配置以为这该线程池：

提交给该线程池的第一个任务会导致该线程池中的第一个工作者线程被创建并启动。

后续继续提交任务时，由于当前线程池大小已经超过核心线程池大小(0)，因此`ThreadPoolExecutor`会将任务缓存到工作队列中(即调用`workerQueue.offer`方法)。如果此时没有空闲的工作者线程，即没有工作者线程调用`SynchronousQueue.take()`而被暂停。那么入队会失败，

而任务缓存失败时，如果当前线程池大小没有达到最大线程池大小(这里实际上时不限最大线程池大小的)时会创建并启动新的工作线程。

所以该线程池只要缓存任务失败就会创建并启动一个新的工作者线程。

所以如果提交的任务平均执行时间很长，会使工作者线程很难空闲，导致没提交一个任务就会创建启动一个新工作者线程。

因为该线程池没有核心线程，并且有60s空闲时间；所以如果提交任务的频率很低；会导致提交一个任务创建一个工作者线程后，因为后续60s内没有新任务提交，导致该工作线程被杀死；后续再新提交任务又会触发工作者线程的创建和启动；这会导致线程频繁的创建和销毁。

所以`Executors.newCachedThreadPool()`所返回的线程池适合用来执行耗时较短切提交频率较高的任务。

### `newFixedThreadPool()`

```java
public static ExecutorService newFixedThreadPool(int nThreads) {
    return new ThreadPoolExecutor(nThreads, nThreads,
                                  0L, TimeUnit.MILLISECONDS,
                                  new LinkedBlockingQueue<Runnable>());
}
```

它会返回一个以无界队列为工作队列，核心线程池大小嗯好最大线程池大小均为`nThreads`且线程池中的空闲工作者线程不会被自动清理的线程池，所以其线程池大小一旦达到其核心线程池大小就既不会增加也不会减少工作者线程的固定大小的线程池。

所以，这样的线程池实例一旦不再被需要，我们必须主动将其关闭。

### `newSingleThreadExecutor()`

~~~java
public static ExecutorService newSingleThreadExecutor() {
    return new FinalizableDelegatedExecutorService
        (new ThreadPoolExecutor(1, 1,
                                0L, TimeUnit.MILLISECONDS,
                                new LinkedBlockingQueue<Runnable>()));
}
~~~

该方法返回值相当于`Executors.newFixedThreadPool(1)`所返回的线程池。不过该方法返回的线程池并非`ThreadPoolExecutor`实例，而是封装了`ThreadPoolExecutor`实例且对外仅暴露`ExecutorService`接口所定义的方法的一个`ExecutorService`实例

该线程可以实现单/多生产者-单消费者模式。

该线程确保了再任意一个时刻都只有一个任务会被执行，这就形成了类似锁将原本并发的操作改为串行的操作的效果。因此该线程池适合用于执行访问了非线程安全对象单又不希望因此而引入锁的任务。

该线程池也适用与用来执行I/O操作，因为I/O操作往往受限于相应的I/O设备，使用多个线程池执行同一个I/O操作可能不会提高I/O效率

## CompletionService

`Future`接口使得我们能够方便地获取异步任务的出理结果，但是如果需要一次性提交一批异步任务并获取这些任务的处理结果的话，仅使用`Future`接口实现会很繁琐。

`CompletionService`接口为异步任务的批量提交以及获取这些任务的处理结果提供了便利：

~~~java
public interface CompletionService<V> {
    Future<V> submit(Callable<V> task);
    Future<V> submit(Runnable task, V result);
    //submit()用于提交异步任务
    Future<V> take() throws InterruptedException;
    //获取异步任务的处理结果，如果尚不存在，则等待
    Future<V> poll();
    //获取异步任务的处理结果，如果尚不存在，返回null
    Future<V> poll(long timeout, TimeUnit unit) throws InterruptedException;
    //获取异步任务的处理结果，如果尚不存在，返回null;可以指定等待时间
}
~~~

所以批量提交了n个异步任务；最终需要调用n次`take()`方法获取这些任务的处理结果

Java标准类库提供的`CompletionService`接口的实现类是`ExecutorCompletionService`,其完整构造器签名如下：

~~~java
public ExecutorCompletionService(Executor executor,
                                     BlockingQueue<Future<V>> completionQueue)
~~~

所以它内部维护一个线程池用以提交任务，维护一个`Future`阻塞队列用以缓存异步任务的处理结果

如果不指定`completionQueue`,则默认类型为`LinkedBlockingQueue`

提交给`ExecutorCompletionService` 的任务最终由指定的`Executor`执行，任务结果将存储到,completionQueue阻塞队列中等待被获取

另外`ExecutorService.involeAll(Collection<? extends Callable<T>> tasks)`也能用来批量提交异步任务。但该方法必须再所有任务都执行结束之后才会返回

# FutureTask

`Runnable`实例和`Callable`实例都可以表示异步任务，但他们各有限制：

* 使用`Runnable`实例表示的异步任务既可以交给专门的工作者线程执行，也可以交给一个线程池或者`Executor`的其他实现类来执行；但是我们无法获取任务的执行结果
* 使用`Callable`实例表示的异步任务可以通过`submit()`的返回值获取任务的处理结果，但是`Callable`实例表示的异步任务只能交给线程池执行，而无法交给专门的工作者线程执行

`FutureTask`则融合了`Runnable`接口和`Callable`接口的有点，`FutureTask`是`RunnableFuture`接口的实现类，而`RunnableFuture`接口继承了`Runnable`接口和`Future`接口，也就是说`FutureTask`实例既代表一个任务，又能直接返回该任务的执行结果

这样我们就可以使用`FutureTask`实例调用`Executor.execute(Runnable)`的方法的同时，通过它本身来获取惹任务的执行结果。

`FuntureTask`支持回调的方式处理任务的执行结果。当`FutureTask`实例所代表的任务执行结束后`FutureTask.done()`会被执行。我们可以通过重写该方法来实现对任务执行结果的处理。

`FutureTask`基本上是被设计用来表示一次性执行的任务的，其内部会维护一个表示任务运行状态(新建、未开始运行、运行结束等)的状态变量。`FutureTask.run()`在执行任务处理逻辑钱会先判断相应任务的运行状态，如果该任务已经执行过，那么`FutureTask.run()`会直接返回。所以`FutureTask`所代表的任务无法被重复执行的。

# 计划任务

在有些情况下，我们可能需要事先提交一个任务，这个任务并不是立刻被执行，而是要在指定的时间或者周期性地被执行，这种任务被称为计划任务(Scheduled Task)。典型的计划任务包括：系统监控、数据备份等

`ExecutorService`接口的子类`ScheduledExecutorService`接口定义了一组方法用于执行计划任务：

~~~java
public interface ScheduledExecutorService extends ExecutorService {

    public ScheduledFuture<?> schedule(Runnable command,
                                       long delay, TimeUnit unit);

    public <V> ScheduledFuture<V> schedule(Callable<V> callable,
                                           long delay, TimeUnit unit);

    public ScheduledFuture<?> scheduleAtFixedRate(Runnable command,
                                                  long initialDelay,
                                                  long period,
                                                  TimeUnit unit);

    public ScheduledFuture<?> scheduleWithFixedDelay(Runnable command,
                                                     long initialDelay,
                                                     long delay,
                                                     TimeUnit unit);

}
~~~

`schedule()`方法实现延迟执提交的任务：

* ScheduledExecutorService重载了`schedule()`方法以提交`Runnable`和`Callable`任务。
* `delay`和`unit`两个参数一起用来表示被提交的任务自提交的那一刻到开始执行之间的时间差，即延时。

**执行周期(Interval):**同一个任务任意两次执行的开始时间之间的时间差

**耗时(ExecutionTime):**一个任务从其开始执行到其执行结束所需的时间。

`scheduleAtFixedRate()`方法实现周期性地执行提交的任务：

* `initialDelay`和`unit`参数一起指定了一个时间偏移，任务首次执行的开始时间就是任务提交时间加上这个偏移。

* `period`和`unit`参数一起指定了该任务的执行周期。但实际上任务的执行周期受`period`和任务的耗时ExecutionTime共同作用：

  * 如果提交的任务耗时小于`period`指定的时间，那么任务的执行周期就是`period`指定的时间
  * 但如果提交的任务耗时大于`period`指定的时间，那么任务的执行周期就是任务耗时

  可以用表达式表示为：

  ~~~java
  Interval = max(period,executionTime);
  ~~~

`scheduleWithFixedDelay()`同样实现周期性地执行提交的任务，但和`scheduleAtFixedRate()`不同的是，其执行周期为任务的耗时加上period指定的时间，即：

~~~java
Interval = period + executionTime;
~~~

`ScheduledExecutorService`有实现类`ScheduledThreadPoolExecutor`，它是`ThreadPoolExecutor`类的子类

提交给`ScheduledExecutorService`执行的计划任务在其执行过程中如果抛出未捕获异常，那么该任务后续就不会再被执行。

