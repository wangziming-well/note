# 内部锁优化

自Java6/Java7开始，JVM对内部锁的实现进行了一些优化。这些优化包括：锁消除、锁粗化、偏向锁以及适应性锁

这些优化仅在JVM server模式下起作用

## 锁消除

锁消除(Lock Elision)是JIT编译器对内部锁的具体实现所做的一种优化。

在动态编译同步块的时候，JIT编译器会借助一种被称为逃逸分析(Escape Analysis)的技术来判断同步块所使用的锁对象是否只能被一个线程访问而没有被发布到其他线程。

如果同步块所使用的锁对象通过这种分析被证实只能够被一个线程访问，那么JTI编译器在编译这个同步块时就不会生成synchronized锁表示的锁的申请和释放对应的机器码。

这样动态编译的字节码就像不包含monitorenter 和monitorexit这两个字节码一样，即消除了锁的使用。这种编译器优化就被称为锁消除。它使得在特定情况下可以完全避免锁的开销。

Java标准库中有许多类虽然是线程安全的，但在实际使用时我们往往不在多个线程间共享这些类的实例。而这些类实现线程安全的时候往往借助于内部锁。因此，这些类是锁消除优化的常见目标。如下面代码：

~~~java
public static String getInfo(User user){
    StringBuffer sbf = new StringBuffer();
    sbf.append("id:").append(user.id)
        .append(",name:").append(user.name)
        .append(",password:").append(user.password);
    return sbf.toString();
}
~~~

JIT编译器在编译`getInfo`方法的时候会将其调用的`StringBuffer.append()/toString()`方法内联到该方法之中，即相当于把`StringBuffer.append()/toString()`方法的方法体中的指令复制到了`getInfo()`方法之中。

这里`StringBuffer`的实例`sbf`是一个局部变量，并且没有被发布到其他线程，所以JIT编译器此时可以消除`getInfo()`方法中从`StringBuffer.append()/toString()`的方法体复制的指令所使用的内部锁。

在这个例子中`StringBuffer.append()/toString()`方法本身所使用的锁并不会被消除，因为系统中可能还有其他地方在使用StringBuffer，而这些代码的实例可能会共享StringBuffer实例。

从上述例子可以看出，锁消除优化可能需要以JIT编译器的内联优化为前提。而一个方法是否会被JIT编译器内联取决于该方法的热度以及该方法对应的字节码的尺寸。因此，锁消除优化能否被实施还取决于被调用的同步方法是否能够被内联

锁消除是JIT编译器而不是javac所做的一种优化，而一段代码只有在其执行的频率足够大的情况下才有可能被JIT编译器优化。也就是说在JIT编译器优化介入之前，只要源代码中使用了内部锁，那么这个锁的开销就会存在。

在锁消除的作用下，利用ThreadLocal将一个线程安全的对象(比如Random)做为一个线程特有对象来使用，不仅可以避免锁的争用，还可以彻底消除这些多想内部所使用的锁的开销。

## 锁粗化