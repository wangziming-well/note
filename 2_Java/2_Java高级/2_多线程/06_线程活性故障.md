线程活性故障是由资源稀缺性或者程序自身的问题和缺陷导致线程一直处于非RUNNING状态，或者线程虽然处于RUNNING状态但是其要执行的任务却一直无法进展的故障现象

# 死锁

死锁现象指两个或者多个线程因相互等待对方而被永远暂停。

死锁产生的一种典型场景是线程A持有锁L1的情况下申请锁L2，而线程B在持有L2的情况下申请L1。即两个现象在各自持有一个锁的情况下去申请对方持有的另一个锁，这两个线程最终都无法获得它们申请的另外一个锁，产生了死锁。

~~~java
public class DeadlockDemo {
    private final static Object o1 = new Object();
    private final static Object o2 = new Object();

    public static void main(String[] args) {
        new Thread(()->{
            while (true){
                synchronized (o1){
                    System.out.println(Thread.currentThread().getName()+ "使用资源o1");
                    synchronized (o2){
                        System.out.println(Thread.currentThread().getName()+ "使用资源o2");
                    }
                }
            }
        }).start();
        new Thread(()->{
            while (true){
                synchronized (o2){
                    System.out.println(Thread.currentThread().getName()+ "使用资源o2");
                    synchronized (o1){
                        System.out.println(Thread.currentThread().getName()+ "使用资源o1");
                    }
                }
            }

        }).start();
    }
}

~~~

## 产生条件和规避

产生死锁一定满足如下条件：

* 资源互斥：资源必须是独占的，每个资源一次只能被一个线程使用
* 资源不可抢夺：涉及的只能被其持有者主动释放，而无法被其他线程抢夺。
* 占用并等待资源:涉及的线程当前至少持有一个资源并申请其他资源
* 循环等待资源：涉及的线程必须在等待别的线程持有的资源，而这些线程反过来在等待该线程所持有的资源

要注意以上条件是死锁产生的必要条件，但满足了上述条件不是一定会产生死锁，只是可能产生

如果这种资源是锁，那么锁已经满足了资源互斥和资源不可抢夺。那么产生死锁的特征就是在持有一个锁的情况下去申请另一个锁，这通常意味着锁的嵌套。

所以避免锁产生的死锁，可以通过避免“占用并等待资源”和“循环等待资源”两个方向入手，可以通过下面方法规避死锁：

* 锁粗法：使用粗粒度的锁代替多个锁，从而消除“占用并等待资源”这个产生死锁的前提。但缺点也很明显，它显著降低了并发性，肯呢个导致资源浪费
* 锁排序法：相关线程使用全局统一顺序申请锁。即多个线程申请锁的顺序都是相同的，这样就避免了“循环等待资源”这个产生死锁的前提。
* 使用`ReentrantLock.tryLock(long,TimeUnit)`申请锁，为锁申请设置一个超时时间。从而消除丝素产生的“占用并等待资源”

事实上导致死锁的代码可能不像DeadlockDemo中的代码一样直接能看出问题。更为常见的情况是一个方法在持有一个锁的情况下调用一个外部方法，外部方法不在我们的控制范围之内，可能是同步方法也可能不是；如果是同步方法那么就可能导致死锁；如果两个类的多个同步方法互相调用，如`A.a()`方法中调用了`B.c()`;并且`B.d()`方法中调用了`B.b()`;那么就可能导致死锁

* 这种死锁可以使用“开放调用”来规避：开放调用是指一个方法在调用外部方法(其他类的方法以及当前类的可覆盖方法)的时候不持有任何锁

* 规避死锁的终极方法就是不使用锁：使用无状态对象、线程特有对象、volatile关键字等

## 死锁的故障恢复

如果代码中使用的是内部锁或者使用的是显式锁而锁的申请是通过`Lock.lock()`调用实现的，那么这些锁所导致的死锁故障是不可恢复的，唯一能做的就是重启Java虚拟机。

如果代码中使用的是显式锁且锁的申请是通过`Lock.lockUnterruptibly()`调用实现的，那么这些锁的使用锁导致的死锁理论上是可恢复的。

但是，死锁的恢复实际可操作性并不强：进行恢复的尝试可能是徒劳的(故障线程可不响应中断)且有害的(可能导致其他线程活性故障)

死锁的自动恢复有赖于线程的中断机制，其基本思路是：
