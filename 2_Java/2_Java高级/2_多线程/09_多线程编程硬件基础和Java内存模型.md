# 高速缓存

现代处理器处理速率远胜于主内存(DRAM)访问速率，主内存执行一次内存读、写操作所需的时间可能足够处理器执行上百条的命令。为了弥补处理器与主内存处理能力之间的鸿沟，硬件设计者在主内存和处理器之间引入了高速缓存(Cache)

高速缓存时一种存取速率远比主内存大而容量远比主内存下的存储部件，每个处理器都有其高速缓存。

引入高速缓存后，处理器在执行内存读写操作的时候并不直接与主内存打交道，而是通过高速缓存进行的。

变量名相当于内存地址，而变量值相当于相应内存空间所存储的数据。从这个角度看，高速缓存相当于为程序所访问的每个变量保存了一份相应内存空间所存储数据的副本。由于高速缓存的存储容量远小于主内存，因此高速缓存并不是每时每刻保留着所有变量值的副本。

## 高速缓存结构

高速缓存相当于一个由硬件实现的内存极小的散列表，其键(Key)是一个内存地址，其值(Value)是内存数据的副本或者准备写入内存的数据。

从内部结构来看，高速缓存相当于一个拉链散列表(Chained Hash Table)，它包含若干桶(Bucket)，每个桶又包含若干缓存条目(Cache Entry)

![image-20230804103629417](https://gitee.com/wangziming707/note-pic/raw/master/img/%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84%E7%A4%BA%E6%84%8F%E5%9B%BE.png)

缓存条目可被进一步划分为Tag、Data Block和Flag三部分：

![image-20230804103800395](https://gitee.com/wangziming707/note-pic/raw/master/img/%E7%BC%93%E5%AD%98%E6%9D%A1%E7%9B%AE%E7%BB%93%E6%9E%84.png)

* Data Block 也被称为缓存行(Cache Line)，它是高速缓存与主内存之间的数据交换最小单元，用于存储从内存中读取的或者准备写往内存的数据。缓存行的容量(缓存行宽度)通常是2的倍数，其大小在16~256字节(Byte)之间。从代码角度看，一个缓存行可以存储若干变量的值，而多个变量的值可能被存储在同一个缓存行之中。

* Tag则包含了与缓存行中数据相应的内存地址的部分信息(内存地址的高位部分比特)
* Flag用于表示相应缓存行的状态信息

## 内存地址解码和缓存命中

处理器在执行内存访问操作时会将相应的内存地址解码(具体的解码动作是由高速缓存控制器负责执行)。内存地址的解码结果包括tag、index以及offset这三部分数据。其中index相当于桶编号，它可以用来定位内存地址对应的桶，tag相当于缓存条目的相对编号，其作用是定位一个具体的缓存条目(即缓存条目的Tag);offset是缓存行内的位置偏移，其作用是确定一个变量在一个缓存行中的存储起始位置。

根据这个内存地址的解码结果，如果高速缓存子系统能够找到相应的缓存行并且缓存行所在的缓存条目的Flag表示相应缓存条目是有效的，那么就称相应的内存操作产生了缓存命中(Cache Hit)；否则，我们就称相应的内存操作产生了缓存未命中(Cache Miss)

缓存未命中包括读未命中和写未命中，分别对应内存的读和写操作。当读未命中产生是，处理器所需要读取的数据会从主内存中加载并被存入相应的缓存行之中，这个过程会导致处理器停顿而不能执行其他指令，这不利于发挥处理器的处理能力。所以从性能角度来看我们应该尽可能减少缓存未命中。而由于高速缓存的总容量远小于主内存的总容量，因此缓存未命中不可避免。

## 多级缓存

现代处理器一般具有多个层次的高速缓存。在这个层次中，相应的高速缓存通常被称为一级缓存(L1 Cacha)、二级缓存(L2 Cache)、三级缓存(L3 Cache)等。

一级缓存可能被继承在处理器的内核里，因此其访问效率非常高，一般来说一级缓存的访问操作可以在2~4个处理器时钟循环完成。一级缓存通常包括两部分，其中一部分用于存储指令(L1i),另外一部分用于存储数据(L1d)。

距离处理器越近的高速缓存，器存取速率越快，制造成本越高，因此其容量也越小。

![image-20230804112552333](https://gitee.com/wangziming707/note-pic/raw/master/img/%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98%E7%BB%93%E6%9E%84.png)

# 缓存一致性协议

多个线程访问同一个共享变量的时候，这些线程的执行处理器上的高速缓存各自都会保留一份该共享变量的副本，这带来的新的问题：一个处理器对其副本数据进行更新之后，其他处理器如果不同步更新数据，那么其他处理器将无法读取到这个处理器对变量的更新。这就是缓存一致性问题，其实质就是如何防止读脏数据和丢失更新的问题。

为了解决这个问题，处理器之间需要一种通信机制：缓存一致性协议。

## MESI协议

MESI(Modified-Exclusive-Shared-Invalid)协议是常用的缓存一致性协议，x86处理器所使用的缓存一致性协议就是基于MESI协议的。MESI协议对内存数据访问的控制类似于读写锁，它使得针对同一地址的读内存操作时并发的，而针对同一内存地址的写操作是独占的，即针对同一内存地址进行的写操作在任意一个时刻只能由一个处理器执行。在MESI协议中，一个处理器往内存中写数据时必须持有该数据的所有权。

为了保障数据的一致性，MESI将缓存条目的状态划分为：Modified、Exclusive、Shared、Invalid四种，并在此基础上定义了一组消息用于协调各个处理器的读、写内存操作

## MESI协议的Flag值

MESI协议中一个缓存条目的Flag值有以下四种可能：

* Invalid(无效的，记为I)：该状态表示相应缓存行中不包含任何内存地址对应的有效副本数据。该状态是缓存条目的初始状态。
* Shared(共享的，记为S)：该状态表示相应缓存行包含相应内存地址所对应的副本数据。并且，其他处理器上的高速缓存中也可能包含相同内存地址对应的副本数据。一个缓存条目的状态如果为Shared，并且其他处理器上也存在Tag值与该缓存条目Tag值相同的缓存条目，那么这些缓存条目的状态也为Shared。处于该状态的缓存条目，其缓存行中包含的数据与主内存中包含的数据一致。
* Exclusive(独占的，记为E)：该状态表示相应缓存行包含相应内存地址所对应的副本数据。并且，该缓存行以独占的方式保留了相应内存地址的副本数据，即其他所有处理器上的高速缓存当前都不保存该数据的有效副本。处于该状态的缓存条目，其缓存行中包含的数据与主内存中包含的数据一致。
* Modified(更改过的，记为M)：该状态标识相应缓存行包含对相应内存地址所做的更新结果数据。由于MESI协议中的任意一个时刻只能够有一个处理器对同一内存地址对应的数据进行更新，因此在多个处理器上的高速缓存中Tag值相同的缓存条目中，任意一个时刻只能够有一个缓存条目处于该状态。处于该状态的缓存条目，其缓存行中包含的数据与主内存中包含的数据不一致。

## MESI协议的消息

MESI协议定义了一组消息(Message)用于协调各个处理器的读、写内存操作，我们可以将MESI协议中的消息分为请求消息和响应消息。

处理器在执行内存读、写操作时在必要的时候会往总线中发送特定的请求消息，同时每个处理器还拦截总线中其他处理器发出的请求消息并在特定条件下往总线中回复相应的响应消息。

| 消息名                 | 消息类型 | 描述                                                         |
| ---------------------- | -------- | ------------------------------------------------------------ |
| Read                   | 请求     | 通知其他处理器、主内存当前处理器准备读取某个数据。该消息包含待读取数据的内存地址 |
| Read Response          | 响应     | 该消息包含被请求读取的数据。该消息可能是主内存提供的，也可能是拦截Read消息的其他高速缓存提供的 |
| Invalidate             | 请求     | 通知其他处理器将其高速缓存中指定内存地址对应的缓存条目状态置为I，即通知这些处理器删除指定内存地址的副本数据 |
| Invalidate Acknowledge | 响应     | 接收到Invalidate消息的处理器必须回复该消息，以表示删除了其高速缓存上的相应副本数据 |
| Read Invalidate        | 请求     | 该消息是由Read消息和Invalidate消息组合而成的复合消息。其作用在于通知其他处理器当前处理器准备更新(读后写更新)一个数据，并请求其他处理器删除其高速缓存中相应的副本数据。接收到该消息的处理器必须回复Read Response消息和Invalidate Acknowledge消息 |
| Writeback              | 请求     | 该消息包含需要写入主内存的数据以及对应的内存地址             |

## 
