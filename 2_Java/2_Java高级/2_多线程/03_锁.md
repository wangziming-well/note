# 线程同步机制概述

上一节从软硬件的角度来分析线程安全问题。但从应用程序的角度来看，线程安全问题的产生是由于多线程应用程序缺少线程同步机制。

线程同步机制是一套用于协调线程间的数据访问和活动的机制。该机制用以保障线程安全以及实现这些线程的共同目标。

Java提供的线程同步机制包括锁、volatile关键字、final关键字、static关键字以及相关的API(如Object.wait()/ Object.notify())等。本篇介绍Java平台中用于协调线程间共享数据访问的相关关键字和API

# 锁概述

线程安全问题的产生的前提是多个线程并发访问共享数据。那么一种保障线程安全的方法就是：讲多个线程多共享数据的并发访问转换未串行访问，即一个共享数据一次只能被一个线程访问，该线程访问结束后其他线程才能对其进行访问。锁(Lock)就是利用这种思路以保障线程安全的线程同步机制

一个线程在访问共享数据前必须申请相应的锁，线程的这个动作被称为锁的获得；一个线程获得某个锁，我们就称该线程为相应锁的持有线程，一个锁一次只能被一个线程持有。

锁的持有线程可以对该锁所保护的共享数据进行访问，访问结束后该线程必须释放相应的锁。锁的持有线程在其获得锁之后和释放锁之前这段时间内所执行的代码被称为临界区。因此，共享数据只允许在临界区内进行访问，临界区一次只能被一个线程执行。

如果有多个线程访问同一个锁所保护的共享数据，那么我们就称这些同步线程在这个锁上，或者称我们对这些线程所进行的共享数据访问进行加锁；相应地，这些线程所执行的临界区就被称为这个锁所引导的临界区。

锁具有排他性，即一个锁一次只能被一个线程持有。因此这种锁被称为排他锁或者互斥锁。后续还有另外一种锁，读写锁。它可以被看作排他锁的一种相对改进。

JVM对锁的实现方式划分，分为内部锁和显式锁。内部锁通过`synchronized`关键字实现的；显式锁是通过`java.conurrent.locks.Lock`接口的实现类实现的。

## 锁的作用

锁能够保护共享数据以实现线程安全，包括保障原子性、可见性和有序性。

### 保障原子性

锁是通过互斥保障原子性的。互斥就是一个锁一次只能被一个线程持有。因此一个线程持有一个锁时，其他线程无法获得锁，只能等待其释放该锁后再申请。这就保证了临界区代码一次只能被一个线程执行。因此，一个线程执行临界区期间没有其他线程能够访问相应的共享数据，这使得临界区代码所执行的操作自然而然地具有不可分割的特性，即具备了原子性。

从互斥的角度来看，锁讲多个线程对共享数据的访问由原来的并发改为了串行。虽然实现并发时多线程编程的目标，但这种并发往往是并发中带有串行的局部并发。

### 保障可见性

可见性的保障时通过写线程冲刷处理器缓存和读取线程刷新处理器缓存这两个动作实现的。

在Java平台中，锁的获得隐含着刷新处理器缓存的动作，这使得读线程在执行临界区代码前可以将写线程对共享变量的更新同步到该线程执行处理器的高速缓存中。

锁的释放隐含着冲刷处理器缓存的动作，这使得写线程多共享变量所作的更新能够从不能被其他处理器共享的写缓冲器推送到高速缓存中，从而对读线程可同步。

因此，锁能够保障可见性。

锁对可见性的保障使线程在临界区读取到的共享变量是相对新值，锁的互斥性使同一个锁所保护的共享数据一次只能被一个线程访问，所以临界区读取的相对新值同时又是最新值。

### 保障有序性

锁能够保证有序性。即写线程在临界区的源代码顺序与其他线程对其的感知顺序是一致的。

这是锁对原子性和可见性的保障的结果。

由于锁对可见性的保障，写线程在临界区中对任何共享变量的更新都对其他线程可见；由于锁对原子性的保障，写线程对多个变量的更新会同时其他线程可见。这意味着其他线程无法也没有必要区分写线程是以什么顺序更新若干个共享变量的，那么就可以认为是按照源代码顺序更新共享变量的，即保障了有序性。

这种对有序性的保障并不意味着临界区的内存操作不能被重排序。只是这种重排序在原子性和可见性的保障下不再会影响有序性。

### 锁保证线程安全的条件

锁对原子性、可见性、有序性的保障是有条件的，需满足以下两点：

* 多个线程访问同一组共享数据时必须使用同一个锁
* 这些线程中的任意一个线程，即使其仅读取这组共享数据而没有对其更新，也需要在读取时持有相应的锁

## 锁相关的概念

### 可重入性

如果一个线程持有一个锁的时候还能继续成功申请该锁，那么就称该锁是可重入的(Reentrant)，否则就称该锁位非可重入的(Non-reentrant)

可重入锁一般是通过锁对象的计数器属性实现的。计数器初始值为0，表示相应的锁还没有被任何线程持有。每次线程获得一个可重入锁的时候，该锁的计数器值就会加1.每次一个线程释放锁的时候，计数器就减一。

### 锁的争用与调度

锁可以被看所多线程程序访问共享数据时所需持有的一种排他性资源。因此，资源的争用、调度的概念也适用于锁。

Java平台中锁的调度策略也包括公平策略和非公平策略，相应的锁就被成为公平锁和非公平锁。

内部锁属于非公平锁，而显式锁既支持公平锁又支持非公平锁。

### 锁的粒度

一个锁实例可以保护一个或者多个共享数据。一个锁实例所保护的共享数据大小就被称为该锁的 粒度(Granularity)。一个锁实例保护的共享数据的数量大，我们就称该锁的粒度粗，否则就称该锁的粒度细。

锁的粒度过粗会导致线程在申请锁的时候进行不必要的等待；锁的粒度过细会增加锁调度的开销

## 锁的开销和可能导致的问题

锁的开销包括锁的申请和释放所产生的开销，以及锁可能导致的上下文切换的开销。

多个线程争用排他性资源可能导致上下文切换；锁作为一种排他性资源一旦被争用就可能导致上下文切换。

此外，锁的不正确使用会导致以下线程故障：

* 锁泄露：指一个线程获得某个锁后，由于程序的错误、缺陷导致该锁一直无法被释放而导致其他线程一直无法获得该锁的现象。
* 死锁、锁死等线程活性故障

# 内部锁:synchronized

Java平台的任意一个对象都有唯一一个与之关联的锁。这种锁被称为监视器(Monitor)或者内部锁(Intrinsic Lock)。内部锁是一种排他锁

内部锁是通过synchronized关键字实现的。synchronized关键字可以用来修饰方法以及代码块

synchronized关键字修饰的方法就是同步方法。同步方法的整个方法体就是一个临界区：

~~~~java
public synchronized void method(){ ... }
~~~~

synchronized关键字修饰的代码块被称为同步块(Synchronized Block),其语法如下：

~~~java
synchronized(锁句柄){
    //...
}
~~~

synchronized关键字锁引导的代码块就是临界区。锁句柄是一个对象的引用。持有相同锁句柄的线程会被同步。习惯上我们也直接称锁句柄为锁。锁句柄对应的监视器就被称为相应同步块的引导锁。

作为锁句柄的变量通常用`final`修饰。因为锁句柄的变量的值一旦改变，就会导致执行同一个同步块的多个线程实际上使用不同的锁，从而导致竞态。

线程对内部锁的申请和释放动作由JVM代为实施，这也是`synchronized`实现的锁被称为内部锁的原因。

内部锁的使用不会导致锁泄露。因为Java编译器在将同步块代码编译为字节码时，对临界区中可能抛出但未捕获的异常进行了特殊处理，使得临界区的代码即使抛出异常也不会妨碍内部锁的释放。

## 同步方法的锁句柄

同步实例方法相当于以`this`为引导锁的同步块。所以下面两段代码是等价的：

~~~java
public synchronized void method(){
    //......
}
~~~

等价于

~~~java
public void method(){
    synchronized(this){
            //......
    }
}
~~~

同步静态方法相当于以当前类对象为引导锁的同步块。所以下面两段代码是等价的：

~~~java
public static synchronized void method(){
	//...
}
~~~

等价于

~~~java
public static void method2(){
    synchronized (Demo.class){
        //...
    }
}
~~~

## 使用示例

在前面的笔记中，我们用IDGenerator演示了竞态，其`nextSeq()`方法因为多个线程使用共享数据造成了线程安全问题，现在我们使用`synchronized`关键字来消除竞态：

~~~java
public class IDGenerator {

    private final static IDGenerator INSTANCE = new IDGenerator();
    private final static short SEQ_LIMIT = 999;
    private short sequence = -1;
    
    private synchronized short nextSeq() {
        if (sequence >= SEQ_LIMIT)
            sequence = 0;
        else
            sequence++;
        return sequence;
    }
    
    public String nextID() {
        SimpleDateFormat formatter = new SimpleDateFormat("yyMMddHHmmss");
        String timestamp = formatter.format(new Date());
        DecimalFormat df = new DecimalFormat("000");
        short sequenceNo = nextSeq();
        return timestamp + df.format(sequenceNo);
    }
    
    public static IDGenerator getInstance(){
        return INSTANCE;
    }
}
~~~

用`synchronized`关键字修饰`nextSeq()`使其成为同步方法。这样，锁将保护对共享变量`sequence`的访问。

## 内部锁的调度

JVM会为每个内部锁分配一个入口集(Entry Set)，用于记录等待获得相应内部锁的线程。

多个线程申请同一个锁的时候，只有一个线程能申请成功，称为该锁的持有线程。其他的线程的申请操作会失败，这些申请失败的线程会被暂停(生命周期状态变为BLOCKED)并被存入相应锁的入口集中等待再次申请锁的机会。

入口集中的线程就被称为相应锁的等待线程。

当锁被释放时，JVM会按相应的策略选取并唤醒该锁的入口集中的一个线程，从而得到再次申请锁的机会。由于内部锁时非公平调度的，被唤醒的等待线程占用处理器运行时可能还有其他新的活跃线程(RUNNABLE状态,且未进入过入口集)与该线程抢占这个锁。因此这个被选中唤醒的线程不一定就能成为该锁的持有线程。

JVM唤醒入口集中线程的选取策略和JVM的具体实现有关：可能是入口集中等待时间最长的线程，也可能是等待时间最短的线程，或者是完全随机的线程。所以我们不能依赖具体的选择算法。

# 显式锁:Lock接口

显式锁是JDK1.5引入的排他锁。作为一种线程同步机制，其作用与内部锁相同。它提供了一些内部锁所不具备的特性，但并不是内部锁的替代品。

显式锁是`Lock`接口的实例。该接口对显式所进行了抽象。类`ReentrantLock`是`Lock`接口的默认实现类

`Lock`接口规范如下：

~~~java
public interface Lock {

    void lock();
    //获取锁
    void lockInterruptibly() throws InterruptedException;
	//如果当前线程未被中断，则获取锁
    boolean tryLock();
    //仅在调用时锁位空闲状态才获取该锁
    boolean tryLock(long time, TimeUnit unit) throws InterruptedException;
	//如果锁在给定的等待时间内空闲，并且当前线程未被中断，则获取锁
    void unlock();
	//释放锁
    Condition newCondition();
    //返回绑定此Lock实例的新Condition实例。
}
~~~

一个Lock接口实例就是一个显式锁对象，Lock接口定义的`lock()`方法和`unlock()`方法分别用于申请和释放相应Lock实例表示的锁。其使用示例如下：

~~~java
Lock l = ...;
l.lock();
try {
    // access the resource protected by this lock
} finally {
    l.unlock();
}
~~~

使用显式锁有如下步骤：

* 创建Lock接口实例。如果没有特别要求，可以创建Lock接口的默认实现类ReentrantLock的实例，它是一个可重入锁
* 在访问共享数据前申请相应的显式锁。调用`Lock.lock()`方法
* 在临界区中访问共享数据；`Lock.lock()`调用与`Lock.unlock()`调用之间的代码区域为临界区
* 共享数据访问结束后释放锁。为了避免锁泄露，将`Lock.unlock()`的调用放到finally代码块中执行

使用示例：

~~~java
private short nextSeq() {
    ReentrantLock lock = new ReentrantLock();
    lock.lock();
    try {
        if (sequence >= SEQ_LIMIT)
            sequence = 0;
        else
            sequence++;
        return sequence;
    } finally {
        lock.unlock();
    }
}
~~~

## 显式锁的调度

`ReentrantLock`既支持非公平锁也支持公平锁，它有要给构造器签名如下：

~~~java
public ReentrantLock(boolean fair)
~~~

调用该构造器创建lock实例可以指定实例相应的锁是否公平锁；fair为true是公平锁；fair为false是非公平锁

如果调用`ReentrantLock`无参构造,则默认创建非公平锁

公平锁保障调度的公平性往往是以增加了线程的暂停和唤醒的可能性，即增加了上下文切换为代价的。

所以公平锁适用于锁被持有的时间相对长或者线程申请锁的平均时间间隔相对长的情形。总的来说公平锁的开销比非公平锁的开销要大。

## 显式锁和内部锁

显式锁和内部锁各自适用场景不同，不是相互替代。

内部锁是基于代码块的锁，所以其使用没有灵活性可言，要么使用它要不不使用。而显式锁是基于对象的锁，其使用可以充分发挥面向对象编程的灵活性。内部锁的申请和释放只能在一个方法内进行(因为代码块无法跨方法)，而显式锁的申请和释放可以跨方法。

内部锁因为锁的申请和释放由JVM代为操作，所以它简单易用，不会导致锁泄露。而显式锁容易错用而导致锁泄露。所以显式锁使用时需注意将锁的释放动作放到finally代码块中

在锁的调度方面，内部锁仅支持非公平锁；而显式锁即支持公平锁又支持非公平锁

显式锁提供了一些接口方法用来对锁的相关信息进行监控，而内部锁不支持这种特性`RentrantLock.isLocked()`可以用于检测相应锁是否被某个线程持有，`RentrantLock.getQueueLength()`方法用于检测相应锁的等待线程数量。

显式锁和内部锁在性能方面的差异主要包括：

* Java1.6/1.7对内部锁做了一些优化，可以在特定情况下减少锁的开销。包括：锁消除、锁粗化、偏向锁和适配性锁

## 读写锁

锁的排他性使得多个线程无法以线程安全的方式在同一时刻对共享变量进行读取，这不利于提高系统的并发性。特别是在读多写少的场景中。

读写锁(Read/Write Lock)是一种改进型的排他锁，也被称为共享/排他锁(Shared/Exclusive Lock)

读写锁允许多个线程可以同时读取(只读)共享变量，但一次只允许一个线程对共享变量进行更新。任何线程读取共性变量的时候，其他线程无法更新这些变量；一个线程更新共享变量的时候，其他任何线程都无法访问该变量。
