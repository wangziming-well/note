# 线程同步机制概述

上一节从软硬件的角度来分析线程安全问题。但从应用程序的角度来看，线程安全问题的产生是由于多线程应用程序缺少线程同步机制。

线程同步机制是一套用于协调线程间的数据访问和活动的机制。该机制用以保障线程安全以及实现这些线程的共同目标。

Java提供的线程同步机制包括锁、volatile关键字、final关键字、static关键字以及相关的API(如Object.wait()/ Object.notify())等。本篇介绍Java平台中用于协调线程间共享数据访问的相关关键字和API

# 锁概述

线程安全问题的产生的前提是多个线程并发访问共享数据。那么一种保障线程安全的方法就是：讲多个线程多共享数据的并发访问转换未串行访问，即一个共享数据一次只能被一个线程访问，该线程访问结束后其他线程才能对其进行访问。锁(Lock)就是利用这种思路以保障线程安全的线程同步机制

一个线程在访问共享数据前必须申请相应的锁，线程的这个动作被称为锁的获得；一个线程获得某个锁，我们就称该线程为相应锁的持有线程，一个锁一次只能被一个线程持有。

锁的持有线程可以对该锁所保护的共享数据进行访问，访问结束后该线程必须释放相应的锁。锁的持有线程在其获得锁之后和释放锁之前这段时间内所执行的代码被称为临界区。因此，共享数据只允许在临界区内进行访问，临界区一次只能被一个线程执行。

如果有多个线程访问同一个锁所保护的共享数据，那么我们就称这些同步线程在这个锁上，或者称我们对这些线程所进行的共享数据访问进行加锁；相应地，这些线程所执行的临界区就被称为这个锁所引导的临界区。

锁具有排他性，即一个锁一次只能被一个线程持有。因此这种锁被称为排他锁或者互斥锁。后续还有另外一种锁，读写锁。它可以被看作排他锁的一种相对改进。

JVM对锁的实现方式划分，分为内部锁和显示锁。内部锁通过`synchronized`关键字实现的；显示锁是通过`java.conurrent.locks.Lock`接口的实现类实现的。

## 锁的作用

锁能够保护共享数据以实现线程安全，包括保障原子性、可见性和有序性。

### 保障原子性

锁是通过互斥保障原子性的。互斥就是一个锁一次只能被一个线程持有。因此一个线程持有一个锁时，其他线程无法获得锁，只能等待其释放该锁后再申请。这就保证了临界区代码一次只能被一个线程执行。因此，一个线程执行临界区期间没有其他线程能够访问相应的共享数据，这使得临界区代码所执行的操作自然而然地具有不可分割的特性，即具备了原子性。

从互斥的角度来看，锁讲多个线程对共享数据的访问由原来的并发改为了串行。虽然实现并发时多线程编程的目标，但这种并发往往是并发中带有串行的局部并发。

### 保障可见性

可见性的保障时通过写线程冲刷处理器缓存和读取线程刷新处理器缓存这两个动作实现的。

在Java平台中，锁的获得隐含着刷新处理器缓存的动作，这使得读线程在执行临界区代码前可以将写线程对共享变量的更新同步到该线程执行处理器的高速缓存中。

锁的释放隐含着冲刷处理器缓存的动作，这使得写线程多共享变量所作的更新能够从不能被其他处理器共享的写缓冲器推送到高速缓存中，从而对读线程可同步。

因此，锁能够保障可见性。

锁对可见性的保障使线程在临界区读取到的共享变量是相对新值，锁的互斥性使同一个锁所保护的共享数据一次只能被一个线程访问，所以临界区读取的相对新值同时又是最新值。

### 保障有序性

锁能够保证有序性。即写线程在临界区的源代码顺序与其他线程对其的感知顺序是一致的。

这是锁对原子性和可见性的保障的结果。

由于锁对可见性的保障，写线程在临界区中对任何共享变量的更新都对其他线程可见；由于锁对原子性的保障，写线程对多个变量的更新会同时其他线程可见。这意味着其他线程无法也没有必要区分写线程是以什么顺序更新若干个共享变量的，那么就可以认为是按照源代码顺序更新共享变量的，即保障了有序性。

这种对有序性的保障并不意味着临界区的内存操作不能被重排序。只是这种重排序在原子性和可见性的保障下不再会影响有序性。

### 锁保证线程安全的条件

锁对原子性、可见性、有序性的保障是有条件的，需满足以下两点：

* 多个线程访问同一组共享数据时必须使用同一个锁
* 这些线程中的任意一个线程，即使其仅读取这组共享数据而没有对其更新，也需要在读取时持有相应的锁

## 锁相关的概念

### 可重入性

如果一个线程持有一个锁的时候还能继续成功申请该锁，那么就称该锁是可重入的(Reentrant)，否则就称该锁位非可重入的(Non-reentrant)

可重入锁一般是通过锁对象的计数器属性实现的。计数器初始值为0，表示相应的锁还没有被任何线程持有。每次线程获得一个可重入锁的时候，该锁的计数器值就会加1.每次一个线程释放锁的时候，计数器就减一。

### 锁的争用与调度

锁可以被看所多线程程序访问共享数据时所需持有的一种排他性资源。因此，资源的争用、调度的概念也适用于锁。

Java平台中锁的调度策略也包括公平策略和非公平策略，相应的锁就被成为公平锁和非公平锁。

内部锁属于非公平锁，而显示锁既支持公平锁又支持非公平锁。

### 锁的粒度

一个锁实例可以保护一个或者多个共享数据。一个锁实例所保护的共享数据大小就被称为该锁的 粒度(Granularity)。一个锁实例保护的共享数据的数量大，我们就称该锁的粒度粗，否则就称该锁的粒度细。

锁的粒度过粗会导致线程在申请锁的时候进行不必要的等待；锁的粒度过细会增加锁调度的开销

## 锁的开销和可能导致的问题

锁的开销包括锁的申请和释放所产生的开销，以及锁可能导致的上下文切换的开销。

多个线程争用排他性资源可能导致上下文切换；锁作为一种排他性资源一旦被争用就可能导致上下文切换。

此外，锁的不正确使用会导致以下线程故障：

* 锁泄露：指一个线程获得某个锁后，由于程序的错误、缺陷导致该锁一直无法被释放而导致其他线程一直无法获得该锁的现象。
* 死锁、锁死等线程活性故障

# 内部锁:synchronized









