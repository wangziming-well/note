# 线程同步机制概述

上一节从软硬件的角度来分析线程安全问题。但从应用程序的角度来看，线程安全问题的产生是由于多线程应用程序缺少线程同步机制。

线程同步机制是一套用于协调线程间的数据访问和活动的机制。该机制用以保障线程安全以及实现这些线程的共同目标。

Java提供的线程同步机制包括锁、volatile关键字、final关键字、static关键字以及相关的API(如Object.wait()/ Object.notify())等。本篇介绍Java平台中用于协调线程间共享数据访问的相关关键字和API

# 锁概述

线程安全问题的产生的前提是多个线程并发访问共享数据。那么一种保障线程安全的方法就是：讲多个线程多共享数据的并发访问转换未串行访问，即一个共享数据一次只能被一个线程访问，该线程访问结束后其他线程才能对其进行访问。锁(Lock)就是利用这种思路以保障线程安全的线程同步机制

一个线程在访问共享数据前必须申请相应的锁，线程的这个动作被称为锁的获得；一个线程获得某个锁，我们就称该线程为相应锁的持有线程，一个锁一次只能被一个线程持有。

锁的持有线程可以对该锁所保护的共享数据进行访问，访问结束后该线程必须释放相应的锁。锁的持有线程在其获得锁之后和释放锁之前这段时间内所执行的代码被称为临界区。因此，共享数据只允许在临界区内进行访问，临界区一次只能被一个线程执行。

如果有多个线程访问同一个锁所保护的共享数据，那么我们就称这些同步线程在这个锁上，或者称我们对这些线程所进行的共享数据访问进行加锁；相应地，这些线程所执行的临界区就被称为这个锁所引导的临界区。

锁具有排他性，即一个锁一次只能被一个线程持有。因此这种锁被称为排他锁或者互斥锁。后续还有另外一种锁，读写锁。它可以被看作排他锁的一种相对改进。

JVM对锁的实现方式划分，分为内部锁和显示锁。内部锁通过`synchronized`关键字实现的；显示锁是通过`java.conurrent.locks.Lock`接口的实现类实现的。

## 锁的作用

锁能够保护共享数据以实现线程安全，包括保障原子性、可见性和有序性。

### 保障原子性

锁是通过互斥保障原子性的。互斥就是一个锁一次只能被一个线程持有。因此一个线程持有一个锁时，其他线程无法获得锁，只能等待其释放该锁后再申请。这就保证了临界区代码一次只能被一个线程执行。因此，一个线程执行临界区期间没有其他线程能够访问相应的共享数据，这使得临界区代码所执行的操作自然而然地具有不可分割的特性，即具备了原子性。

从互斥的角度来看，锁讲多个线程对共享数据的访问由原来的并发改为了串行。虽然实现并发时多线程编程的目标，但这种并发往往是并发中带有串行的局部并发。

### 保障可见性

可见性的保障时通过写线程冲刷处理器缓存和读取线程刷新处理器缓存这两个动作实现的。

在Java平台中，锁的获得隐含着刷新处理器缓存的动作，这使得读线程在执行临界区代码前可以将写线程对共享变量的更新同步到该线程执行处理器的高速缓存中。

锁的释放隐含着冲刷处理器缓存的动作，这使得写线程多共享变量所作的更新能够从不能被其他处理器共享的写缓冲器推送到高速缓存中，从而对读线程可同步。

因此，锁能够保障可见性。



### 保障有序性