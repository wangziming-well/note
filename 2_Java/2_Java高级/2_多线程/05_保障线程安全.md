# 无状态对象

**状态变量**：对象就是操作和数据的封装。对象所包含的数据被称为该对象的状态，它包括存储在实例变量或者静态变量之中的数据。以恶对象的状态也可能包换该对象引用的其他对象的实例变量或者静态变量种的数据。实例变量、静态变量也被称为状态变量。

**无状态对象**：如果一个类的同一个实例被多个线程共享并不会使这些线程存在共享状态，那么这个类极其任意一个实例就被称为无状态对象；反之称为有状态对象。

无状态对象不含任何实例变量，且不包含任何静态变量或者其包含 静态变量都是只读的。

有状态对象又可以分为状态可变对象和状态不可变对象。

线程安全问题产生的前提是多个线程之间存在共享数据。因此，实现线程安全的一种自然方式就是避免在多个线程之间共享数据。使用无状态对象就可以达成这样的目的：一个线程执行无状态对象的任意一个方法阿来完成某个计算的时候，该计算产生的所有变量和数据都是方法上的局部变量，其他线程无法访问。所以，无状态对象具有固有的线程安全性，它被多个线程共享时无需使用同步机制。

无状态对象不包含任何实例变量或者可更新静态变量，但是一个不包含任何实例变量或则和静态变量却不一定是无状态对象。比如一个没有变量的对象方法有对单例的线程不安全的类访问；此时多个线程调用该方法会造成线程不安全。

# 不可变对象

不可变对象是指一经创建其状态就保持不变的对象。不可变对象也具有固有的线程安全性。

一个不可变对象要同时满足以下所有条件：

* 类本身使用`final`修饰
* 所有字段都是使用`final`修饰
* 对象在初始化过程中没有溢出
* 任何字段，如果引用了其他状态可变的对象(如集合，数组等)，则这些字段必须是private私有的，若相关方法要返回这些字段值，则应该进行防御性复制

对于不可变对象，如果需要其改变它保存的状态；则常常创建一个新的对象来替换；而不是直接改变对象状态；如果会进行这种替换操作，在多线程环境下，需要使用`volatile`关键西修饰不可变对象的变量，以保证替换的可见性和原子性。

这种对不可变对象替换会带来较大的内存开销：创建不可变对象的时候尽可能让新的不可变对象于老的不可变对象共享部分内存空间。

**典型应用场景**

* 被建模对象的状态变化不频繁。对象建模状态的变化通过创建新的不可变对象替换旧对象来实现，通过`volatile`关键字修饰不可变对象的变量，既可以保证原子性，也可以保证可见性。
* 同时对一组相关的数据进行写操作。使用不可变队形可以保证原子性，并且避免对锁的应用
* 使用不可变对象作为Map的键

# 线程特有对象

