# 无状态对象

**状态变量**：对象就是操作和数据的封装。对象所包含的数据被称为该对象的状态，它包括存储在实例变量或者静态变量之中的数据。以恶对象的状态也可能包换该对象引用的其他对象的实例变量或者静态变量种的数据。实例变量、静态变量也被称为状态变量。

**无状态对象**：如果一个类的同一个实例被多个线程共享并不会使这些线程存在共享状态，那么这个类极其任意一个实例就被称为无状态对象；反之称为有状态对象。

无状态对象不含任何实例变量，且不包含任何静态变量或者其包含 静态变量都是只读的。

有状态对象又可以分为状态可变对象和状态不可变对象。

线程安全问题产生的前提是多个线程之间存在共享数据。因此，实现线程安全的一种自然方式就是避免在多个线程之间共享数据。使用无状态对象就可以达成这样的目的：一个线程执行无状态对象的任意一个方法阿来完成某个计算的时候，该计算产生的所有变量和数据都是方法上的局部变量，其他线程无法访问。所以，无状态对象具有固有的线程安全性，它被多个线程共享时无需使用同步机制。

无状态对象不包含任何实例变量或者可更新静态变量，但是一个不包含任何实例变量或则和静态变量却不一定是无状态对象。比如一个没有变量的对象方法有对单例的线程不安全的类访问；此时多个线程调用该方法会造成线程不安全。

# 不可变对象

不可变对象是指一经创建其状态就保持不变的对象。不可变对象也具有固有的线程安全性。

一个不可变对象要同时满足以下所有条件：

* 类本身使用`final`修饰
* 所有字段都是使用`final`修饰
* 对象在初始化过程中没有溢出
* 任何字段，如果引用了其他状态可变的对象(如集合，数组等)，则这些字段必须是private私有的，若相关方法要返回这些字段值，则应该进行防御性复制

对于不可变对象，如果需要其改变它保存的状态；则常常创建一个新的对象来替换；而不是直接改变对象状态；如果会进行这种替换操作，在多线程环境下，需要使用`volatile`关键西修饰不可变对象的变量，以保证替换的可见性和原子性。

这种对不可变对象替换会带来较大的内存开销：创建不可变对象的时候尽可能让新的不可变对象于老的不可变对象共享部分内存空间。

**典型应用场景**

* 被建模对象的状态变化不频繁。对象建模状态的变化通过创建新的不可变对象替换旧对象来实现，通过`volatile`关键字修饰不可变对象的变量，既可以保证原子性，也可以保证可见性。
* 同时对一组相关的数据进行写操作。使用不可变队形可以保证原子性，并且避免对锁的应用
* 使用不可变对象作为Map的键

# 线程特有对象

如果多个线程需要共享一个非线程安全的对象，那么我们往往需要借助锁来保障线程安全。

但是我们也可以选择不共享线程安全对象：为每一个线程都创建一个该对象的实例，各个线程仅访问各自创建的实例， 且一个线程不能访问另外一个线程创建的实例。

这种各个线程创建各自的实例，一个实例只能被一个线程访问的对象就被称为线程特有对象(Thread Specific Object)相对应的线程就被称为该线程特有对象的持有线程。

使用线程特有对象即保障了线程安全又避免了锁的开销。

`ThreadLocal`类相当于线程访问其线程特有对象的代理，各个线程通过这个对象可以创建并访问各自的线程特有对象，其泛型`T`指定了相应线程特有对象的类型。

一个线程可以使用不同的`ThreadLocal`实例来创建并访问其不同的线程特有对象。对个线程可以使用同一个`ThreadLoacl<T>`实例锁访问到的对象是类型`T`的不同实例，即这些线程各自的线程特有对象实例。

`ThreadLocal`实例为每个访问它的线程都关联了一个该线程的线程特有对象。即每个`ThreadLocal<T>`实例都有一个与当前线程的特有对象T的实例与之关联，这种关联关系就行一个变量总是有一个值与之关联一样，因此`ThreadLocal`实例也别称为线程局部变量(Thread-local Variable)

`ThreadLocal`类的常用方法如下：

~~~java
void set(T value);
//设置当前线程的线程特有对象。
T get();
//返回当前线程的线程特有对象。如果变量没有当前线程的值，则首先将其初始化为调用 initialValue 方法返回的值。
void remove();
//删除当前线程的线程特有对象。
protected T initialValue();
//返回此线程局部变量的当前线程的“初始值”。此方法将在线程第一次使用 get 方法访问变量时调用，除非线程之前调用了 set 方法，在这种情况下，不会为线程调用 initialValue 方法。通常，每个线程最多调用一次此方法，但如果随后调用 remove 后跟 get，则可以再次调用此方法。
//此实现仅返回 null;如果程序员希望线程局部变量具有 null 以外的初始值，则必须对 ThreadLocal 进行子类化，并重写此方法。通常，将使用匿名内部类。
~~~

## ThreadLocal实现

为了实现不同线程访问得到不同的线程特有对象的功能，每个Thread类实例维护一个`ThreadLocalMap`:

~~~java
ThreadLocal.ThreadLocalMap threadLocals = null;
~~~

`ThreadLocalMap`是`ThreadLcoal`自定义的哈希映射，其维护的键值对：键为线程局部变量`ThreadLocal`实例，值为线程局部变量关联的线程特有对象

`ThreadLocal.set(T)`方法最终调用`ThreadLocalMap.set()`方法，入参键为this当前ThreadLocal实例本身，值为要设置的value

相应的`ThreadLocal.get()`方法则调用`ThreadLocalMap.getEntry()`，入参为键this当前ThreadLocal实例本身。

这样`ThreadLocalMap`就维护了ThreadLocal实例与线程特有对象之间的映射关系

## 可能导致的问题

### 退化和数据错乱

由于线程和任务之间可能是一对多的关系，即一个线程可能先后执行多个任务，因此线程特有对象就相当于一个线程锁执行的多个任务之间的共享对象。

如果这个线程特有对象是个有状态对象并且状态会随着执行任务而改变，那么这个线程所执行的下一个任务可能看到来自前一个任务的数据，这个数据与该任务并不匹配，导致数据操作。

为了防止这种现象，我们需要在每个任务执行前，重新关联一个线程特有对象，或者重置线程特有队形的状态。这导致了线程特有对象实际上的退化：线程特有对象对每个任务都是独立的。

### 内存泄露

**内存泄露：**指由于对象无法被垃圾回收导致其占用的JVM内存无法被释放。持续的内存泄露会导致JVM可用内存逐渐减少，最终导致OOM内存溢出

**伪内存泄露：**类似于内存泄露，不同的是，伪内存泄露中对象所占用的内存在其不被使用后相当长时间仍然无法被回收。

我们已经知道`ThreadLocal`是通过`Thread`实例持有的 `ThreadLcaolMap`实例来维护线程特有对象的

`ThreadLocalMap`内部通过`Entry[]`数组存储键值对；这里的`Entry`是继承自`WeakReference`;`Entry`对它的键`ThreadLocal<?>`实例的引用是一个弱引用，因此它不会阻止被引用的`ThreadLocal`实例被垃圾回收。

所以当一个`ThreadLocal`实例没有对其可达的强引用时，这个实例可以被垃圾回收；此时，相应的`Entry`就成为无效条目(它的键已被垃圾回收置为null，但值线程特有对象却没有)

因为无效条目对线程特有对象是强引用的，所以它会阻止其线程特有对象被垃圾回收。为了尽量避免无效条目的线程持有对象无法被垃圾回收导致的内存泄露。当`ThreadLocalMap`中有新的`ThreadLocal`到线程特有对象的映射被创建时(调用`ThreadLocal.set()`设置一个新的`ThreadLocal`实例键值对)，会将无效条目清理掉(通过`ThreadLocal.cleanSomeSlots()`),此时无效条目对应的线程特有对象就能够被垃圾回收。

但是这样处理的缺点就是：当一个线程访问过线程局部变量之后，如果该线程在长时间内处于非运行状态时或者没有再创建新的`ThreadLocal`与线程特有对象的映射关系，那么`ThreadLocalMap`中的无效条目就无法被清理，这就可能导致这些线程的各个`Entry`所引用的线程特有对象无法被垃圾回收，导致了伪线程泄露

为了避免这种内存泄露，我们需要在一个线程使用完其线程特有对象时，调用`ThreadLocal.remove()`删除对应`Entry`

# 并发集合

JDK1.5的`java.util.concrrent`包中引入了一些线程安全的集合对象，它们并称为并发集合。

并发集合对象支持对其进行线程安全的遍历操作。并且对并发集合的遍历操作和对其进行更新的操作可以由不同的线程并发执行。

并发集合实现线程安全的遍历通常有两种方法：

* 对遍历对象的快照进行遍历。快照是在`Iteraor`实例被创建的那一刻待遍历对象内部结构的一个只读副本
  * 优点：遍历操作和更新操作互不影响
  * 缺点：当遍历的集合比较大是，创建快照的直接或者间接开销会比较大
* 对遍历对象进行准实时的遍历。
  * 缺点：遍历过程中其他线程对遍历对象的内部结构的更新可能会被反映出来
  * 优点：支持remove方法

并发集合内部在保障其线程安全的时候通常不借助锁，而是使用CAS操作，或者对锁的使用进行了优化，比如使用粒度较小的锁。因此，并发集合的可伸缩性一般要比相应的同步集合要高

**`ConcurrentLinkedQueue`**:是`Queue`接口的一个线程安全类，相当于`LinkedList`的线程安全版。`ConcurrentLinekedQueue`内部访问其共享状态变量的时候不借助锁，而是使用CAS操作来保障线程安全。因此它是非阻塞的，避免了上下文的开销。其使用的遍历方式是准实时的。其更适合于更新和遍历操作并发的场景。

**`ConcurrentHashMap`**:是Map接口的一个线程安全类，相当于`HashMap`的线程安全版。其内部使用了粒度极小的锁来保障线程安全。其读操作几乎不会导致锁的使用

**`CopyOnWriteArrayList`**:是List接口的一个线程安全类，相当于ArrayList的线程安全版。其内部通过维护一个数组来储存元素。对元素的更新是通过创建一个新的数组，把老的数组替换掉来实现的；整个替换过程使用来显式锁保证并发修改的安全；所以它的更新操作开销很大(复制新数组的内存开销；锁的上下文开销)，所以它更适合读多写少的场景。

**`CopyOnWriteArraySet`**:是`Set`接口的一个线程安全实现类，相当于`HashSet`的线程安全版。其内部实现了一个`CopyOnWriteArrayList`,所以其特性和使用场景和`CopyOnWriteArraySet`类似







