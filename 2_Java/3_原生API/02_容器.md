# Java容器类概述

很多时候，程序是根据运行时才知道的某些条件去创建新对象。在编译时，我们可能无法知道这样的对象的数量和类型；这需要程序能够在任意位置创建任意数量的对象。所以，不能依靠创建命名的引用来持有每一个对象:

~~~java
MyType aReference;
~~~

这只适用于在编译时就知道确切数量和类型信息的情况；并且如果需要创建的对象数量很大，直接创建命名的引用也很繁琐

所以和大多数程序语言一样，Java提供了容器对象以持有其他对象(确切地说是对象的引用)；如数组类型，但数组只能持有固定数量的对象，并且结构简单，很受局限且功能单一；除了数组类型，Java类型提供了专门的容器类以持有对象

Java容器类根据结构和特征可划分为两大类：

* Collection:保存对象的集合，这些元素都服从一条或者多条规则；如Set保存的元素必须唯一，List按照插入的顺序保存元素
* Map:保存键值对对象的映射表，或者称为字典、散列表

# 数组

数组通过整数索引值访问它们的元素，并且数组的大小不能改变

数组相比与Java中的其他容器类型很特殊：

* 效率：数组是一种效率最高的存储和随机访问对象引用序列的方式；因为它是一个简单的线性序列
* 持有基本类型：数组可以直接持有基本数据类型，而其他容器因为泛型，只能持有基本类型的包装类型

## Arrays

Arrays为数组提供一系列工具方法：









# Collection概述

Collection为一个基本的Java容器规范了行为，其继承体系如下：

![Collection](https://gitee.com/wangziming707/note-pic/raw/master/img/Collection.png)

Collection下主要有三类：List、Set、Queue；它们各自有不同的特征

Collection规范如下行为：

* 获取容器状态：

  ~~~java
  int size();//返回此集合中元素的数目。如果此集合包含多于Integer.MAX_VALUE元素，返回Integer.MAX_VALUE。
  boolean isEmpty();//如果此集合不包含任何元素，则返回true
  boolean contains(Object o);//如果此集合包含指定的元素，则返回true。更正式地说，当且仅当此集合包含至少一个元素e满足(o==null ? e==null: o.equals(e))
  boolean containsAll(Collection<?> c);//如果此集合包含指定集合中的所有元素，则返回true
  ~~~

* 添加元素：

  ~~~java
  boolean add(E e);//确保此集合包含指定的元素。如果此集合因调用而更改，则返回true。(如果此集合不允许重复且已包含指定元素，则返回false)
  boolean addAll(Collection<? extends E> c);//将指定集合中的所有元素添加到此集合。
  ~~~

* 删除元素

  ~~~java
  boolean remove(Object o);//从此集合中删除指定元素的单个实例(如果存在);如果此集合因调用而更改，则返回true。
  boolean removeAll(Collection<?> c);//移除指定集合中也包含的此集合的所有元素。在此调用返回后，此集合将不包含与指定集合相同的元素;如果此集合因调用而更改，则返回true
  boolean removeIf(Predicate<? super E> filter);//删除此集合中满足给定谓词的所有元素。在迭代期间或由谓词抛出的错误或运行时异常将传递给调用方;如果删除任何元素，返回true
  boolean retainAll(Collection<?> c);//仅保留此集合中包含在指定集合中的元素。换句话说，从此集合中删除未包含在指定集合中的所有元素。
  void clear();//从该集合中删除所有元素。此方法返回后，集合将为空
  ~~~

* 转换数组

  ~~~java
  Object[] toArray();//返回包含此集合中所有元素的数组。如果此集合保证其迭代器返回元素的顺序，则此方法必须以相同的顺序返回元素。
  <T> T[] toArray(T[] a);//返回一个包含此集合中所有元素的数组;返回数组的运行时类型为指定数组的运行时类型。如果集合适合指定的数组，则在其中返回它。否则，将使用指定数组的运行时类型和此集合的大小分配新数组。如果此集合保证其迭代器返回元素的顺序，则此方法必须以相同的顺序返回元素。
  ~~~

* 迭代器方法

  ~~~java
  Iterator<E> iterator();//返回该集合的迭代器
  ~~~

* 支持Stream编程

  ~~~java
  default Spliterator<E> spliterator();
  default Stream<E> stream();
  default Stream<E> parallelStream();
  ~~~

## Iterator和Iterable







# List

List是有序集合(也称为序列)。序列可以精确控制在列表中插入每个元素的位置。可以通过整数索引(在列表中的位置)访问元素，并在序列中搜索元素。

除了继承自Collection的方法，List有如下独有方法：

* 操作方法

  ~~~java
  boolean addAll(int index, Collection<? extends E> c);
  //将指定集合中的所有元素插入到该列表的指定位置(可选操作)。将当前在该位置的元素(如果有的话)和任何后续元素向右移动(增加它们的索引)。新元素将按照指定集合的迭代器返回的顺序出现在列表中。
  void replaceAll(UnaryOperator<E> operator);
  //将此列表中的每个元素替换为对该元素应用operator的结果
  void sort(Comparator<? super E> c);
  //根据指定的Comparator产生的顺序对该列表进行排序。
  E set(int index, E element);
  //将此列表中指定位置的元素替换为指定元素
  void add(int index, E element);
  //将指定元素插入此列表中的指定位置。将当前在该位置的元素(如果有的话)和任何后续元素向右移动(在它们的索引上加1)。
  E remove(int index);
  //移除列表中指定位置的元素(可选操作)。将所有后续元素向左移动(从它们的索引中减去1)。返回从列表中删除的元素。
  ~~~

* 访问方法

  ~~~java
  E get(int index);
  //返回列表中指定索引位置的元素
  int indexOf(Object o);
  //返回指定元素在此列表中第一次出现的索引，如果此列表不包含该元素，则返回-1
  int lastIndexOf(Object o);
  //返回指定元素在此列表中最后出现的索引，如果此列表不包含该元素，则返回-1
  ListIterator<E> listIterator();
  //返回一个遍历此列表中元素的ListIterator(按适当的顺序)。
  ListIterator<E> listIterator(int index);
  //返回遍历此列表中元素的列表迭代器(以适当的顺序)，从列表中的指定位置开始。指定的索引指示初始调用next将返回的第一个元素。对previous的初始调用将返回具有指定索引- 1的元素。
  List<E> subList(int fromIndex, int toIndex);
  //返回该列表中介于指定的fromIndex(包含)和toIndex(不包含)之间的部分的视图。(如果fromIndex和toIndex相等，返回的列表为空。)
  ~~~

List主要有两个实现类：

* ArrayList：长于随机访问，但进行插入和移除操作慢
* LinkedList：随机访问慢，但插入和删除的代价低

## ArrayList

底层仍然是定长数组，内部维护数组









































# Stream流中的函数式接口

## Predicate

* 表示一个参数的谓词（布尔值函数）。 

* 抽象方法：

  boolean `test(T t)`  ：在给定的参数上计算这个谓词。 

* 默认方法

  * `default Predicate<T> and(Predicate<? super T> other) `
    返回一个由谓词表示短路逻辑和谓词和另一个。  
  * `default Predicate<T> negate() `
    返回一个表示该谓词的逻辑否定的谓词。  
  * `default Predicate<T> or(Predicate<? super T> other) `
    返回一个由谓词表示短路逻辑或该谓词和另一个。  



## Supplier

* 表示结果的供应商。 
* 抽象方法：`T get() `：得到一个结果。 

## Consumer

* 表示接受一个输入参数，并返回没有结果的操作。

* 抽象方法：

  `void accept(T t)`  在给定的参数上执行此操作。

* 默认方法：  

  `default Consumer<T> andThen(Consumer<? super T> after) `
  返回一个由 Consumer执行此操作，在序列，其次是 after操作。  

## Function<T,R>

* 表示接受一个参数并产生结果的函数。 

* 抽象方法：

  `R apply(T t) ` 将此函数应用于给定的参数。  

* 默认方法：

  `default <V> Function<V,R> compose(Function<? super V,? extends T> before) `
  返回一个由功能，首先应用 before函数的输入，然后将该函数的结果。  



# Stream接口

JDK8最重要的新特性之一。

可以操作一系列元素。用于操作集合和数组

模拟流水线

流只能用一次，且不改变集合和数组的原有元素



## 获取Stream流对象

* 集合获取Stream流：

  Collection接口中有Stream stream()返回单列集合的流对象

* 数组获取Stream流

  Arrays数组工具类中的

  * Stream stream(arr)
  * Stream stream(arr,startIndex,endIndex)

* 数据获取Stream流

  Stream接口中有静态方法Stream of(....)



## 成员方法



### 延迟方法

Stream<T> filter(Predicate<? super T> predicate) 
返回由该流的元素组成的流，该元素与给定的谓词匹配。  

Stream<T> limit(long maxSize) 返回由此流的元素组成的流，截短长度不能超过 maxSize 。

Stream<T> skip(long n) 在丢弃流的第一个 n元素后，返回由该流的剩余元素组成的流。 

<R> Stream<R> map•(Function<? super T,? extends R> mapper) 返回由给定函数应用于此流的元素的结果组成的流。 

static <T> Stream<T> concat•(Stream<? extends T> a, Stream<? extends T> b) 创建一个懒惰连接的流，其元素是第一个流的所有元素，后跟第二个流的所有元素。  

Stream<T> parallel() 
返回一个并行的等效流。 

### 终结方法

void forEach(Consumer<? super T> action) 
对该流的每个元素执行一个动作。  

long count() 返回此流中的元素数。  