TODO 补充继承体系图片，补充方法说明

# File

`File`是文件和目录路径名的抽象表示形式，File也可成为抽象路径名

File实例不仅可以表示存在的文件或者目录，也可以用来创建新的目录/文件

## 路径

在计算机操作系统中使用路径来确定文件在操作系统中的存储位置

路径由文件夹/文件名和分隔符组成

不同系统的分隔符不同，可以通过以下方式获取当前系统的分隔符：

~~~java
String sepa = java.io.File.separator;    
String sepa1 = System.getProperty("file.separator");
~~~

### 绝对路径

绝对路径就是从头开始，在操作系统中能唯一确定文件/文件夹地址的路径，

在liunx系统中用`/`表示绝对路径的开始，如`/usr/dir/abc.txt`

在windows系统中，用盘符加上`://`表示绝对路径的开始，如`D://Data/abc.txt`

### 相对路径

相对路径是相对于指定路径的路径,对于不同的指定路径，相对路径的指向是不同的。

java中，可以通过`System.getProperty("user.dir")`获取用户当前的工作目录

默认情况下java.io包中所有类使用的相对路径就是相对于这个当前工作目录的。

用`.`表示相对路径路径，用`..`表示相对的路径的上一级路径。

* 在idea调试中，这个当前工作目录在Debug Configurations中的Working directory设置

  ![image-20230810110137155](https://gitee.com/wangziming707/note-pic/raw/master/img/idea%E5%B7%A5%E4%BD%9C%E7%9B%AE%E5%BD%95.png)

* 直接使用使用`java`命令启动的java项目，其当前工作目录就是该jar包或者class文件所在的文件夹

* 使用tomcat启动的项目，其当前工作目录为该tomcat的bin目录

  所以在web项目中一般不直接受用工作目录的相对路径，而是以项目中的resources文件夹为相对路径

## 创建File对象

可以使用下面方法创建File实例：

~~~java
File(String pathname);
//通过路径创建File实例，可以是绝对路径或者是相对路径
File(URI uri);
//通过uri创建File实例
File(String parent, String child);
File(File parent, String child);
//通过子父路径创建File实例，parent必须表示文件夹,child可以表示文件夹也可以表示文件。
~~~

## 访问文件属性

可以通过File提供的如下方法访问文件/文件夹的属性

~~~java
String getName();
//返回由此抽象路径名表示的文件或目录的名称
String getParent();
//返回由此抽象路径名表示的文件或目录所在的文件夹(即父级路径)
File getParentFile();
//返回由此抽象路径名表示的文件或目录所在的文件夹对应的File实例
String getPath();
//返回抽象路径名对应的标准格式。
boolean isAbsolute();
//判断此抽象路径名是否为绝对路径名
String getAbsolutePath();
//返回此抽象路径名的绝对路径名字符串
File getAbsoluteFile();
//返回此抽象路径名的绝对形式。等效于 new File(this.getAbsolutePath)
String getCanonicalPath();
//返回此抽象路径名的规范路径名字符串,规范路径名是绝对路径，且是唯一的。其定义取决于操作系统。通常是解析去掉路径中多余的.和..
File getCanonicalFile();
//返回此抽象路径名的规范形式。等效于 new File(this.getCanonicalPath)
URI toURI();
//构造一个表示此抽象路径名的 URI
boolean canRead();
//判断应用程序是否可以读取此抽象路径名表示的文件。在某些平台上，可以使用特殊权限启动 JVM，以允许其读取标记为不可读的文件。因此，即使文件没有读取权限，此方法也可能返回 true
boolean canWrite();
//判断应用程序是否可以修改此抽象路径名表示的文件。在某些平台上，可以使用特殊权限启动 JVM，以允许其修改标记为只读的文件。因此，即使文件标记为只读，此方法也可能返回 true。
boolean exists();
//判断此抽象路径名表示的文件或目录是否存在
boolean isDirectory();
//判断此抽象路径名表示的文件是否为目录
boolean isFile();
//测试此抽象路径名表示的文件是否为普通文件。Java 应用程序创建的任何非目录文件都保证为普通文件。
boolean isHidden();
//测试以此抽象路径名表示的文件是否为隐藏文件
long lastModified();
//返回以此抽象路径名表示的文件的最后修改时间
long length();
String[] list();
String[] list(FilenameFilter filter);
File[] listFiles();
File[] listFiles(FilenameFilter filter);
File[] listFiles(FileFilter filter);
boolean canExecute();
long getTotalSpace();
long getFreeSpace();
long getUsableSpace();
int compareTo(File pathname);
Path toPath();
~~~

## 操作文件

~~~java
boolean createNewFile();
boolean delete();
void deleteOnExit();
boolean mkdir();
boolean mkdirs();
boolean renameTo(File dest);
boolean setLastModified(long time) ;
boolean setReadOnly();
boolean setWritable(boolean writable, boolean ownerOnly);
boolean setWritable(boolean writable);
boolean setReadable(boolean readable, boolean ownerOnly);
boolean setReadable(boolean readable);
boolean setExecutable(boolean executable, boolean ownerOnly);
boolean setExecutable(boolean executable);

~~~

## 静态方法

~~~java
File[] listRoots();
File createTempFile(String prefix, String suffix,File directory);
File createTempFile(String prefix, String suffix);
~~~

# IO概述

Java的I/O类库使用流这个抽象给i年，它代表任何有能力产出数据的数据源对象或者是有能力接收数据的接收端对象。流屏蔽了实际的I/O设备中处理数据的细节。

Java类库中的I/O类分为输入和输出两部分

* 输入：`InputStream`或`Reader`，提供`read()`基本方法，用于读取单个字节或者字节数组
* 输出：`outputStream`或`Writer`，提供`write()`基本方法，用于写单个字节或者字节数组

我们通常不会直接用到`read()`或者`write()`方法。这两个方法一般是提供给别的类使用，以提供更有用的接口。

因此我们很少使用单一的类来创建流对象，而是通过叠合多个对象来提供所期望的功能(装饰器设计模式)

## InputStream

`InputStream`用于表示那些从不同数据源产生输入的类

其主要子类如下：

| 类                        | 说明                                                        |
| ------------------------- | ----------------------------------------------------------- |
| `ByteArrayInputStream`    | 允许将内存的缓冲区当作InputStream使用                       |
| `StringBufferInputStream` | 将String转换成`InputStream`                                 |
| `FileInputStream`         | 从文件中读取数据                                            |
| `PipedInputStream`        | 产生用于写入相关`PipedOutputStream`的数据                   |
| `SequenceInputStream`     | 将两个或者多个InputStream对象转换为单一InputStream          |
| `FilterInputStream`       | 抽象类，作为装饰器的基类，为其他InputStream类提供有用的功能 |

## OutputStream

`OutputStream`决定了输出所要去往的目标：字节数组，文件或管道。

其常用子类如下：

| 类                      | 说明                                                       |
| ----------------------- | ---------------------------------------------------------- |
| `ByteArrayOutputStream` | 在内存中创建缓冲区。所有送往流的数据会放置到缓冲区中       |
| `FileOutputStream`      | 用于将数据写入文件                                         |
| `PipedOutputStream`     | 任何写入其中的信息都将自动作为相关`PipedInputStream`的输出 |
| `FilterOutputStream`    | 作为输出流装饰器的基类                                     |

# I/O流的装饰器

java I/O库需要多种不同功能的组合，所以使用装饰器模式，

使用装饰器模式，能为我们编码提供相当的灵活性，但也同时增加了代码的复杂性。

`FilterInputStream`和`FilterOutputStream`是用来提供装饰器类接口已控制特定输入输出流的两个类。

## FilterInputStream

不同的`FileterInputStream`能完成完全不同的事情。其中`DataInputStream`允许我们读取不同的基本数据类型以及String对象。搭配`DataOutputStream`我们就可以通过数据流将基本类型的数据从一个地方迁移到另一个地方。

其他`FilterInputStream`类则在内部修改`InputStream`的行为方式：是否缓冲，是否保留它读过的行，是否把单一字符推回输入流等。

`FilterInputStream`的常用子类如下：

| 类                      | 说明                                                     |
| ----------------------- | -------------------------------------------------------- |
| `DataInputStream`       | 能够直接读取基本数据类型                                 |
| `BufferedInputStream`   | 内部维护一个缓冲区，防止每次读取的时候都需要实际的写操作 |
| `LineNumberInputStream` | 跟踪输入流中的行号，已弃用                               |
| `PushBackInputStream`   | 可以将读到的最后一个字节回退                             |

## FilterOutputStream

` FilterOutputStream`的常用子类如下：

| 类                     | 说明                                                         |
| ---------------------- | ------------------------------------------------------------ |
| `DataOutputStream`     | 可以直接写入基本数据类型                                     |
| `PrintStream`          | 用于产生格式化输出，`System.out`就是该类型                   |
| `BufferedOutputStream` | 使用缓冲区，避免每次发送数据时都要进行实际的写操作。可以调用`flush()`清空缓冲区 |

# Reader和Writer

`InputStream`和`OutputStream`提供面向字节形式的I/O；而`Reader`和`Writer`则提供兼容Unicode与面向字符的I/O功能

字节流也可以通过适配器类转换为字符流：

* `InputStreamReader`可以把`InputStream`转换为`Reader`
* `OutputStreamWriter`可以把`OutputStream`转换为`Writer`

设计`Reader`和`Writer`继承层次结构主要是为了国际化，`InputStream`和`OutputStream`体系仅支持8位字节流，并不能很好的处理16位的Unicode字符。由于Unicode用于字符国际化。所以添加Reader和Writer继承层次结构就是为了在所有的I/O操作中都支持Unicode

## 对应关系

`InputStream`或者`OutputStream`都有有对应的`Reader`或`Writer`，来提供天然的Unicode操作。我们尽量使用Reader和Writer，只有在必须使用字节流的场合使用字节流。其对应如下：

| InputStream                       | Reader            | OutputStream            | Writer            |
| --------------------------------- | ----------------- | ----------------------- | ----------------- |
| `FileInputStream`                 | `FileReader`      | `FileOutputStream`      | `FileWriter`      |
| `StringBufferInputStream`(已弃用) | `StringReader`    | 无                      | `StringWriter`    |
| `ByteArrayInputStream`            | `CharArrayReader` | `ByteArrayOutPutStream` | `CharArrayWriter` |
| `PipedInputStream`                | `PipedReader`     | `PipedOutputStream`     | `PipedWriter`     |

## 装饰器

在字节流中`FilterInputStream`和`FilterOutputStream`作为装饰器基类衍生出了许多功能不同的I/O类，

但是在`Reader`和`Writer`中，虽然有字节流装饰器类衍生出来的类的对应类，但是没有相应的继承关系

比如虽然`BufferedInputStream`是`FilterInputStream`的子类，但`BufferReader`却不是`FilterReader`的子类

`FilterReader`和`FilterWriter`在这里仅仅作为一种占位符的存在。

| 字节流装饰器            | 字符流装饰器       |
| ----------------------- | ------------------ |
| `FilterInputStream`     | `FilterReader`     |
| `FilterOutputStream`    | `FilterWriter`     |
| `BufferedInputStream`   | `BufferedReader`   |
| `BufferedOutputStream`  | `BufferedWriter`   |
| `DataInputStream`       | `DataInputStream`  |
| `PrintStream`           | `PrintWriter`      |
| `LineNumberInputStream` | `LineNumberReader` |
| `StreamTokenizer`       | `StreamTokenizer`  |
| `PushbackInputStream`   | `PushbackReader`   |

# RandomAccessFile

一个`RandomAccessFile`实例同时支持向随机访问文件的读操作和写操作，

`RandomAccessFile`内支持游标的概念(或者说file pointer)读写操作都是在游标处进行的。完成读写后，游标自动向前移动。

可以通过`RandomAccessFile.getFilePointer()`获取当前游标位置，可以通过`RandomAccessFile.seek(long)`设置游标的位置



# I/O流使用模板

## 缓冲文件输入

~~~java
public class BufferedInputFile {
    public static String read(String filename) throws IOException {
        BufferedReader in = new BufferedReader(new FileReader(filename));
        StringBuilder sb = new StringBuilder();
        String s ;
        while ((s = in.readLine()) != null)
            sb.append(s).append("\n");
        in.close();
        return sb.toString();
    }
    public static void main(String[] args) throws IOException {
        System.out.println(read("ccc.txt"));
    }
}
~~~

## 内存输入

~~~java
public class MemoryInput {
    public static void main(String[] args) throws IOException {
        StringReader in = new StringReader(BufferedInputFile.read("ccc.txt"));
        int c;
        while ((c = in.read()) != -1)
            System.out.print((char)c);
    }
}
~~~

使用上一个模板中的方法读取文件内容的字符串。

## 格式化内存输入

~~~java
public class FormattedMemoryInput {
    public static void main(String[] args) throws IOException {
        DataInputStream in = new DataInputStream(new ByteArrayInputStream("123".getBytes(StandardCharsets.UTF_8)));
        try{
            while (true){
                System.out.print(in.readChar());
            }
        } catch (EOFException e){
            System.out.println("读取结束");
        }
    }
}
~~~

`readChar()`可能返回任何字符，所以没有返回可以表示读取结束；所以它通过抛出异常表示读取结束。

我们也可以通过`available()`的返回来判断当前流是否读取完毕。

## 文件输出

~~~java
public class BasicFileOutput {
    public static void main(String[] args) throws IOException {
        BufferedReader in = new BufferedReader(new FileReader("ccc.txt"));
        PrintWriter out = new PrintWriter(new BufferedWriter(new FileWriter("write.txt")));
        String s;
        while ((s = in.readLine())!= null)
            out.println(s);
        out.close();
    }
}
~~~

上面代码将文件复制了一份，写入指定的文件中

`PrintWriter`提供了直接写入文件的构造器，所以上面输出流的构造可以改为：

~~~java
PrintWriter out = new PrintWriter("write.txt");
~~~

