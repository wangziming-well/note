# 正则表达式语法

正则表达式是一种用于匹配和操作文本的工具。

正则表达式是由普通字符以及特殊字符组成的文字模式。正则表达式作为一个模式，将某个字符模式与所搜索的字符串进行匹配。

## 普通字符

普通字符包括没有显示指定为元字符的所有可打印和不可打印的字符。这包括所有大写和小写字符、所有数字、所有标点符号和一些其他符号。

| 字符     | 描述                                                         |
| :------- | :----------------------------------------------------------- |
| `[ABC]`  | 匹配` [...] `中的所有字符，例如` [al] `匹配字符串 "apple" 中所有的 a l 字母。 |
| `[^ABC]` | 匹配除了` [...] `中字符的所有字符，例如 `[^al]` 匹配字符串 "apple" 中除了 a l字母的所有字符。 |
| `[A-Z]`  | [A-Z] 表示一个区间，匹配所有大写字母，[a-z] 表示所有小写字母。 |
| `.`      | 匹配除换行符（\n、\r）之外的任何单个字符，相等于 `[^\n\r]`。 |
| `\w` | 匹配字母、数字、下划线。等价于`[A-Za-z0-9_]`。   |
| `\W` | 匹配非字母、数字、下划线。等价于 `[^A-Za-z0-9_]`。 |
| `\d` | 匹配一个数字字符。等价于` [0-9]`。  |
| `\D` | 匹配一个非数字字符。等价于 `[^0-9]`。 |

## 非打印字符

非打印字符也可以是正则表达式的组成部分。下表列出了表示非打印字符的转义序列：

| 字符  | 描述                                                         |
| :---- | :----------------------------------------------------------- |
| `\cx` | 匹配由x指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 'c' 字符。 |
| `\f`  | 匹配一个换页符。等价于 `\x0c` 和 `\cL`。                     |
| `\n`  | 匹配一个换行符。等价于` \x0a `和` \cJ`。                     |
| `\r`  | 匹配一个回车符。等价于` \x0d` 和` \cM`。                     |
| `\s`  | 匹配任何空白字符，包括空格、制表符、换页符等等。等价于` [ \f\n\r\t\v]`。注意 Unicode 正则表达式会匹配全角空格符。 |
| `\S`  | 匹配任何非空白字符。等价于 `[^ \f\n\r\t\v`]。                |
| `\t`  | 匹配一个制表符。等价于 `\x09` 和` \cI`。                     |
| `\v`  | 匹配一个垂直制表符。等价于 `\x0b` 和` \cK`。                 |

## 特殊字符

特殊字符即正则表达式语法的保留字，如果要匹配保留字，需要对其转义：

| 特别字符 | 描述                                                         |
| :------- | :----------------------------------------------------------- |
| `$`      | 匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 `$` 也匹配 '\n' 或 '\r'。要匹配 `$` 字符本身，请使用 `\$`。 |
| `()`     | 标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 `\( `和 `\)`。 |
| `*`      | 匹配前面的子表达式零次或多次。要匹配 `*` 字符，请使用` \*`。 |
| `+`      | 匹配前面的子表达式一次或多次。要匹配 `+` 字符，请使用 `\+`。 |
| `.`      | 匹配除换行符 \n 之外的任何单字符。要匹配 `.` ，请使用 `\. `。 |
| `[`      | 标记一个中括号表达式的开始。要匹配 `[`，请使用` \[`。        |
| `?`      | 匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配` ?` 字符，请使用 `\?`。 |
| `\`      | 将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， `n `匹配字符 `n`。`\n` 匹配换行符。序列 '`\\`' 匹配 `\`，而 `\(` 则匹配 `(`。 |
| `^`      | 匹配输入字符串的开始位置，除非在方括号表达式中使用，当该符号在方括号表达式中使用时，表示不接受该方括号表达式中的字符集合。要匹配 `^` 字符本身，请使用 `\^`。 |
| `{`      | 标记限定符表达式的开始。要匹配` {`，请使用` \{`。            |
| `|`      | 指明两项之间的一个选择。要匹配` |`，请使用` \|`。            |

## 限定符

限定符用来指定正则表达式的一个给定组件必须要出现多少次才能满足匹配。有 ***** 或 **+** 或 **?** 或 **{n}** 或 **{n,}** 或 **{n,m}** 共6种。

正则表达式的限定符有：

| 字符    | 描述                                                         |
| :------ | :----------------------------------------------------------- |
| `*`     | 匹配前面的子表达式零次或多次。例如，`zo* `能匹配 `z` 以及 `zoo`。`* `等价于 `{0,}`。 |
| `+`     | 匹配前面的子表达式一次或多次。例如，`zo+ `能匹配` zo `以及` zoo`，但不能匹配 `z`。`+ `等价于` {1,}` |
| `?`     | 匹配前面的子表达式零次或一次。例如，`do(es)? `可以匹配 `do` 、 `does`、 `doxy `中的 `do `和 `does`。`? `等价于 `{0,1}`。 |
| `{n}`   | n 是一个非负整数。匹配确定的 n 次。例如，o{2} 不能匹配 `Bob `中的 `o`，但是能匹配 `food`中的两个 `o`。 |
| `{n,}`  | n 是一个非负整数。至少匹配n 次。例如，`o{2,}` 不能匹配 `Bob`中的 o，但能匹配 `foooood` 中的所有 `o`。 |
| `{n,m}` | m 和 n 均为非负整数，其中 n <= m。最少匹配 n 次且最多匹配 m 次。例如，`o{1,3}` 将匹配 `fooooood `中的前三个` o` |

## 定位符

定位符能够将正则表达式固定到行首或行尾。或者定位到单词的边界

| 字符 | 描述                                                         |
| :--- | :----------------------------------------------------------- |
| `^`  | 匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与 \n 或 \r 之后的位置匹配。 |
| `$`  | 匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与 \n 或 \r 之前的位置匹配。 |
| `\b` | 匹配一个单词边界，即字与空格间的位置。                       |
| `\B` | 非单词边界匹配。                                             |

## 选择

用圆括号`()`  将所有选择项括起来，相邻的选择项之间用 `|` 分隔。

`()` 表示捕获分组，`()` 会把每个分组里的匹配的值保存起来， 多个匹配值可以通过数字 n 来查看(n 是一个数字，表示第 n 个捕获组的内容)。

## 修饰符

用修饰符指定正则表达式的匹配策略,标记不写在正则表达式里，标记位于表达式之外，格式如下：

~~~bash
/pattern/flags
~~~

下表列出了正则表达式常用的修饰符：

| 修饰符 | 含义                                   | 描述                                                         |
| :----- | :------------------------------------- | :----------------------------------------------------------- |
| i      | ignore - 不区分大小写                  | 将匹配设置为不区分大小写，搜索时不区分大小写: A 和 a 没有区别。 |
| g      | global - 全局匹配                      | 查找所有的匹配项。                                           |
| m      | multi line - 多行匹配                  | 使边界字符 `^` 和 `$` 匹配每一行的开头和结尾，记住是多行，而不是整个字符串的开头和结尾。 |
| s      | 特殊字符圆点 **.** 中包含换行符 **\n** | 默认情况下的圆点 **.** 是匹配除换行符` \n `之外的任何字符，加上 `s `修饰符之后, `.` 中包含换行符 `\n`。 |

如`/[a-z]*/i`能匹配`aFwEt`

# Java正则

`java.util.regex`对正则表达式进行了支持。通过`Pattern`和`Matcher`类对字符串运用正则表达式

## Pattern

`Pattern`表达式是对正则表达式的抽象，一个`Pattern`实例就代表一个正则表达式。

~~~java
public static Pattern compile(String regex);
public static Pattern compile(String regex, int flags);
public static boolean matches(String regex, CharSequence input);
public static String quote(String s);
public String pattern();
public String toString();
public Matcher matcher(CharSequence input);
public String[] split(CharSequence input, int limit);
public String[] split(CharSequence input);
public Stream<String> splitAsStream(final CharSequence input);
public Predicate<String> asPredicate();
~~~

### 静态方法

`Pattern`的构造器是私有的，可以通过它提供的静态方法`compile()`获取其实例：

~~~java
Pattern compile = Pattern.compile("^\\d*$");
~~~

注意：在java字符串中`\`本身就是转移字符`\n`会被解析为换行符。想要表达`\n`字符串，必须使用`\\n`。其中`\\`对`\`进行转义，表示`\`的字面含义。

`quote()`静态方法对字符串中，正则的特殊字符进行转义，让其确保它们被视为普通字符而不是正则表达式的构造元素：

~~~java
//匹配 字面含义的\n，可以使用:
Pattern.compile("\\\\n"); //其正则表达式为 \\n   匹配  \n
Pattern.compile(Pattern.quote("\\n")); //其正则表达式为 \Q\n\E  匹配 \n
~~~

`matches()`方法提供便捷的正则匹配，将给定的字符串和给定的正则表达式进行匹配：

~~~java
Pattern.matches("\\\\n","\\n"); //返回true
Pattern.matches(Pattern.quote("\\n"),"\\n"); //返回true
~~~

### 匹配模式

`Pattern.compile()`有一个带flags参数的形式，可以通过它设置匹配模式，它通过二进制编码指定匹配模式，可以同时指定多个模式，其模式定义如下：

~~~java
public static final int UNIX_LINES = 0x01;   // 1
public static final int CASE_INSENSITIVE = 0x02; //10
public static final int COMMENTS = 0x04; // 100
public static final int MULTILINE = 0x08; // 1000
public static final int LITERAL = 0x10; // 10000
public static final int DOTALL = 0x20; // 100000
public static final int UNICODE_CASE = 0x40; // 1000000
public static final int CANON_EQ = 0x80; // 10000000
public static final int UNICODE_CHARACTER_CLASS = 0x100; // 10000000
~~~

其说明如下:

| 编译标志                  | 嵌入式表达式 | 效果                                                         |
| ------------------------- | ------------ | ------------------------------------------------------------ |
| `UNIX_LINES `             | `(?d)`       | 在这个模式下，只有'/n'才被认作一行的中止，并且与'.'，'^'，以及'$'进行匹配。默认模式中\r\n都会被当做换行符 |
| `CASE_INSENSITIVE `       | `(?i)`       | 忽略大小写,默认情况下，大小写不敏感的匹配只适用于US-ASCII字符集。这个标志能让表达式忽略大小写进行匹配。要想对Unicode字符进行大小不敏感的匹配，只要将UNICODE_CASE与这个标志合起来就行了。 |
| `COMMENTS `               | `(?x)`       | 注释模式，匹配时会忽略(正则表达式里的)空格字符(注：不是指表达式里的"//s"，而是指表达式里的空格，tab，回车之类)。注释从#开始，一直到这行结束。可以通过嵌入式的标志来启用Unix行模式。 |
| `MULTILINE`               | `(?m)`       | 多行匹配模式，`^`和`$`分别匹配一行的开始和结束。此外，`^`仍然匹配字符串的开始，`$`也匹配字符串的结束。默认情况下，这两个表达式仅仅匹配字符串的开始和结束。 |
| `LITERAL`                 |              | 文字解析模式,所有的元字符会被当成普通字符                    |
| `DOTALL`                  | `(?s)`       | 全字符匹配模式，`.`可以匹配任意字符，包括表示一行的结束符。默认情况下，`.`不匹配行的结束符。 |
| `UNICODE_CASE `           | `(?u)`       | 在这个模式下，如果你还启用了CASE_INSENSITIVE标志，那么它会对Unicode字符进行大小写不敏感的匹配。默认情况下，大小写不敏感的匹配只适用于US-ASCII字符集 |
| `CANON_EQ`                |              | 当且仅当两个字符的"正规分解(canonical decomposition)"都完全相同的情况下，才认定匹配。比如用了这个标志之后，表达式"a/u030A"会匹配"?"。默认情况下，不考虑"规范相等性(canonical equivalence)"。 |
| `UNICODE_CHARACTER_CLASS` | `(?U)`       | 可以使用一些特定匹配规则                                     |

例如同时启用多行注释和忽略大小下可以使用:

~~~java
Pattern compile = Pattern.compile("^abc$", Pattern.CASE_INSENSITIVE | Pattern.MULTILINE);
~~~

也可以使用嵌入式表达式:

~~~java
Pattern compile = Pattern.compile("(?im)^abc$");
~~~

### 实例方法

`pattern()/toString()`方法返回Pattern实例对应的正则表达式字符串。

`matcher()`方法将该正则与指定字符串匹配，返回匹配器`Matcher`

`flags()`方法返回表示该正则的模式的整数

`split()/splitAsStream()`方法将指定字符串用此正则匹配项拆分成字符串数组/流

`asPredicate`创建可用于匹配字符串的谓词

## Matcher

`Matcher`匹配器：通过解释Pattern对字符序列执行匹配操作的引擎
