# 正则表达式语法

正则表达式是一种用于匹配和操作文本的工具。

正则表达式是由普通字符以及特殊字符组成的文字模式。正则表达式作为一个模式，将某个字符模式与所搜索的字符串进行匹配。

## 普通字符

普通字符包括没有显示指定为元字符的所有可打印和不可打印的字符。这包括所有大写和小写字符、所有数字、所有标点符号和一些其他符号。

| 字符     | 描述                                                         |
| :------- | :----------------------------------------------------------- |
| `[ABC]`  | 匹配` [...] `中的所有字符，例如` [al] `匹配字符串 "apple" 中所有的 a l 字母。 |
| `[^ABC]` | 匹配除了` [...] `中字符的所有字符，例如 `[^al]` 匹配字符串 "apple" 中除了 a l字母的所有字符。 |
| `[A-Z]`  | [A-Z] 表示一个区间，匹配所有大写字母，[a-z] 表示所有小写字母。 |
| `.`      | 匹配除换行符（\n、\r）之外的任何单个字符，相等于 `[^\n\r]`。 |
| `\w` | 匹配字母、数字、下划线。等价于`[A-Za-z0-9_]`。   |
| `\W` | 匹配非字母、数字、下划线。等价于 `[^A-Za-z0-9_]`。 |
| `\d` | 匹配一个数字字符。等价于` [0-9]`。  |
| `\D` | 匹配一个非数字字符。等价于 `[^0-9]`。 |

## 非打印字符

非打印字符也可以是正则表达式的组成部分。下表列出了表示非打印字符的转义序列：

| 字符  | 描述                                                         |
| :---- | :----------------------------------------------------------- |
| `\cx` | 匹配由x指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 'c' 字符。 |
| `\f`  | 匹配一个换页符。等价于 `\x0c` 和 `\cL`。                     |
| `\n`  | 匹配一个换行符。等价于` \x0a `和` \cJ`。                     |
| `\r`  | 匹配一个回车符。等价于` \x0d` 和` \cM`。                     |
| `\s`  | 匹配任何空白字符，包括空格、制表符、换页符等等。等价于` [ \f\n\r\t\v]`。注意 Unicode 正则表达式会匹配全角空格符。 |
| `\S`  | 匹配任何非空白字符。等价于 `[^ \f\n\r\t\v`]。                |
| `\t`  | 匹配一个制表符。等价于 `\x09` 和` \cI`。                     |
| `\v`  | 匹配一个垂直制表符。等价于 `\x0b` 和` \cK`。                 |

## 特殊字符

特殊字符即正则表达式语法的保留字，如果要匹配保留字，需要对其转义：

| 特别字符 | 描述                                                         |
| :------- | :----------------------------------------------------------- |
| `$`      | 匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 `$` 也匹配 '\n' 或 '\r'。要匹配 `$` 字符本身，请使用 `\$`。 |
| `()`     | 标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 `\( `和 `\)`。 |
| `*`      | 匹配前面的子表达式零次或多次。要匹配 `*` 字符，请使用` \*`。 |
| `+`      | 匹配前面的子表达式一次或多次。要匹配 `+` 字符，请使用 `\+`。 |
| `.`      | 匹配除换行符 \n 之外的任何单字符。要匹配 `.` ，请使用 `\. `。 |
| `[`      | 标记一个中括号表达式的开始。要匹配 `[`，请使用` \[`。        |
| `?`      | 匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配` ?` 字符，请使用 `\?`。 |
| `\`      | 将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， `n `匹配字符 `n`。`\n` 匹配换行符。序列 '`\\`' 匹配 `\`，而 `\(` 则匹配 `(`。 |
| `^`      | 匹配输入字符串的开始位置，除非在方括号表达式中使用，当该符号在方括号表达式中使用时，表示不接受该方括号表达式中的字符集合。要匹配 `^` 字符本身，请使用 `\^`。 |
| `{`      | 标记限定符表达式的开始。要匹配` {`，请使用` \{`。            |
| `|`      | 指明两项之间的一个选择。要匹配` |`，请使用` \|`。            |

## 限定符

限定符用来指定正则表达式的一个给定组件必须要出现多少次才能满足匹配。有 ***** 或 **+** 或 **?** 或 **{n}** 或 **{n,}** 或 **{n,m}** 共6种。

正则表达式的限定符有：

| 字符    | 描述                                                         |
| :------ | :----------------------------------------------------------- |
| `*`     | 匹配前面的子表达式零次或多次。例如，`zo* `能匹配 `z` 以及 `zoo`。`* `等价于 `{0,}`。 |
| `+`     | 匹配前面的子表达式一次或多次。例如，`zo+ `能匹配` zo `以及` zoo`，但不能匹配 `z`。`+ `等价于` {1,}` |
| `?`     | 匹配前面的子表达式零次或一次。例如，`do(es)? `可以匹配 `do` 、 `does`、 `doxy `中的 `do `和 `does`。`? `等价于 `{0,1}`。 |
| `{n}`   | n 是一个非负整数。匹配确定的 n 次。例如，o{2} 不能匹配 `Bob `中的 `o`，但是能匹配 `food`中的两个 `o`。 |
| `{n,}`  | n 是一个非负整数。至少匹配n 次。例如，`o{2,}` 不能匹配 `Bob`中的 o，但能匹配 `foooood` 中的所有 `o`。 |
| `{n,m}` | m 和 n 均为非负整数，其中 n <= m。最少匹配 n 次且最多匹配 m 次。例如，`o{1,3}` 将匹配 `fooooood `中的前三个` o` |

## 定位符

定位符能够将正则表达式固定到行首或行尾。或者定位到单词的边界

| 字符 | 描述                                                         |
| :--- | :----------------------------------------------------------- |
| `^`  | 匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与 \n 或 \r 之后的位置匹配。 |
| `$`  | 匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与 \n 或 \r 之前的位置匹配。 |
| `\b` | 匹配一个单词边界，即字与空格间的位置。                       |
| `\B` | 非单词边界匹配。                                             |

## 选择

用圆括号`()`  将所有选择项括起来，相邻的选择项之间用 `|` 分隔。

`()` 表示捕获分组，`()` 会把每个分组里的匹配的值保存起来， 多个匹配值可以通过数字 n 来查看(n 是一个数字，表示第 n 个捕获组的内容)。

## 修饰符

用修饰符指定正则表达式的匹配策略,标记不写在正则表达式里，标记位于表达式之外，格式如下：

~~~bash
/pattern/flags
~~~

下表列出了正则表达式常用的修饰符：

| 修饰符 | 含义                                   | 描述                                                         |
| :----- | :------------------------------------- | :----------------------------------------------------------- |
| i      | ignore - 不区分大小写                  | 将匹配设置为不区分大小写，搜索时不区分大小写: A 和 a 没有区别。 |
| g      | global - 全局匹配                      | 查找所有的匹配项。                                           |
| m      | multi line - 多行匹配                  | 使边界字符 `^` 和 `$` 匹配每一行的开头和结尾，记住是多行，而不是整个字符串的开头和结尾。 |
| s      | 特殊字符圆点 **.** 中包含换行符 **\n** | 默认情况下的圆点 **.** 是匹配除换行符` \n `之外的任何字符，加上 `s `修饰符之后, `.` 中包含换行符 `\n`。 |

如`/[a-z]*/i`能匹配`aFwEt`

# Java正则

`java.util.regex`对正则表达式进行了支持。通过`Pattern`和`Matcher`类对字符串运用正则表达式

## Pattern

`Pattern`表达式是对正则表达式的抽象，一个`Pattern`实例就代表一个正则表达式。

~~~java
public static Pattern compile(String regex);
public static Pattern compile(String regex, int flags);
public static boolean matches(String regex, CharSequence input);
public static String quote(String s);
public String pattern();
public String toString();
public Matcher matcher(CharSequence input);
public String[] split(CharSequence input, int limit);
public String[] split(CharSequence input);
public Stream<String> splitAsStream(final CharSequence input);
public Predicate<String> asPredicate();
~~~

### 静态方法

`Pattern`的构造器是私有的，可以通过它提供的静态方法`compile()`获取其实例：

~~~java
Pattern compile = Pattern.compile("^\\d*$");
~~~

注意：在java字符串中`\`本身就是转移字符`\n`会被解析为换行符。想要表达`\n`字符串，必须使用`\\n`。其中`\\`对`\`进行转义，表示`\`的字面含义。

`quote()`静态方法对字符串中，正则的特殊字符进行转义，让其确保它们被视为普通字符而不是正则表达式的构造元素：

~~~java
//匹配 字面含义的\n，可以使用:
Pattern.compile("\\\\n"); //其正则表达式为 \\n   匹配  \n
Pattern.compile(Pattern.quote("\\n")); //其正则表达式为 \Q\n\E  匹配 \n
~~~

`matches()`方法提供便捷的正则匹配，将给定的字符串和给定的正则表达式进行匹配：

~~~java
Pattern.matches("\\\\n","\\n"); //返回true
Pattern.matches(Pattern.quote("\\n"),"\\n"); //返回true
~~~

### 实例方法





## Matcher

`Matcher`匹配器：通过解释Pattern对字符序列执行匹配操作的引擎
