# 计算机网络概述

计算机网络是由一组通过通信信道相互连接的机器组成。这些机器是主机(hosts)和路由器(routers)

* **主机**是指运行应用程序的计算机，这些应用程序如网络浏览器，即时通讯代理等是计算机网络的真正用户

* **路由器**的作用是将信息从一个通信信道转递或转发到另一个通信信道
* **通信信道**是将字节序列从一个主机传输到另一个主机的手段，如有线电缆、WIFI等

计算机网络中主机和主机之间一般不是直接相连的，通常主机先连接到路由器，路由器再连接到其他路由器。这样使每个主机只需要用到数量相对较少的通信信道，大部分主机仅需要一条通道。而网络上相互转递信息的程序并不直接于路由器交互。

网络间程序互相传递的信息是由程序创建和解释的字节序列，在计算机网络中，这些字节序列被称为**分组报文**

**协议**(protocol):是相互通信的程序间达成的约定，它规定了分组报文的交换方式和它们包含的信息。一个协议规定了分组报文的结构以及怎样对报文中所包含的信息进行解析。

## TCP/IP协议族

人们设计了不同的协议用来解决不同类型的问题。TCP/IP协议就是这样一组的解决方案，也被称为协议族

TCP/IP协议族将网络分为链路层、网络层、传输层、应用层

其主要协议有：

* IP协议：互联网协议(Internet Protocol)
* TCP协议：传输控制协议(Transmission Control Protocol)
* UDP协议：用户数据报协议(User Datagram Protocol)

IP协议位于网络层，它使两个主机间的一系列通信信道和路由器看起来像是一条单一的主机到主机的信道。它为每个主机标记了一个地址，这就是IP地址。

TCP和UDP协议都位于传输层，建立在IP协议所提供的服务基础之上。但IP地址只能帮助定位到主机，无法区分寻址到具体的应用程序。

TCP和UDP在IP地址的基础上使用端口号来区分同一主机中的不同应用程序。它们也被称为端到端传输协议，因为它们将数据从一个应用程序传输到另一个应用程序。

TCP协议提供一个可信赖的字节流通道，通过三次握手建立起稳定的TCP连接

UDP协议并不可靠，可能发生报文丢失、重复以及其他错误。

## 地址

在TCP/IP协议中，IP地址和端口号可以定位网络中一个指定的程序。其中IP地址由IP协议使用，端口号由传输协议解析。

IP地址分为IPv4和IPv6两种形式。

IPv4地址占4个字节：被表示为一组4个十进制数，每两个数字之间由原点隔开，每个数字的范围是0到255，如10.1.2.3

IPv6地址占16个字节：由几组16进制的数组表示，这些16进制数之间由分号隔开，如：2000:fdb8:0000:0000:0001:00ab:853c:39a1

每个IP地址代表了一个主机与底层的链路层的连接，也就是一个网络接口。主机可以有多个接口。

TCP或UDP协议种的端口号总与一个IP地址相关联。端口号范围：1-65535，其中1-1024被系统应用占用

IP地址有一个特殊的回环地址。回环接口是一种虚拟设备，它的功能是将发送给它的报文直接回发给发送者。在测试种很有用，因为发送给这个地址的报文能够立即返回到目标地址。每台主机上都有回环地址。IPv4的回环地址是127.0.0.1。IPv6的回环地址是0:0:0:0:0:0:0:1

## Socket套接字

Socket事一种抽象层，应用程序通过它来发送和接收数据。一个Socket允许应用程序添加到网络种，并于处于同一网络种的其他应用程序进行通信。



# InetAddress

是对IP地址的抽象封装。包括IP地址和端口号。它有两个实现类`Inet4Address`和`Inet6Address`，分别对应了目前IP地址的两个版本。

## 获取InetAddress实例

可以通过`NetworkInterface.getNetworkInterfaces()`获取当前主机的网络接口实例，可以通过`NetworkInterface.getInetAdresses()`获取网络接口下的地址信息。

可以获取本机的地址信息：

~~~java
Enumeration<NetworkInterface> interfaces = NetworkInterface.getNetworkInterfaces();
while (interfaces.hasMoreElements()){
    NetworkInterface inter = interfaces.nextElement();
    System.out.println("接口名:"+inter.getName());
    Enumeration<InetAddress> addresses = inter.getInetAddresses();
    while (addresses.hasMoreElements()){
        InetAddress inetAddress = addresses.nextElement();
        System.out.println("地址信息："+inetAddress);
    }
}
~~~

可以通过`InetAddress  `提供的静态工厂方法获取IP地址实例：

~~~java
public static InetAddress getByAddress(String host, byte[] addr);
//根据提供的主机名和 IP 地址创建 InetAddress。不检查名称服务地址的有效性
public static InetAddress getByAddress(byte[] addr);
//返回给定 InetAddress 原始 IP 地址的对象。
public static InetAddress getByName(String host);
//根据主机的名称确定主机的IP 地址。可以是域名也可以是其 IP 地址的文本表示形式。如果提供了文本 IP 地址，则仅检查地址格式的有效性。
public static InetAddress[] getAllByName(String host);
//给定主机的名称，根据系统上配置的名称服务返回其 IP 地址的数组。可以是域名也可以是其 IP 地址的文本表示形式。如果提供了文本 IP 地址，则仅检查地址格式的有效性。
public static InetAddress getLocalHost();
//返回本地主机的地址。这是通过从系统中检索主机的名称，然后将该名称解析为 InetAddress 来实现的。
public static InetAddress getLoopbackAddress();
//返回环回地址
~~~

例：

~~~java
InetAddress[] inetAddresses = InetAddress.getAllByName("www.baidu.com");
for (InetAddress address : inetAddresses)
    System.out.println(address);
//输出：www.baidu.com/112.80.248.75 和 www.baidu.com/112.80.248.76
~~~







## 构造方法

此类没有给我们提供用于创建对象的构造方法，InetAddress   类中有提供静态的获取本类对象的方法



## 非静态方法

* String getHostAddress() 
              返回 IP 地址字符串（以文本表现形式）。 
*  String getHostName() 
              获取此 IP 地址的主机名。 

* byte[] getAddress() 
              返回此 InetAddress 对象的原始 IP 地址。 

## 静态方法

* static InetAddress[] getAllByName(String host) 
              在给定主机名的情况下，根据系统上配置的名称服务返回其 IP 地址所组成的数组。  

* static InetAddress getByName(String host) 
              在给定主机名的情况下确定主机的 IP 地址。 

* static InetAddress getLocalHost() 
              返回本地主机。 

# DatagramSocket

## 描述

此类表示用来发送和接收数据报包的套接字。（端点）

数据报套接字是包投递服务的发送或接收点。

每个在数据报套接字上发送或接收的包都是单独编址和路由的。

从一台机器发送到另一台机器的多个包可能选择不同的路由，也可能按不同的顺序到达。 

## 构造方法

* DatagramSocket() 
              构造数据报套接字并将其绑定到本地主机上任何可用的端口。

* DatagramSocket(int port) 
              创建数据报套接字并将其绑定到本地主机上的指定端口。

* DatagramSocket(int port, InetAddress laddr) 
              创建数据报套接字，将其绑定到指定的本地地址。

## 方法

* void close() 
              关闭此数据报套接字。 

* int getPort() 
              返回此套接字的端口。 

* void receive(DatagramPacket p) 
              从此套接字接收数据报包。 
*  void send(DatagramPacket p) 
              从此套接字发送数据报包。 



# DatagramPacket

## 描述

此类表示数据报包。

数据报包用于实现无连接分组传送服务。 仅基于该数据包中包含的信息，每个消息从一台机器路由到另一台机器。从一台机器发送到另一台机器的多个分组可能会有不同的路由，并且可能以任何顺序到达。包传送不能保证。



## 构造方法

* DatagramPacket(byte[] buf, int length) 
              构造 DatagramPacket，用来接收长度为 length 的数据包。 
* DatagramPacket(byte[] buf, int length, InetAddress address, int port) 
              构造数据报包，用来将长度为 length 的包发送到指定主机上的指定端口号 



## 方法

* InetAddress getAddress() 

    返回该数据报发送或接收数据报的计算机的IP地址。  

* int getPort() 

    返回发送数据报的远程主机上的端口号，或从中接收数据报的端口号。  

* byte[] getData() 

    返回数据缓冲区。  

* int getLength() 

    返回要发送的数据的长度或接收到的数据的长度。





# Socket

## 描述

客户端套接字

## 构造方法

* Socket(String host, int port) 
              创建一个流套接字并将其连接到指定主机上的指定端口号。

* Socket(InetAddress address, int port) 
              创建一个流套接字并将其连接到指定 IP 地址的指定端口号

## 方法

* OutputStream getOutputStream() 
              返回此套接字的输出流。 该流的read方法是阻塞的

* InetAddress getInetAddress() 
              返回套接字连接的地址。 

* void close() 
              关闭此套接字。 

* InetAddress getInetAddress() 
              返回套接字连接的地址。
* int getPort() 
              返回此套接字连接到的远程端口。  

* void shutdownInput() 
              此套接字的输入流置于“流的末尾”。 
* void shutdownOutput() 
              禁用此套接字的输出流。 



# SeverSocket

## 描述

服务端套接字

## 构造方法

* ServerSocket(int port) 
              创建绑定到特定端口的服务器套接字。



## 非静态方法

* Socket accept() 
              侦听并接受到此套接字的连接。 该方法阻塞

* InetAddress getInetAddress() 
              返回此服务器套接字的本地地址。 



# 生成随机文件名

## UUID类

~~~java
String fileName = UUID.randomUUID().toString().replace("-", "");
~~~

## 随机数

~~~java
String filename = System.currentTimeMillis()+new Random().nextInt()+"";
~~~

## IP地址

~~~java
InetAddress address = InetAddress.getByName("127.0.0.1");
        File file = new File("父路径", address.getHostAddress());
        int num = 1;
        while (file.exists()) {
            file = new File("父路径", address.getHostAddress() + num);
        }
~~~

# TCP代码实现

## CS模式

### 请求相应信息

* 客户端

~~~java
//创建客户端对象
Socket client = new Socket("127.0.0.1", 8080);
System.out.println("客户端连接成功");
//创建输出输入流
OutputStream out = client.getOutputStream();
BufferedWriter outWriter = new BufferedWriter(new OutputStreamWriter(out));
InputStream in = client.getInputStream();
BufferedReader inReader = new BufferedReader(new InputStreamReader(in));
Scanner input = new Scanner(System.in);
try {
    while (true) {
        //发送请求，接受响应
        System.out.print("请输入请求信息：");
        String request = input.nextLine();
        outWriter.write(request);
        //需要手动结束服务端readLine方法，否则readLine不会结束，会一直阻塞
        outWriter.write("\r\n");
        //需要刷新缓冲区
        outWriter.flush();
        System.out.println("请求成功");
        String response = inReader.readLine();
        System.out.print("收到响应信息：");
        System.out.println(response);
    }
} finally {
    //关闭流
    input.close();
    inReader.close();
    in.close();
    outWriter.close();
    out.close();
    client.close();
}
~~~

* 服务端

~~~java
//创建服务端对象
ServerSocket server = new ServerSocket(8080);
//倾听客户端请求并创建客户端对象
Socket client = server.accept();
//创建流对象
Scanner input = new Scanner(System.in);
InputStream in = client.getInputStream();
OutputStream out = client.getOutputStream();
BufferedReader inReader = new BufferedReader(new InputStreamReader(in));
BufferedWriter outWriter = new BufferedWriter(new OutputStreamWriter(out));
//接受请求，发送响应
try {
    while (true) {
        String request = inReader.readLine();
        System.out.println("收到请求："+request);
        System.out.print("请输入响应：");
        String response = input.nextLine();
        outWriter.write(response);
        outWriter.write("\r\n");
        outWriter.flush();
        System.out.println("响应成功");
    }
} finally {
    //关闭流
    outWriter.close();
    inReader.close();
    out.close();
    in.close();
    input.close();
    client.close();
}
~~~

### 上传下载数据

#### 同时获取文件名

* 客户端

~~~java
//创建客户端对象
Socket client = new Socket("127.0.0.1", 8888);
System.out.println("客户端连接成功");
//创建文件对象与获得文件名
File file = new File("d:\\Data\\Temporary\\test.wav");
String filename = file.getName();
//创建流对象
FileInputStream fis = new FileInputStream(file);
OutputStream out = client.getOutputStream();
BufferedWriter outWriter = new BufferedWriter(new OutputStreamWriter(out));
//用字符缓冲区必须手动结束read(),并且刷新缓冲区
outWriter.write(filename);
outWriter.write("\r\n");
outWriter.flush();
//上传文件
byte[] bytes = new byte[1024];
int len =0;
while((len = fis.read(bytes))!=-1){
    out.write(bytes,0,len);
}
System.out.println("文件上传成功");
//关闭流
outWriter.close();
out.close();
fis.close();
client.close();
~~~

* 服务端

~~~java
ServerSocket server = new ServerSocket(8888);
while (true) {
    Socket client = server.accept();
    System.out.println("连接客户端成功");
    new Thread(new Runnable() {
        @Override
        public void run() {
            //创建流对象
            InputStream in = null;
            BufferedReader inReader = null;
            FileOutputStream fos = null;
            try {
                in = client.getInputStream();
                inReader = new BufferedReader(new InputStreamReader(in));
                //获取并设置文件名
                String filename = inReader.readLine();
                File file = setFileName(filename);
                //下载文件
                byte [] bytes = new byte[1024];
                int len = 0;
                fos = new FileOutputStream(file);
                while((len = in.read(bytes)) != -1){
                    fos.write(bytes,0,len);
                }
                System.out.println("文件下载成功");
                //关闭流
                fos.close();
                inReader.close();
                in.close();
                client.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }).start();
}
~~~

其中设置文件名方法为：

~~~java
public static File setFileName(String filename){
    String[] filenameList = filename.split("\\.");
    String fileStartName = String.join(".", Arrays.copyOf(filenameList,filenameList.length-1));
    String fileSuffix = "."+filenameList[filenameList.length-1];
    System.out.println(fileStartName);
    System.out.println(fileSuffix);
    File file = new File("d:\\",fileStartName+fileSuffix);
    int num = 1;
    while (file.exists()){
        file = new File("d:\\",fileStartName +"("+num+")"+fileSuffix);
        num++;
    }
    System.out.println("设置文件名成功");
    return file;

}
~~~

# URL

## 描述

类 `URL`  代表一个统一资源定位符，它是指向互联网“资源”的指针。资源可以是简单的文件或目录，也可以是对更为复杂的对象的引用，例如对数据库或搜索引擎的查询。

## 构造方法

URL(String spec) 
          根据 String 表示形式创建 URL 对象。

## 方法

* URLConnection openConnection() 
              返回一个 URLConnection 对象，它表示到 URL 所引用的远程对象的连接。 

# URLConnection

## 描述

它代表应用程序和 URL 之间的通信链接

## 方法

* OutputStream getOutputStream() 
              返回写入到此连接的输出流 

* InputStream getInputStream() 
              返回从此打开的连接读取的输入流。 
