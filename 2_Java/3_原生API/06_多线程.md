# 相关概念

* 并行：同一个时刻点，有多个任务同时执行。

* 并发：同一个时间段，有多个任务同时执行。

* 进程：计算机中正在运行的应用程序，每个进程有自己独立的内存空间

    是系统进行资源分配和调度的基本单位，是操作系统结构的基础

* 线程：是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位

* 多线程：多个线程并发执行的技术

* 主线程：负责应用程序运行入口的线程。java程序的运行入口是main方法。

* 在java 中每个一个.class文件的运行，都需要独立得分配一个JVM。在一个.class程序中可以运行多个线程。

* 线程的调度策略(算法)：
    * 分时调度：平均分配任务时间
    * 时间片抢占式调度：多个线程抢夺执行权

* 在java中每一个线程会分配一个独立的栈内存，但堆内存是线程共享的

* 同步：一个进程在执行某个任务时，必须等该任务完成，才会继续执行下去

* 异步：进程在执行任务时，不必等任务执行完成，可以直接立刻继续执行其他操作



概念对比：

* 并行与并发：区别在于时间，一个是时间点，一个是时间段，并行是真正的有多个任务在同时执行，而并发不一定，并发可能是多个任务某个时间点只有一个在执行，在一个时间段来看，像是多个任务在同时执行
* 线程与进程：
    * 进程包含线程，一个进程可以有多个线程，线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。
    *  同一进程的线程共享本进程的地址空间和资源，而进程之间的地址空间和资源是相互独立的
* 异步与多线程：多线程是实现异步的一种技术。异步是一种技术功能要求，多线程是实现异步的一种手段。



# 线程

线程是多线程编程中的核心概念

## 生命周期

![线程生命周期](https://gitee.com/wangziming707/note-pic/raw/master/img/%E7%BA%BF%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png)

* 新建状态：当程序使用new关键字创建了一个线程之后，该线程就处于 新建状态(初始化阶段)
* 就绪状态：线程对象调用了start()方法之后，该线程处于 就绪状态

* 运行状态：当CPU开始调度处于 就绪状态 的线程时，此时线程获得了CPU时间片才得以真正开始执行run()方法的线程执行体，则该线程处于 运行状态。

* 阻塞状态：阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。阻塞的情况大概三种：
    * 等待阻塞：运行的线程执行wait()方法，JVM会把该线程放入等待池中。(wait会释放持有的锁)
    * 同步阻塞：运行的线程在获取对象的同步锁(synchronized)时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池中。
    * 其他阻塞：运行的线程执行sleep()或join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。（注意,sleep是不会释放持有的锁）。
* 死亡状态：线程会以下三种方式之一结束，结束后就处于死亡状态：
    *  run()或call()方法执行完成，线程正常结束。
    * 线程抛出一个未捕获的Exception或Error。
    * 直接调用该线程的stop()方法来结束该线程，该方法容易导致死锁，通常不推荐使用。



## 线程通信

让某个线程在某些条件下改变状态，比如从运行变为阻塞，从阻塞变为就绪等

* 等待唤醒机制：Object提供了 wait() 和 notify() 方法

    wait()/notify() 方法只能在同步方法或同部块中调用

    执行 wait() 方法后，当前线程立即释放锁

    notify() 方法可以随机唤醒等待队列中等待同一共享资源的一个（随机的，仅仅一个）线程，并使该线程退出等待队列，进入可运行状态。

    notifyAll() 方法可以使所有正在等待队列中等待同一资源的全部线程从等待状态进入可运行状态。

* Thread类提供方法：

    * join() 可以理解成线程合并，当在一个线程调用另一个线程的 join() 方法时，当前线程阻塞等待被调用 join() 方法的线程执行完毕才能继续执行，所以 join() 的好处能够保证线程的执行顺序，具有使线程排队的作用

* volatile 关键字，被这个关键字修饰的变量：

    * 保证此变量对所有的线程的可见性(，当一个线程修改了这个变量的值，volatile 保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新)
    * 禁止指令重排序（CPU采用了允许将多条指令不按程序规定的顺序分开发送给各相应电路单元处理）

    通过volatile关键字的特性，我们可以实现比sychronized关键字更轻量级的同步机制

## 创建方式

* 直接继承Thread类

    * 将一个类声明为Thread的子类

    * 重写Thread中的run()方法-->需要多线程执行的代码都写在run() 方法中

    * 创建子类对象

    * 启动线程（调用对象的start()方法）
* 实现Runnable接口
    * 将一个类实现Runnable接口
    * 重写run()方法
    * 创建实现类对象
    * 创建Thread对象将类对象传入
    * 启动线程
* 实现Callable接口
    * 实现Callable接口
    * 通过Callable接口创建 FutureTask对象，该对象实现了Runnable接口
    * 通过 FutureTask对象创建 Thread线程对象
    * start启动线程

* 使用线程池

# Thread类

## 描述

实现多线程的类

1. 线程都有优先级，范围是1-10，默认为5，优先级越高，被执行的几率越高
2. 线程分为：
    * 用户线程[默认]:表示普通线程，线程任务结束后自动释放
    * 守护线程[设置]：用于服务用户线程，当程序中没有执行的用户线程时，守护线程会自动结束。 Java中的垃圾回收机制，和日志的记录都是典型的守护线程
3. 线程有线程名，默认Thread-x, x从0开始，逐一增加

## 构造方法

* `Thread(String name) `
              分配新的 Thread 对象，并指定线程名称
* `Thread(Runnable target) `
    分配新的 Thread 对象。

## 非静态方法

### 核心方法

* `void run() `

    线程任务方法，指定多线程想需要调用的方法          如果该线程是使用独立的 Runnable 运行对象构造的，则调用该 Runnable 对象的 run 方法；否则，该方法不执行任何操作并返回。 

### 获取线程信息

*  `long getId() `
              返回该线程的标识符。 
* `String getName() `
              返回该线程的名称。 
* `int getPriority() `
              返回线程的优先级。 
* `Thread.State getState() `
              返回该线程的状态。 

### 设置线程

* `void setName(String name) `
    改变线程名称，使之与参数 name 相同。 
* `void setPriority(int newPriority) `
    更改线程的优先级。 

*  `void setDaemon(boolean on) `
    将该线程标记为守护线程或用户线程。 



### 判断线程状态

* `boolean isAlive() `
    测试线程是否处于活动状态。 
* `boolean isDaemon() `
    测试该线程是否为守护线程。 
* `boolean isInterrupted() `
    测试线程是否已经中断。 

### 操作线程

* `void checkAccess() `
    判定当前运行的线程是否有权修改该线程。

* `void start() `
    使该线程开始执行；Java 虚拟机调用该线程的 run 方法。 线程只能启动一次（一个对象只能调用一次start()) 

* `void interrupt() `
    中断线程。 

* `void join() `
    等待该线程终止。

    在该线程终止前，执行权都在该线程手中，直到该线程终止 其他的线程才能参与线程执行

* `void join(long millis) `
    等待该线程终止的时间最长为 millis 毫秒。 

    在该线程终止前，或者指定的时间内，执行权都在该线程手中，直到线程结束或者指定时间结束其他的线程才能参与线程执行

* `void join(long millis, int nanos) `
    等待该线程终止的时间最长为 millis 毫秒 + nanos 纳秒。 同上



## 静态方法

* `static int activeCount() `
              返回当前线程的线程组中活动线程的数目。 

* `static Thread currentThread() `
    返回对当前正在执行的线程对象的引用。 

* `static void sleep(long millis) `
    在指定的毫秒数内让当前正在执行的线程休眠（暂停执行），此操作受到系统计时器和调度程序精度和准确性的影响。 
* `static void sleep(long millis, int nanos) `
    在指定的毫秒数加指定的纳秒数内让当前正在执行的线程休眠（暂停执行），此操作受到系统计时器和调度程序精度和准确性的影响。 

* `static void yield() `

    暂停当前正在执行的线程对象，并执行其他线程。 

    让出当先线程的执行权，但会继续参与线程执行权的抢夺

    也就是说让线程进入就绪状态，而不是阻塞

* `static boolean interrupted() `
              测试当前线程是否已经中断。 

# 线程同步

* 多线程经常会用于操作共享的资源，而线程之间对资源的抢夺会造成数据的安全问题。

    有多条线程操作更新共享数据，且操作共享数据的语句不止一条。

* 原因：当某个线程的任务还没有执行结束，其他线程就进入线程任务代码造成的

* 解决方案，上锁：
    * synchronized同步代码块
    * synchronized同步方法
    * Lock锁(用ReentrantLock类结合Condition实例可以实现选择性通知)

## Synchronized关键字

* 同步代码块

~~~java
synchronized (锁对象){
    //........
}
~~~

* 同步方法

当方法中的所有代码都是操作共享数据时再使用（为了效率）

~~~java
public [static] synchronized methodName(){
    //操作共享数据的代码；
}
~~~

同步方法有一个默认的锁对象，不需要手动指定；

## Lock接口

### 描述

Lock能替代synchronized方法与synchronized代码块，实现代码同步

同时能实现代码同步和等待唤醒解耦

### 方法

* `void lock() `
    获取锁。 

* `void unlock() `
    释放锁。 
* `Condition newCondition() `
    返回绑定到此 Lock 实例的新 Condition 实例。 

### 实现类

ReentrantLock

ReentrantReadWriteLock.ReadLock

ReentrantReadWriteLock.WriteLock

## Condition 接口

### 描述

Condition替代了对象监视器（即锁对象）方法（等待、唤醒）

并提供了精准唤醒服务

### 方法

* `void await() `
        造成当前线程在接到信号或被中断之前一直处于等待状态。 

* `void signal() `
        唤醒一个等待线程。 

* `void signalAll() `
        唤醒所有等待线程。 

## 死锁

线程的任务没有执行结束，但是线程对象基于某些原因无法继续执行任务，而导致线程阻塞

进入死锁的情况：

* 两个线程需要两把锁才能执行任务时，每个线程只抢到了一把锁
* 在线程等待唤醒中，因为唤醒时随机的，可能会出现所有线程都等待在线程常量池中的情况

# 多线程下的单例模式

## 饿汉式

多线程下仍然保持单例

~~~java
public class Single{
    private Single(){}
    oruvate static final Single s = new Single();
    public static Single getInstance(){
        return s;
    }
}
~~~

## 懒汉式

多线程模式下不能保证唯一，

~~~JAVA
public class Single {
    private Single(){}
    private static Single s;
    public static Single getInstance(){
        if (s ==null){
            s = new Singel();
        }
        return s;
    }
}
~~~

需要加锁:

~~~java
public class Single {
    private Single(){}
    private static Single s;
    public static Single getInstance(){
        if(s ==null){
            synchronized(lock){
                if (s ==null){
            		s = new Singel();
        		}
            }
        }
        return s;
    }
}
~~~



# 生产消费模拟

资源类：

~~~java
public class Resource {
    
    private String[] goods = new String[1];
    private int counter = 0;
    
    Lock lock = new ReentrantLock();
    Condition get_con = lock.newCondition();
    Condition set_con = lock.newCondition();

    public void get() throws InterruptedException {
        while (true) {
            try {
                lock.lock();
                if(goods[0]==null){
                    get_con.await();
                }
                System.out.println(Thread.currentThread().getName() 
                                   + "获得商品" + goods[0]);
                goods[0] = null;
                Thread.sleep(1);
                set_con.signal();
            }finally {
                lock.unlock();
            }
        }
    }

    public void set() throws InterruptedException {
        while (true) {
            try {
                lock.lock();
                if(goods[0] !=null){
                    set_con.await();
                }
                counter++;
                System.out.println(Thread.currentThread().getName() 
                                   + "补充商品:" + "饮料" + counter);
                goods[0] = "饮料" + counter;
                Thread.sleep(1);
                get_con.signal();
            }finally {
                lock.unlock();
            }
        }
    }
}
~~~

消费者类

```java
public class Consumer implements Runnable{
    private Resource resource;
    public Consumer() {
    }
    public Consumer(Resource resource) {
        this.resource = resource;
    }
    @Override
    public void run() {
        try {
            resource.get();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```

生成者类

```java
public class Producer implements  Runnable {
    private Resource resource;
    public Producer() { }
    public Producer(Resource resource) {
        this.resource = resource;
    }

    @Override
    public void run() {
        try {
            resource.set();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```

测试单元

```java
public static void test() {
    Resource resource = new Resource();

    Producer producer1 = new Producer(resource);
    Producer producer2 = new Producer(resource);
    Consumer consumer1 = new Consumer(resource);
    Consumer consumer2 = new Consumer(resource);
    
    Thread t_producer1 = new Thread(producer1, "producer1");
    Thread t_producer2 = new Thread(producer2, "producer2");
    Thread t_consumer1 = new Thread(consumer1, "consumer1");
    Thread t_consumer2 = new Thread(consumer2, "consumer2");
    
    t_consumer1.start();
    t_consumer2.start();
    t_producer1.start();
    t_producer2.start();
}
```

# 线程池

## 描述

* 一个用于保存线程对象的容器

* 线程池中的线程对象可以复用，当有需要执行的线程任务是，只需要从线程池中调用处于闲置状态下的线程对象执行任务，当任务执行结束后，将线程再加载进线程池

* 线程池底层是队列数据结构

## 优点

* 降低资源消耗，不需要频繁地创建和销毁线程
* 提高响应速度（节省了创建线程对象的时间）

* 方便对线程对象的统一管理

## 问题

* 对SingleThread和FixedThread来说，他们有阻塞队列无界，队列很大，很有可能导致JVM出现OOM（Out Of Memory）异常，即内存资源耗尽

* 对ScheduledThread和CachedThread来说， 线程数量无上界，会导致创建大量的线程，从而导致OOM

## 线程池继承关系

* Executor接口
    * ExecutorService

* Executors类：线程池工厂类

## Executor接口

### 描述

是线程池的顶层父接口

因为提供的功能少，所以我们一般不使用

## ExecutorService

### 描述

使用线程池的主要类

### 方法

* Future<?> submit(Runnable task) 
              提交一个 Runnable 任务用于执行，并返回一个表示该任务的 Future。 

## Executors

### 描述

生成线程池executor的工厂类

### 方法

* `static ExecutorService newSingleThreadExecutor()  `

    创建单线程化线程池

    特点：

    - 单线程化的线程池中的任务是按照提交的次序顺序执行的
    - 只有一个线程的线程池
    - 池中的唯一线程的存活时间是无限的
    - 当池中的唯一线程正繁忙时，新提交的任务实例会进入内部的阻塞队列中，并且其阻塞队列是无界的

    适用场景：

    * 任务按照提交次序，一个任务一个任务地逐个执行的场景

* `static ExecutorService newFixedThreadPool(int nThreads) `
        创建一个可重用固定线程数的线程池

    特点：

    * 如果线程数没有达到“固定数量”，每次提交一个任务线程池内就创建一个新线程，直到线程达到线程池固定的数量
    * 线程池的大小一旦达到“固定数量”就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程
    * 在接收异步任务的执行目标实例时，如果池中的所有线程均在繁忙状态，新任务会进入阻塞队列中（无界的阻塞队列）

    适用场景：

    - 需要任务长期执行的场景
    - CPU密集型任务

* `static ExecutorService newCachedThreadPool() `

    可缓存线程池

    特点：

    * 在接收新的异步任务target执行目标实例时，如果池内所有线程繁忙，此线程池就会添加新线程来处理任务
    * 线程池不会对线程池大小进行限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小
    * 如果部分线程空闲，也就是存量线程的数量超过了处理任务数量，就会回收空闲（60秒不执行任务）线程

    适用场景：

    * 需要快速处理突发性强、耗时较短的任务场景

* `static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) `
          
          可调度线程池
          
          - 延时性
          - 周期性
