# 关键字和标识符

关键字：被Java语言赋予特殊含义，用作专门用途的的字符串

* 特点：所有全部都是小写

标识符：表示起一定标识作用的符号。标识作用的符号是指程序中定义的名称。

* 命名规则：
    * 取值范围：`a-z` `A-Z` `0-9` `_` 和`$`
    * 数字不能开头
    * 不能直接使用关键字或者保留字，但是可以包含关键字和保留字
    * 严格区分大小写，长度无限制
    * 标识符不可以包含空格
* 规范：
    * 包名：多单词组成时所有字母都小写
    * 类名，接口名：多单词组成时，所有单词的首字母大写
    * 变量名、方法名：多单词组成时，第一个单词首字母小写，第二个单词开始每个单词首字母大写
    * 常量名：所有字母都大写。多单词时每个单词用下划线连接
    * 尽管`$`是一个合法的Java字符，但不能在代码中使用这个字符。它只用于在Java编译器或者其他工具生成的名字中。

# 基本数据类型

Java是一种强类型语言。必须为每一个变量声明一种类型。

Java中数据类型分为基本数据类型与引用数据类型，现在只介绍基本数据类型，引用数据类型会在面向对象中详细介绍

Java一共有八种数据类型，其中有4种整型、2种浮点类型、1种字符类型和1种boolean类型

## 整型

| 关键字 | 又称   | 占用内存      | 取值范围         |
| ------ | ------ | ------------- | ---------------- |
| byte   |        | l byte (8bit) | [-2^7^,2^7^-1]   |
| short  | 短整型 | 2byte (16bit) | [-2^15^,2^15^-1] |
| int    | 整型   | 4byte (32bit) | [-2^31^,2^31^-1] |
| long   | 长整型 | 8byte (64bit) | [-2^63^,2^63^-1] |

字面量:

* 整型字面量直接用数字表示，默认类型为int
* long类型的字面量有一个后缀`L`或者`l`，如`1000000L`
* 十六进制数值字面量有一个前缀 Ox 或 0X如 :`OxCAFE`
* 八进制数值字面量有一个前缀 0 , 如` 010`
* 二进制数值字面量有一个前缀`0b`或者`0B`,如`0B101`

## 浮点型

浮点类型用于表示有小数部分的数值。

| 类型         | 关键字 | 占用内存 |
| ------------ | ------ | -------- |
| 单精度浮点数 | float  | 4byte    |
| 双精度浮点数 | double | 8byte    |

* 用带小数部分的数值表示浮点型字面量，默认类型为double
* 单精度浮点类型的数值字面量有一个后缀`f`或`F`，如：`3.14f`

## 字符类型

关键字：`char`

字面量为被单引号标注的单个字符

码点 （ code point ) 是指与一个编码表中的某个字符对应的代码值。 在 Unicode 标准中，码点采用十六进制书写，并加上前缀 U+, 例如 U+0041 就是拉丁字母 A 的码点

UTF-16 编码采用不同长度的编码表示所有 Unicode 码点。在基本的多语言级别中，每个字符用 16 位表示，通常被称为代码单元（code unit)

在 Java 中，char 类型描述了 UTF-16 编码中的一个代码单元。

在程序中最好不要直接使用`char`类型

## 布尔类型

关键字：`boolean`

取值：`true `、`false`

# 变量

Java是强类型语言，在Java中每个变量都有一个类型(type)，可以是基本数据类型或者引用数据类型。

## 声明变量

在声明变量时，变量的类型位于变量名之前，格式为`变量类型 变量名`，例如：

~~~java
int number;
boolean done;
String str;
~~~

变量的声明是一条完整的Java语句，所以必须以分号结束。

变量名是Java标识符的一种，必须符合标识符的规则规范

可以在一行中声明多个变量:

~~~java
int i,j;
~~~

不过，不提倡使用这种风格。逐一声明每一个变量可以提高程序的可读性。

在Java中可以将声明放在代码中的放在代码中的任何地方。

但编程时变量的声明最好尽可能靠近变量第一次使用的地方，这是一种良好的程序编写风格。

## 变量初始化

声明了一个变量之后，必须用赋值语句对变量进行显式初始化。

使用未初始化的变量是错误的:

~~~java
String  str;
System.out.println( str );//编译报错
~~~

可以用等号对未初始化的变量进行赋值:

~~~java
int i ;
i = 10;
~~~

也可以将变量的声明和初始化放在同一行:

~~~java
int i = 10;
~~~

## 常量

关键字`final`指示常量,例如:

~~~java
final double PAI = 3.14;
~~~

常量只能被赋值一次，一旦被赋值之后，就不能再更改了

# 运算符

## 算数运算符

Java中用`+ - * / %`表示加、减、乘、除、取模运算，用于数值运算

这与数学中的运算符的含义一致

## 数值自动类型转换

经常需要将一种数值类型转换为另一种数值类型，Java中合法的数值类型之间的转换如下:

![合法数值类型转换](https://gitee.com/wangziming707/note-pic/raw/master/img/%E5%90%88%E6%B3%95%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2.png)

其中实箭头表示无信息丢失的转换，虚箭头表示可能有精度损失的转换。

上述转换是隐式的，自动的，在进行数值二元运算和赋值时这些转换会自动发生

### 赋值中的自动类型转换

在赋值中允许将上图中箭头尾的类型变量或者字面量赋值给箭头指向的类型变量，如:

~~~java
int a = 'c';
double b = 10;
byte c = 21;
short d = c;
......
~~~

### 二元运算中的自动类型转换

在使用两个不同类型的数值进行二元操作时，首先会将两个操作数转换为同一种类型，然后再进行计算:

* 如果操作数中有一个是double，另一个操作数就会转换为double类型
* 否则，如果其中一个操作数是float类型，另一个操作数将会转换为float类型
* 否则，如果其中一个操作数为long类型，另一个操作数将会转换为long类型
* 否则，两个操作数都将被转化为int类型

## 数值强制类型转换

上述的类型转换是Java允许的自动的、隐式的类型转换。但是有时候，我们需要自动数值类型转换允许之外的类型转换，比如将double类型转换成int类型。

这就需要使用显示声明的强制类型转换来完成,在变量或者字面量加上格式为`(type)`，表示将当前变量类型强制转换为括号中的类型，如:

~~~java
double a = 3.14;
int b = (int) a;
~~~

一般强制类型转换会丢失一些信息，如浮点类型转换为整型时，会自动去掉小数点后的信息。

**注意：**如果将一个数值从一种类型强制转换为另一种类型，但又超出了目标类型的表示范围，结果将会截断成一个完全不同的值。

例如`(byte)300`的实际值为44.

## 混合赋值运算符

可以在赋值中使用二元运算符,例如：

~~~java
x += 4;
~~~

等价于:

~~~java
x = x +4;
~~~

如果运算符得到一个值，其类型于左侧操作符数的类型不同，就会发生隐式的强制类型转换

~~~java
int x = 1;
x += 3;  //这是合法的，这相当于 x = (int)(x+3.5)
~~~

## 一元运算符

| 运算符 | 运算                               | 实例                   | 结果              |
| ------ | ---------------------------------- | ---------------------- | ----------------- |
| ++     | 自增（前缀），先（自增）运算再取值 | a = 3;<br />b = ++a;   | a =4<br />b = 4   |
| ++     | 自增（后缀），先取值再（自增）运算 | a = 3;<br />b = a ++； | a = 4<br />b = 3  |
| --     | 自减（前缀），先（自减）运算再取值 | a = 3;<br />b = --a;   | a = 2<br />b = 2  |
| --     | 自减（后缀），先取值再（自减）运算 | a = 3;<br />b = a --   | a  = 2<br />b = 3 |

自增自减的操作数必须时变量，不能时字面量

## 关系运算符

关系运算符用来计算两个值之间的关系，计算结果为boolean值:

* `==`相等
* `!=`不等
* `>、>=`大于、大于等于

* `<、<=`小于、小于等于

和算数运算一样，关系运算也属于二元运算，对于基本数据类型，适用于自动类型转换

**注意:**对于引用数据类型，只能进行相等和不等的比较，而且比较的是引用的地址值

## 逻辑运算符

参与逻辑运算的表达式都是布尔类型，结果也是布尔类型

* 与操作：       
    * 含义：一假即假
    * 符号
        * 逻辑操作：`&`  
        * 短路操作：`&&`
    * 敏感条件：`false `
* 或操作：
    * 含义：一真即真
    * 符号:
        * 逻辑操作：`|` 
        * 短路操作：`||`
    * 敏感条件：`true `

* 逻辑操作和短路操作：
    * 逻辑操作 顺序执行，即使找到了第一个满足了逻辑运算的敏感条件的表达式，也会执行后续表达式
    * 短路操作 顺序执行，只要找到了第一个满足了逻辑运算的敏感条件的表达式，就不会执行后续的表达式
    * 短路操作比逻辑操作更安全也更高效，在后续学习和开发下，主要使用短路操作

* 异或操作：
    * 含义：相异为真
    * 符号：`^`
* 非操作：
    * 含义：取反
    * 符号：`!`

## 位运算符

位运算直接对整数对应的二进制位进行运算操作

| 运算       | 符号   |
| ---------- | ------ |
| 按位与     | a & b  |
| 按位或     | a \| b |
| 按位异或   | a ^ b  |
| 按位取反   | ~a     |
| 左移       | a <<b  |
| 带符号右移 | a >> b |
| 无符号右移 | a>>> b |

运算名以按位前缀开始的，表示对两个操作数对应二进制的每一位进行相应的逻辑运算，0表示false，1表示true，空位用0表示

比如按位与表示对每一位二进制数进行与操作:

~~~java
0101 & 1010 = 0000;
~~~

其他按位运算依此类推











## 三元/三目运算符

* 格式 ：

    ~~~java
     条件表达式 ? 表达式1 : 表达式2;
    ~~~

* 执行流程：

    * 先执行条件表达式；
    * 如果条件表达式的结果为true，就执行表达式1，并且将表达式1的执行结果作为整个三目运算的最终结果；
    * 如果条件表达式的结果为false，就执行表达式2，并且将表达式2的执行结果作为整个三目运算的最终结果；



# 数组

* 概念：

  是一块连续的存储空间，内部有许多个小空间，有数据类型的限定，可以存入一组匹配类型的数据，根据需要可以改动小区域中的数据。

* 特点：

  可以存储一组同类型（可以多态）的数据，方便日后的维护和管理。解决了变量只能存储单个数据的局限性

* 定义格式：

  * 静态初始化：声明定义数组，创建数组对象以及为数组元素赋值同时进行。

    ~~~JAVA
    数据类型 [] 数组名 = new 数组类型[]{a1,a2,...an}
    ~~~

    简化形式：

    ~~~java
    数据类型 [] 数组名 = {a1，a2,..,an}
    ~~~

  * 动态初始化：声明，创建，赋值分开进行

    ~~~java
    数据类型[] 数组名 =new 数据类型[容量]
    ~~~

* 数组元素默认值：

  * 整数型：0
  * 浮点型 ：0.0
  * 布尔型：false
  * 字符型：空白字符
  * 引用类型：null

* 堆内存：

  * 特点：只要是new出来的对象都在堆中

    ​			堆中的对象都有地址值

    ​			对象中的区域空间都有默认值

  基本类型变量，存储在基本类型空间，内部存储的都是常量值

  引用类型变量，存储在引用类型空间，内部存储的都是对象地址值

  引用数据类型变量可以存储地址值，也可以存储null值；基本类型变量不可以

* 数组内存解析：

  * 是在堆内存中的
  * 有地址，在栈空间中存储的是地址
  * 如果在堆空间中的对象没有指针指向它，那么它会被回收

  ~~~java
  int [] arr = new int [4];
  int [] arr2 = arr;  //进行浅拷贝
  arr = null          //数组空间不会被回收，因为arr2仍指向它
  ~~~

* 数组的弊端

  * 数组的长度一旦确定无法改变

* 普通常量值传递和引用地址值传递

  * 普通常量值传递：将数据拷贝一份给方法的形参位置

    改动数据，是暂时的，方法弹栈后，原数据不变

  * 引用地址值传递：将对象地址拷贝一份给到形参位置

    改动对象数据，是永久的，方法弹栈后改动任有效

## 二维数组

定义格式：

* 静态初始化

  ~~~java
  数据类型[][] 数组名 = new 数据类型 [][] {一维数组对象，...，};
  ~~~

* 动态初始化

  * 模板一：

    ~~~java
    数据类型 [][] 数组名 =new 数据类型 [一维数组个数][一维数组的元素个数];
    ~~~

  * 模板二：

    ~~~java
    数据类型 [][] 数组名 =new 数据类型[一维数组个数][];
    ~~~

    关联一位数组对象，存放的是地址；



# 流程控制语句

顺序结构、判断结构、选择结构、循环结构

## 判断结构

* 格式一：

~~~java
if(假){
    //...
}
~~~

* 格式二：

~~~java
if(假){
    //...
}否则{
    //...
}
~~~

* 格式三：

~~~java
if(f){
    //...
}else if(t){
    //...
}else if(t){
    //...
}else{
    //...
}
~~~

## 选择结构

格式：

~~~java
switch(expression){
    case value1:
        //语句
    case value2:
    	//语句
    default:
    	//语句
   
}
~~~

注意事项：

* 绝大多数情况下，每个case的最后位置都需要定义break，防止case穿透现象

* 从语法角度上：

    default是可有可无的，并且位置是可以随意的

* 从使用角度上：

​			default一定会被定义，并且只会被定义在最后位置

* default永远是case都不满足表达式值时，才会被执行
* case标签的值可以为:
  * char、byte、short、int的常量表达式
  * 枚举常量
  * 字符串字面量


## 循环结构

* 四要素：

    * 初始化条件

    * 循环条件

    * 迭代条件

    * 循环体

### while循环

* 格式一

~~~java
while(条件表达式){
    //...  
}
~~~

* 格式二

~~~java
do{
    //...
}while(条件表达式)；
~~~

**注意**：while行后面必须有分号

**注意**：dowhile循环先执行循环体，再执行循环条件 

所以dowhile循环至少会执行一次循环体

### for循环

* 普通for循环

~~~java
for ( 初始化 ; 条件表达式 ; 迭代条件 ){
    //...
}
~~~

* 增强for循环

~~~java
for( 定义变量 : 容器对象){
    //...
}
~~~

容器对象必须实现Iterable接口

### 循环结构的关键字

在循环结构中：

* `break`：立即结束循环

* `continue`：结束当此循环，继续下一次循环

**注意**：break continue 默认只控制所在的最近的循环的流程

可以使用标签技术：

~~~java
标签名：for(){
    for(){
        break 标签名；
    }
}
~~~

