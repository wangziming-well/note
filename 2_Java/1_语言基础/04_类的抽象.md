# 抽象类

在自上而下的类的继承层次中，位于上层的类更具有通用性，或者更加抽象。

祖先类更加通用，有时候只将它当作派生其他类的基类，而不作为特定的实例类。

有的时候作为基类的方法是无法确定具体的实现的，必须由具体的派生类来实现，可以用`abstract`修饰成员方法，指示该方法是抽象的，这样就不需要实现这个方法。这种方法被称为抽象方法

有抽象方法的类，也必须用`abstract`关键字修饰，被`abstract`修饰的类被称为抽象类

很显然，抽象方法存在的意义就是被重写，所以抽象方法的权限修饰符不能为private，否则无法重写。

抽象类存在的意义就是被继承，它无法被实例化。但是抽象方法仍然有构造器，以供子类调用

如果继承的子类不是抽象类，需要重写父类，祖先类所有的抽象方法。

一个抽象类的示例:

~~~java
public abstract class Animal {
    private String name;
    public Animal(String name){
        this.name = name;
    }
    
    public Animal(){}
    
    public abstract void eat();

    public abstract void sleep();

    public String getName(){
        return name;
    }

}
~~~

# 接口

抽象类提供了一个部分抽象的类，而接口则提供了一个完全抽象的类。

interface关键字指示一个接口，产生一个完全抽象的类，它没有提供任何形式的实现。它定义的方法没有方法体，只提供了形式，并未提供任何具体实现。

一个接口指示了所有实现该特定接口的类应该具有哪些方法，不论各个接口如何实现这些方法。所有任何使用某特定接口的代码都知道可以调用该接口的哪些方法，而且仅需要知道这些。所有接口可以被用来建立类和类之间的协议。



接口和父类一样，对实现的父接口可以使用向上转型的多态。可以在`interface`关键字钱使用`public`关键字。

和类不一样的是，接口是多继承的，一个类可以实现多个接口。

## 接口定义

接口通过`interface`关键字定义接口，

实现了某接口的类，必须实现该接口定义的所有方法。

~~~java
interface InterfaceName{
    //....
}
~~~

## 接口成员

接口作为一种抽象程度很高的特殊类，也拥有成员方法和成员域，不过它们相比普通类有有所不同，接口定义的目的就是为了让其他类最终实现它,并且供外部类访问接口定义的成员(如果有的话),所以接口中的成员的访问权限必须是公共的，

所以在接口成员的权限修饰符隐式地是`public`，定义是可以省略。

基于同样的原因，接口是没有构造方法，无法实例化的。

### 成员方法

根据前述，接口的成员显然是有抽象方法的，这是接口的主要内容，所以如果没有其他修饰符，接口中的方法隐式地是`abstract`的

另外，接口中还可以定义静态方法和默认方法

### 成员域

除此之外，接口也可以包含域,但是**这些域隐式地是`static`和`final`的**，也就是说接口中定于的属性都是静态常量，这是可以理解的：

首先接口作为抽象程度很高的类，它没有构造函数，无法实例化，所以无法对接口中的属性进行初始化；

然后接口本身也不会用到自己定义的属性，接口定义的属性只为了给它的实现类和其他地方使用。

上述两点决定了接口中的域只能是静态的常量

## 实现和继承

具体的类通过`implements`关键字指示实现特定的接口。

~~~java
class ClassName implements InterfaceName{
    //重写接口中的所有抽象方法
}
~~~

这个类就称为接口的实现类

和继承类一样，实现接口也可以应用向上转型的多态

一个类只能继承一个父类，可以实现多个父接口，类可以同时继承和实现:

~~~java
class D extends C implements A,B{
}//其中C是类，A，B是接口
~~~

接口之间可以通过`extends`关键字指示继承，接口之间是多继承的:

~~~java
interface C extends A,B  {
}
~~~

### 类优先原则

接口和父类中都定义了相同名字的默认方法和非静态方法时，如果类继承父类的同时实现了这个接口，在外界创建实现类的对象，调用同名方法，默认调用执行的是父类的该方法。

如果想要访问接口的方法，需要在实现类中对其重写：

~~~java
//实现类中假设同名方法为method
public void method(){
    Inter.super.method();
}
~~~

如果多实现的接口中有相同名称的默认方法，实现类中必须重写该方法；因为多个接口的优先级是一样的；

## 使用接口

接口允许同一个接口具有多个不同的具体实现；这中特性让我们能灵活的使用接口。

接口的一种常见用法就是策略模式。编写的方法入参是定义好的接口，调用者可以使用任何想要的对象来调用该方法，只要对象实现了对应的接口。这使方法更加灵活通用。

如比较器接口的使用:

我们可以很自然地根据大小对数字数组进行排序，但是对于对象，很难有一种标准的排序依据，所以Java将排序的标准交给客户端程序员来自己定义，提供了比较器的接口，通过实现不同的比较器，我们可以实现不同的排序策略。

