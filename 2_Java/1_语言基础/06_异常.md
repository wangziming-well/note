# 异常概述

一个健壮的Java程序在设计时会对可能出现的异常进行处理，如用户输入错误、环境错误、物理限制、设备错误等等....

但是，错误发生的地方，和可能处理错误的地方可能隔了很远，错误发生处的代码也可能不清楚该怎么处理当前的错误。比如在一个方法内发生了错误，如果这样的错误不是在方法内能处理的，就需要通知调用该方法的地方，发生了错误。比如返回一个错误码。

但是，方法不是总有返回值的，返回值的类型也不是固定的。很难通过这种方式统一约定错误码。

所以Java单独提供了一套异常体系和异常处理方式。

异常体系中的类型对象保存了完整的错误信息

通过“抛出”的方式抛出异常对象通知方法的调用方发生了什么异常。

通过异常处理的机制来处理抛出的异常。

# 异常体系

在Java程序设计语言中，异常类型都派生自`Throwable`类，其继承体系如下:

![Throwable](https://gitee.com/wangziming707/note-pic/raw/master/img/Throwable.png)

所有的异常类型都继承自`Throwable`但不会直接继承它，而是继承它的子类`Error`和`Exception`

`Error`类描述的是Java运行时系统的内部错误。应用程序不应该抛出这种类型的对象，(即使抛出，程序也无法处理这样的错误),除了通知用户，并尽力使程序安全地终止之外，我们无法再多做其他事情

`Exception`的层次结构又分解为两个分支：

一个 分支派生于`RuntimeException`表示由程序错误导致的异常，如：错误的类型转换、数组访问越界、访问空指针等

另一个分支则直接继承`Exception`，表示程序本身没有问题，由其他错误引起的异常。 如`IOException`表示的I/O错误、打开一个不存在的文件等

Java语言规范将派生于`Error`类和`RuntimeException`类的所有异常成为非受查(unchecked)异常，所有其他的异常成为受查(checked)异常。

## 自定义异常

在程序中，可能会遇到任何标准异常类都没有充分描述清楚的问题。这种情况下可以创建自定义异常。我们只需要定义一个`Exception`类的子类，或者`Exception`子类的子类。

习惯上，自定义的类应该包含两个构造器，一个默认构造器，一个带有详细描述信息的构造器(超类`Throwable`的`toString`方法将会返回这些详细信息)

例如定义一个`IOException`的子类：

~~~java
public class FileFormatException extends IOException {
    public FileFormatException() {
    }

    public FileFormatException(String message) {
        super(message);
    }
}
~~~

# 异常处理

有了异常体系定义的各种异常后，我们就可以抛出异常、声明异常、处理异常了

## 声明异常

在之前讲述方法的构成时我们说，方法签名由方法名和形参列表构成，实际上除此以外，方法签名还可以有异常声明，以通知方法的调用方该方法可能抛出的异常

通过`throws`子句声明异常，如:

~~~java
public FileInputStream(String name) throws FileNotFoundException{
    ......
}
~~~

如果方法体内有通过`throw`子句抛出受查异常，或者方法体内调用了一个抛出受查异常的方法，则该方法必须通过`throws`子句声明这些可能抛出的异常；否则编译器将报错。

当然也可以声明非受查异常，但是不应该这样做，因为:

* 对于`Error` 类型的非受查异常:程序代码对`Error`的异常是无法处理的，而且任何程序代码都具有抛出`Error`异常的可能

* 对`RuntimeException`类型的非受查异常，它完全在我们的控制之下，能够通过修改程序避免。

总之，一个方法必须声明所有可能抛出的受查异常， 而非受查异常要么不可控制（`Error`),要么就应该避免发生 （ `RuntimeException `)  

### 声明多个异常

如果一个方法有可能抛出多个受查异常类型， 那么就必须在方法的首部声明所有的异常类。每个异常类之间用逗号隔开，如:

~~~java
public Image loadlmage(String s) throws FileNotFoundException, EOFException{
    //......
}
~~~

如果抛出了多个异常，也可以通过声明它们的父类来替代所有的异常，当然，并不推荐这样做。

### 覆盖中的异常声明

如果在子类中覆盖了超类的一个方法， 子类方法中声明的受查异常不能比超类方法中声明的异常更通用，这体现在:

* 如果超类方法没有声明异常，那么子类方法也不能声明异常
* 如果超类方法声明了异常，那么子类方法必须声明该异常或异常的子类

## 抛出异常

在方法中，通过`throw`关键字抛出异常:

~~~java
throw throwableObject; //throwableObject是异常对象
~~~

例如：

~~~java
throw new IOException();
//或者
EOFException e = new EOFException();
throw e;
~~~

注意`throw`子句只能写在方法体内部，并且如果抛出的异常是受查异常，则方法必须声明该异常。

如果方法程序运行到throw子句，那么该方法就不会返回给调用者，而是抛出该异常给调用者，让调用者(或者调用者的调用者)处理该异常

## 捕获异常

如果某个异常发生后没有在任何地方进行捕获，那么这个异常最终将通过主函数抛给虚拟机，虚拟机将终止程序并在控制台打印异常信息(包括异常的类型和堆栈内容)

通过`try/catch`语句块捕获程序中的异常，其简单格式如下:

~~~java
try{
    //可能抛出异常的代码
}catch(ExceptionType e){ 
    //异常处理器代码
}
~~~

如果在`try `语句块中的任何代码抛出的异常类是在`catch`子句中说明的异常类或者其子类,那么：

* 程序将跳过`try`语句块的其余代码
* 程序将执行`catch`子句中的处理器代码



### finally代码块

* 描述：

    * 属于try的子语句


    * 表示无论是否发生异常都会执行的代码


* 格式

    ~~~JAVA
    try{
        //可能发生异常的代码
    }catch( E e){
        //处理异常
    }finally{
        //不管是否发生异常都会执行的代码
    }
    ~~~
    
    
    
* 注意点：

    * 输出到控制台的错误信息是通过`System.err.println();`

        语句打印的，与`System.out.println();`是不同的线程，所以会有抢夺资源现象；

    * 如果有finally语句，这在return之后还会执行finally（return的值会暂存在栈里面，等待finally执行后再返回）
