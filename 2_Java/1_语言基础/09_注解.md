





# 注解

注解是JDK1.5引用的特性，是Java中是引用类型

通过代码标识注解， 对代码进行解析

## 常用内置注解

* `@override` ：声明在方法上，检测被注解的方法是否为重写的方法。
* `@FunctionalInterface `： 声明在接口上,检测被注解的接口是否为函数式接口。
* `@Deprecated` ： 标记当前方法已经过时。
* `@SuppressWarnings`：抑制警告，让编译器不要报出警告信息。



## 声明与使用

* 定义注解的语法格式：

~~~java
public @interface MyAnnotation{
    public 数据类型 变量名();
    public 数据类型 变量名() default 值;
}
~~~

注解中只有成员变量，没有成员方法，并且变量默认`public `修饰

注解中成员变量的数据类型只能是：

8大基本类型、String、枚举、注解、Class、以及相应一维为数组

* 使用格式

~~~java
@注解名(属性=值,属性=值)
~~~

1. 如果没有限定注解的使用范围，那么注解可以使用在：
   类上、方法上、变量上、参数上、包上......
2. 如果注解中声明的变量没有赋值，那么必须在使用的赋值。
3. 如果属性名为`value` ，赋值的时候 `value= `可以省略。



## 元注解

注解的注解，用来解释注解

设置注解的使用范围和生命周期



### @Targer

通过成员变量`ElementType[] value`数组枚举，设置注解的作用范围

`ElementType`

~~~java
ackage java.lang.annotation;

public enum ElementType {
    TYPE,               /* 类、接口（包括注释类型）或枚举声明  */

    FIELD,              /* 字段声明（包括枚举常量）  */

    METHOD,             /* 方法声明  */

    PARAMETER,          /* 参数声明  */

    CONSTRUCTOR,        /* 构造方法声明  */

    LOCAL_VARIABLE,     /* 局部变量声明  */

    ANNOTATION_TYPE,    /* 注释类型声明  */

    PACKAGE             /* 包声明  */
}
~~~

### @Retention

通过成员变量 `RetentionPolicy value`设置注解的生命周期：

`RetentionPolicy`

~~~java
package java.lang.annotation;
public enum RetentionPolicy {
    SOURCE,            /* Annotation信息仅存在于编译器处理期间，编译器处理完之后就没有该Annotation信息了  */

    CLASS,             /* 编译器将Annotation存储于类对应的.class文件中。默认行为  */

    RUNTIME            /* 编译器将Annotation存储于class文件中，并且可由JVM读入 */
}
~~~

# 模拟@Test注解

* 定义注解

~~~java
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface MyTest {
}
~~~

* 定义测试类

~~~java
public class TestDemo {
    @MyTest
    public void demo1(){
        System.out.println("demo1......");
    }
    @MyTest
    public void demo2(){
        System.out.println("demo2......");
    }
    @MyTest
    public void demo3(){
        System.out.println("demo3......");
    }
    @MyTest
    public void demo4(){
        System.out.println("demo4......");
    }
}
~~~

* 定义解析注解方法

~~~java
import java.lang.reflect.Method;

public static void main(String[] args) throws Exception {
    Class<?> aClass = Class.forName("org.reflect.TestDemo");
    TestDemo testDemo = (TestDemo)aClass.getConstructor().newInstance();
    Method[] methods = aClass.getMethods();
    for(Method method :methods){
        if(method.isAnnotationPresent(MyTest.class)){
            method.invoke(testDemo);
        }
    }
}
~~~

