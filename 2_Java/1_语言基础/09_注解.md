# 注解

注解也叫元数据，为我 们在代码中添加信息提供了形式化的方法

通过注解，我们可以将元数据保存在Java源代码中，并利用annotation API 为自己的注解构造处理工具

## 使用注解

注解名和普通类名不同，以`@`符号作为前缀；将注解名声明在方法、变量、类的修饰符位置以声明注解，如:

~~~java
public class Demo {
    @Override
    public String toString() {
        return super.toString();
    }
}
~~~

## 内置注解

Java的`java.lang`包中定义了以下注解:

* `@override` ：声明在方法上，检测被注解的方法是否为重写的方法。
* `@FunctionalInterface `： 声明在接口上,检测被注解的接口是否为函数式接口。
* `@Deprecated` ： 标记当前方法已经过时。
* `@SuppressWarnings`：抑制警告，让编译器不要报出警告信息。

## 定义注解

注解的定义很想接口，使用`@interface`关键字指示注解定义；

定义注解时，需要一些元注解来指示注解的定义和作用范围如`@Target`、`@Retention`等

~~~java
@Target({ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
public @interface Test {
}
~~~

在注解中，一般会定义一些元素以表示某些值。当分析注解时，程序或工具可以利用这些值。注解的元素看起来像接口的方法，唯一的区别时可以为其指定默认值,如：

~~~java
public @interface MyAnnotation{
    public String name();
    public int age() default 18;
}
~~~

没有元素的注解称为标记注解，如上面的`@Test`

注解的元素默认是`public`的，定义时可省略

注解元素的数据类型只能是：

* 基本类型
* String
* enum
* Annotation
* Class
* 以上类型的一维数组

注解元素的默认值不能为`null`

在声明注解时，可以通过类似键值对的方式给注解的元素赋值:

~~~java
@MyAnnotation(name = "Robot", age = 2)
~~~

如果注解中声明的元素没有默认值，那么必须在使用的赋值。

如果元素名为`value` ，且赋值只有一个value时赋值的时候 `value= `可以省略。





## 元注解

元注解专门用来负责注解其他注解，以界定注解的作用范围和运行层级等

### @Target

表示该注解可以用于什么地方。

通过元素`ElementType[] value`数组枚举，设置注解的作用范围：

~~~java
package java.lang.annotation;

public enum ElementType {
    TYPE,               // 类、接口（包括注释类型）或枚举声明  
    FIELD,              // 字段声明（包括枚举常量）
    METHOD,             // 方法声明
    PARAMETER,          // 参数声明
    CONSTRUCTOR,        // 构造方法声明
    LOCAL_VARIABLE,     // 局部变量声明
    ANNOTATION_TYPE,    // 注释类型声明
    PACKAGE             // 包声明
}
~~~

### @Retention

表示需要在什么级别保存该注解信息

通过成员变量 `RetentionPolicy value`设置：

~~~java
package java.lang.annotation;
public enum RetentionPolicy {
    SOURCE,   //Annotation信息仅存在于编译器处理期间，编译后将丢弃
    CLASS,    //注解在class文件中可用，但会被VM丢弃
    RUNTIME   //VM将在运行期间保留注解，反射机制只能读取到该层次的注解信息
}
~~~

### `@Documented`

将次注解包含在Javadoc中

###  `@Inherited`

允许子类继承父类中的注解

# 注解处理器

如果没有用来读取注解的工具，那么注解不会比注释更有用

可以通过反射机制的API来构造注解处理工具

可以通过外部工具apt解析都带有注解的Java源代码

## 反射注解处理器

反射类`Class`、`Field`、`Constructor`、`Method`都直接或间接地实现了`AnnotatedElement`接口，这个接口规范了访问标注在类、类成员上的注解的方法:

~~~java
public interface AnnotatedElement {
    default boolean isAnnotationPresent(Class<? extends Annotation> annotationClass);
    <T extends Annotation> T getAnnotation(Class<T> annotationClass);
    Annotation[] getAnnotations();
    default <T extends Annotation> T[] getAnnotationsByType(Class<T> annotationClass);
    default <T extends Annotation> T getDeclaredAnnotation(Class<T> annotationClass);
    default <T extends Annotation> T[] getDeclaredAnnotationsByType(Class<T> annotationClass);
    Annotation[] getDeclaredAnnotations();
}
~~~

通过获取到的`Annotation`实例访问注解元素

实例：

如定义一个注解：

~~~java
@Target({ElementType.METHOD,ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
public @interface Test {
    String name() default "wzm";
    int age() default 10;
}
~~~

然后标注在一个类上:

~~~java
@Test
public class Demo {
	//......
}
~~~

那么通过如下代码就可以访问注解和注解元素：

~~~java
Class<Demo> demoClass = Demo.class;
Test annotation = demoClass.getAnnotation(Test.class);
int age = annotation.age();
~~~

## APT注解处理器

==TODO==
