# 面向对象程序设计概述

谈论面向对象的程序设计(Object-Oriented Programming)一定要一起谈过程化的程序设计的(Procedure-Oriented Programming)。

OOP自POP演化而来，又蕴含着POP

## 抽象过程

### 抽象

抽象能力是人类能分析处理复杂事物的根本能力。将事务的本质方面、主要方面提取出来、舍弃非本质、非主要的东西，从而形成概念和范畴的思维能力就是抽象能力。

将复杂的事物抽象为概念范畴，抓住事物的本质，对事物做符合当前分析框架下的简化，在此基础上人们才能分析处理复杂事物。人们所能解决的问题的复杂性直接取决于抽象的类型和质量。

### 编程与抽象

使用编程语言解决问题也是对事物抽象的过程。

面向过程的编程方式是对计算机结构的抽象，抽象出机器模型。但是想要真正的解决问题，我们仍然需要对问题相关的实体进行抽象，抽象出问题模型。想要真正解决问题。我们还需要额外建立机器模型和问题模型之间的关联映射。这种关联映射的建立是费力的，而且这不属于编程语言所固有的能力，这使得程序难以编写和维护，所以面向过程的抽象类型只适合不复杂的程序。

面向对象的编程方式则是直接对问题相关的实体进行抽象。这样抽象出来的模型我们称之为对象。这样不需要额外的映射关系，程序员在编写代码的同时，也就是在表述问题的解决方案。与POP相比，这显示是一种更灵活、更强大的语言抽象。

总之，OOP根据问题来描述问题、而POP根据运行解决方案的计算机来描述问题。

实际上OOP和POP仍然有联系：OOP抽象出的对象内部仍然是使用POP的抽象方式来实现对象的行为特性。

## 对象和类

作为问题相关实体的抽象模型，对象可能具有状态、行为、标识。

对应的程序设计中的对象模型的实现，它应该具有内部数据(它们给出了对象的状态)和方法（它们产生的行为），并且每个对象都可以唯一地与其他对象区分开来，即对象在内存中有唯一的地址。

所有的对象都是唯一的，但同时也是具有相同特性和行为的对象所归属的类的一部分

类，或者说对象的类型描述了具有相同特性(数据元素)和行为(功能)的对象集合，也可以说是对象的模板

在程序设计中，类对应的是一个数据类型；可以自定义的数据类型

## 面向对象设计

在设计一个面向对象的程序时，最好的方法是将对象看为服务提供者(Service Provider)程序本身将向用户提供服务，它将通过调用其他对象提供的服务来实现这一目的。

将对象看作是服务提供者还有利于提高对象的内聚性。 

在良好的面向对象设计中，每个对象都可以很好地完成一项任务，但是它不会做更多的事情。

## 封装

封装就是将数据和行为组合在对象中，并对对象的使用者隐藏了数据的实现方式。类创建者通过访问权限控制哪些类成员暴露给外界，哪些类成员隐藏在对象内部。

对象的封装行为赋予了对象很好的特性：

* 封装给对象赋予了黑盒的特征，我们不需要了解一个对象内部的构成，也可以很好的使用这个对象提供的服务。这提高了重用性和可靠性。

* 只暴露需要暴露的类成员，对象的使用者无法操作类内部成员，这样可以避免造成不必要的风险和bug

* 类的设计者可以改变类内部的构成方式而不影响到类的使用

## 组合

一个完成的类代表一个可供复用的代码单元。代码复用是面向对象程序设计语言所提供的最优秀的特性之一。

最简单的复用就是直接使用该类的一个对象，也可以在一个类中创建另一个类的对象。即创建一个成员对象。

这种方式称为组合。

组合相对于继承对代码的复用更加简单灵活

## 继承

在问题涉及的实体之间，往往存在着联系，比如说“像”和“是”的关系，

面向对象的程序设计中有些时候需要体现这种关系，以实现良好的架构。这就是类之间的继承关系

通过继承，我们可以构建出符合逻辑的类的层次体系

继承允许我们在基类的基础上通过添加或者修改(覆盖)这个类的接口来创建新类，通过继承基类创建出来的类称为该基类的子类

* 覆盖:如果子类只覆盖基类的接口，那么子类和基类就拥有完全相同的接口，这样子类和基类就是完全相同的类型这样就就可以用这个子类来完全替代基类。这叫做纯粹替代，或者叫替代原则。这种情况下子类和基类就是“是”的关系

* 添加：有时必须在子类中添加新的接口元素。这样的子类仍然可以替代基类，带这种替代不完美，因为基类无法访问新添加的方法。这种情况下子类和基类就是“像”的关系

### 多态

在处理类型的层次结构时，可以不把一个对象当作它所属的特定类型来对待，而是将其当作其基类的对象来对待。

这样可以在扩展新类型的基础上，不影响现有的代码。

#### 绑定

这样会牵扯一个问题，在执行一个多态的方法调用时，需要确定调用的具体是哪个方法(因为在多态的行为下，同一个方法在不同的对象中有不同的实现)

不管怎样，执行方法是需要将方法名和方法对应具体代码地址绑定起来

在之前，这种绑定使用的是前期绑定:编译器在编译时就完成了方法绑定，为方法提供了具体代码的地址调用

但在多态环境中，在代码运行前是无法确认方法调用的方法具体是哪个的，所以编译时无法进行绑定，只能将绑定的过程放在方法调用时，这就是后期绑定

# 创建和持有对象

通过类的构造器(constructor)构造对象实例，通过`new`关键字，如:

~~~java
new Date();
~~~

创建对象实例后，如果希望对象可以多次使用，需要将对象的引用存储到对应类型的变量中:

~~~java
Date birthday = new Date();
~~~

一个对象变量并没有实际包含一个对象，仅仅是引用一个对象。

在 Java 中，任何对象变量的值都是对存储在另外一个地方的一个对象的引用。new 操作符的返回值也是一个引用  

# Java类

类是构建对象的模板,由 `class`关键字定义，类名一般大写，简单的类定义形式为:

~~~java
class ClassName{
    field1;
    field2;
    ...
    constructor1;
    constructor2;
    ...
    method1;
    method2;
    ...
}
~~~

类名在class关键字后，紧跟着的大括号中定义类成员

类成员包括构造器、域、方法

## Constructor

构造器与类同名。在创建对应类时，构造器会运行，以将实例域初始化为所希望的状态。

构造器方法一定是`public`的

构造器没有返回值，总是伴随着new操作符的执行被调用

构造器可以有0个、1个或多个参数

每个类可以有一个以上的构造器

* 一个类如果不显示地定义构造方法，编译器会隐式地添加一个空参数的构造方法作为默认构造
* 如果程序员定义了构造方法，编译器就不会提供默认构造；
* 一个类中可以定义多个构造方法，它们之间发生重载现象；

* 构造方法的具体处理过程：

  * 初始化所有域的默认值(0、false或null)
  * 按照在类声明中出现的次序，依次执行所有域初始化语句和初始化块。

  * 执行这个构造器的主体。

## 成员域

又叫属性，是定义在成员位置的（类内部，方法体外）的变量



注意与局部变量（方法体内定义的变量）作区分

## 成员方法

又称为函数，是描述一段功能逻辑代码的，通过方法名对其进行调用执行。

方法由返回值类型、方法签名、方法体构成

方法签名包括方法名和参数列表

* 定义格式：

~~~java
修饰符 返回值类型 方法名(参数类型 参数名，参数类型 参数名...){
    ...
    方法体
    ...
    return 返回值;//如果方法需要返回
}
~~~

方法的返回值类型是void时，也可以有return，此时直接在return后加分号，不写任何数据。此时语句只起到结束方法的作用

不能有两个名字相同、参数类型也相同但返回不同类型值的方法。

### 参数传递

在程序设计语言中将参数传递给方法有如下方式:

* 按值调用/值传递(call by value):表示方法接收的时调用者提供的值
* 按引用调用/引用传递(call by reference):表示方法接收的时调用者提供的变量地址。

一个方法可以修改传递引用所对应的变量值，而不能修改传递值调用所对应的变量值。

Java程序设计语言总是采用按值调用。也就是说，方法得到的时所有参数值的一个拷贝，所以方法不能修改传递给它的任何参数变量的内容。

但是，Java的参数类型有两种:基本数据类型和引用数据类型

显然，方法无法修改传递的变量值(不论是引用数据类型变量和基本数据类型变量)，因为值传递只拷贝了一份变量给方法

但是，如果传递的是引用数据类型的变量，方法可以改变该引用指向的对象的状态，因为Java的引用数据类型变量持有的是对象引用，值传递将对象引用拷贝了一份传递给了方法，方法可以通过拷贝的引用访问同一个对象,以更改对象的状态。

### this

调用类方法会在方法内存中开辟一个this变量空间，指向类的地址，这样才可以让类方法在栈中调用类中的属性。

* this：记录正在被创建，或者已经被创建的类的地址

* 区分同名的成员变量和局部变量

* 本类构造方法之间的相互调用

  ~~~java
  this(形参列表)；
  ~~~

对this的调用必须是构造器中的第一个语句；(与super()冲突)

### 可变参数

当函数

~~~java
修饰符 返回值类型 方法名(数据类型 ... 变量名){

~~~

* 底层是可变数组，在方法体内用数组接收
* 只能定义在形参列表的最后位置
* 只能有一个；

## 代码块

### 构造代码块

一个类的声明中，可以包含多个构造代码块。只要构造类的对象，这些块就会被执行。

* 定义格式：

  ~~~java
  {
      //...
  }
  ~~~

### 静态代码块

随着类的加载而加载，只会被执行一次；可以初始化静态域、或者加载一些类公用的资源

定义格式：

~~~java
static {
    //..
}
~~~

## 内部类

在一个类的内部定义了一个类

外部的类称为外部类，内部的类称为内部类

在类的内部又有一个独立的内部结构，有必要的话可以将其单独定义一个类（内部类），

内部类需要依赖于外部类，不存在单独定义的情况。

### 分类

从定义位置上划分：

​		成员内部类

​		局部内部类

对成员内部类进行划分：

​		非静态成员内部类

​		静态成员内部类

对局部内部类进行划分：

​		局部内部类：定义在局部位置的有名字的内部类

​		匿名内部类：定义在局部位置的没有名字的内部类

### 匿名内部类

作用、意义：

场景搭建：

~~~java
class A{
    func(){
        //...
    }
}

class B extends A{
    @override
    func(){
        //....
	}
}

main(){
    new B().func();
}
~~~

##### 定义格式：

* 情况一：和父类有关

~~~java
new 父类名(){
    //匿名子类成员的设计
}；
~~~



~~~java
new A(){
    @override
    func(){
        //....
	}
}.func();
~~~



* 情况二 ： 和接口有关

~~~java
new 接口名(){
    //匿名实现类成员的设计
}；
~~~

## 重载

在同一个类中，如果多个方法的有相同的方法名、不同的参数(参数类型不同，参数数量不同，参数类型排序不同)，则发生重载。

调用重载方法时，编译器必须挑选出具体执行哪个方法，它通过使用各个方法给出的参数类型和特定方法调用所使用的值类型进行匹配来挑选出相同的方法。如果编译器找不到匹配的参数，就会产生编译时错误。这个过程被称为重载解析

## 修饰符

### 权限修饰符

在类中通过权限修饰符界定类成员的访问权限，权限修饰符有如下:

| 修饰符    | 本类中 | 同包不同类 | 不同包子父类 | 不同包不同类 |
| --------- | ------ | ---------- | ------------ | ------------ |
| private   | ○      | ×          | ×            | ×            |
| 缺省      | ○      | ○          | ×            | ×            |
| protected | ○      | ○          | ○            | ×            |
| public    | ○      | ○          | ○            | ○            |

### final修饰符

final可以修饰类成员中的成员变量和成员方法，也可以直接修饰类:

* 修饰属性：构建对象时必须初始化这样的域。并且在后续的操作中，不能对它进行修改。
* 修饰成员方法：这样的方法不能被子类重写

*  修饰类： 这样的类不能被其他类继承、没有子类

### static修饰符

static可以修饰除构造器外的其他类成员，被static关键字修饰的类成员称为静态成员。否则称为非静态成员。

静态成员随着类加载而加载。而非静态成员随着对象的加载而加载。

作为对象的模板，类加载的时机时早于对象加载的，静态成员方法无法访问非静态成员。

在类的外部，类的静态成员可以直接通过类名访问,但无法通过具体的对象访问:

~~~java
public class StaticDemo {

    public static int i = 1;

    public static void print(){
        System.out.println("Hello");
    }
}
~~~

可以通过如下格式访问:

~~~java
StaticDemo.i ++;
StaticDemo.print();
~~~

# Java类管理

## 包

Java允许使用包(package)将类组织起来。借助于包可以方便地组织自己的代码，并将自己的代码于别人提供的代码库分开管理。

使用包的主要原因是确保类名的唯一性。

### 类的导入

一个类可以使用所属包中的所有类，以及其他包中的公共类(public class)。我们可以采用两种方式访问另一个包中的公有类。

一种方式是在每个类名前添加完整的包名：

~~~java
java.util.Random r = new java.util.Random();
~~~

另一种是使用`import`语句导入一个特定的类或者整个包

`import`语句应该位于源文件的顶部、package语句的后面:

~~~java
import java.util.Random; //导入Random类
import java.util.* //导入util包中的所有类
~~~

`import`语句不仅可以导入类，还可以导入静态方法和静态域

~~~java
import java.lang.System.*; //导入System类中所有静态方法和静态域
import java.lang.System.out;//导入特定的静态方法和静态域
~~~

这样就可以直接使用System类的静态方法和静态域，而不必加类名前缀。

java.lang是常用的包，不需要导包就能直接使用

## 类路径

路径就是java编译器或JVM用来定位类的基目录，类路径可以有多个，是一组路径的集合。

类路径所列出来的目录和归档文件是搜索类的起始点。

使用`java -classpath 路径集合`或者`java -cp 路径集合`指定类路径

## 文档注释

JDK提供了工具javadoc，它可以由源文件生成一个HTML文档。

它根据源代码中`/**`开始的注释生成文档

### 注释的插入

javadoc从以下特性中抽取信息:

* 包
* 公共类和接口
* 公共的和受保护的构造器和方法
* 公共的和受保护的域

应该在上面几部分编写注释。注释应该放置在所描述特性的前面

注释以`/**`开始，以`*/`结束

`/** ... */`文档注释中的文本叫自由格式文本。

自由格式文本的第一句应该是一个概要性的句子。javadoc自动地将这些句子抽取出来形成概要页。

自由格式文本可以使用特定的标记如`@author`、`@param`等

自由格式文本可以使用HTML修饰符，例如`<em>`、`<strong>`、`<img>`

### 自由格式文本标记

类标记

* `@author`产生作者条目，可以使用多个`@author`

* `@version`产生版本条目

方法标记

* `@param`描述当前方法的参数
* `@return`描述当前方法的返回值
* `@throws`描述当前方法可能抛出的异常

通用标记

* `@since`产生始于条目
* `@ses`新增一个超链接

### 注释的抽取

可以使用`java -d docDirectory nameOfPackage`命令生成包文档

# Java类的继承

Java中使用关键字`extends`表示类的继承:

~~~java
class SubClass extends SuperClass{
    //...
}
~~~

关键字`extends`表明正在构造的新类派生于一个已存在的类。

这个已存在的类称为超类(superclass)、基类(base class)或父类(parent class)

这个新类称为子类(subclass)、派生类(derived class)或孩子类(child class)

子类将自动得到超类中所有的域和方法，但子类是无法访问超类中的私有域和私有方法的。

注意:Java仅支持单继承

## 覆盖方法

有时候，超类中的某些方法对子类不一定适用，那么子类可以提供一个相同的方法，并重写方法体，以覆盖超类的行为

除了方法体和权限修饰符外，子类的方法各个组成部分必须和超类一样

并且子类方法的访问权限修饰符必须不小于父类方法的权限

## 子类构造器

可以在子类的构造器中通过super关键字显示地调用超类的构造器。该调用语句必须在子类构造器的第一句。

如果子类的构造器没有显式地调用超类的构造器，那么将自动地调用超类的默认构造器。此时如果超类没有定义默认的无参构造器，那么编译器将报错。所以建议为每个类都定义一个默认的无参构造。

## super

在Java中，使用关键字super调用超类的方法，super和this不一样，不是一个对象的引用，它只是一个指示编译器调用超类方法的特殊关键字

可以用super在子类中调用父类的成员

* 调用父类构造方法`super(...)`


* 调用父类的普通方法`super.method(...)`

## 继承层次



## 多态
