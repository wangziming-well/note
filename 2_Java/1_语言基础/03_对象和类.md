# 面向对象程序设计概述

谈论面向对象的程序设计(Object-Oriented Programming)一定要一起谈过程化的程序设计的(Procedure-Oriented Programming)。

OOP自POP演化而来，又蕴含着POP

## 抽象过程

### 抽象

抽象能力是人类能分析处理复杂事物的根本能力。将事务的本质方面、主要方面提取出来、舍弃非本质、非主要的东西，从而形成概念和范畴的思维能力就是抽象能力。

将复杂的事物抽象为概念范畴，抓住事物的本质，对事物做符合当前分析框架下的简化，在此基础上人们才能分析处理复杂事物。人们所能解决的问题的复杂性直接取决于抽象的类型和质量。

### 编程与抽象

使用编程语言解决问题也是对事物抽象的过程。

面向过程的编程方式是对计算机结构的抽象，抽象出机器模型。但是想要真正的解决问题，我们仍然需要对问题相关的实体进行抽象，抽象出问题模型。想要真正解决问题。我们还需要额外建立机器模型和问题模型之间的关联映射。这种关联映射的建立是费力的，而且这不属于编程语言所固有的能力，这使得程序难以编写和维护，所以面向过程的抽象类型只适合不复杂的程序。

面向对象的编程方式则是直接对问题相关的实体进行抽象。这样抽象出来的模型我们称之为对象。这样不需要额外的映射关系，程序员在编写代码的同时，也就是在表述问题的解决方案。与POP相比，这显示是一种更灵活、更强大的语言抽象。

总之，OOP根据问题来描述问题、而POP根据运行解决方案的计算机来描述问题。

实际上OOP和POP仍然有联系：OOP抽象出的对象内部仍然是使用POP的抽象方式来实现对象的行为特性。

## 对象和类

作为问题相关实体的抽象模型，对象可能具有状态、行为、标识。

对应的程序设计中的对象模型的实现，它应该具有内部数据(它们给出了对象的状态)和方法（它们产生的行为），并且每个对象都可以唯一地与其他对象区分开来，即对象在内存中有唯一的地址。

所有的对象都是唯一的，但同时也是具有相同特性和行为的对象所归属的类的一部分

类，或者说对象的类型描述了具有相同特性(数据元素)和行为(功能)的对象集合，也可以说是对象的模板

在程序设计中，类对应的是一个数据类型；可以自定义的数据类型

## 面向对象设计

在设计一个面向对象的程序时，最好的方法是将对象看为服务提供者(Service Provider)程序本身将向用户提供服务，它将通过调用其他对象提供的服务来实现这一目的。

将对象看作是服务提供者还有利于提高对象的内聚性。 

在良好的面向对象设计中，每个对象都可以很好地完成一项任务，但是它不会做更多的事情。

## 封装

封装就是将数据和行为组合在对象中，并对对象的使用者隐藏了数据的实现方式。类创建者通过访问权限控制哪些类成员暴露给外界，哪些类成员隐藏在对象内部。

对象的封装行为赋予了对象很好的特性：

* 封装给对象赋予了黑盒的特征，我们不需要了解一个对象内部的构成，也可以很好的使用这个对象提供的服务。这提高了重用性和可靠性。

* 只暴露需要暴露的类成员，对象的使用者无法操作类内部成员，这样可以避免造成不必要的风险和bug

* 类的设计者可以改变类内部的构成方式而不影响到类的使用

## 组合

一个完成的类代表一个可供复用的代码单元。代码复用是面向对象程序设计语言所提供的最优秀的特性之一。

最简单的复用就是直接使用该类的一个对象，也可以在一个类中创建另一个类的对象。即创建一个成员对象。

这种方式称为组合。

组合相对于继承对代码的复用更加简单灵活

## 继承

在问题涉及的实体之间，往往存在着联系，比如说“像”和“是”的关系，

面向对象的程序设计中有些时候需要体现这种关系，以实现良好的架构。这就是类之间的继承关系

通过继承，我们可以构建出符合逻辑的类的层次体系

继承允许我们在基类的基础上通过添加或者修改(覆盖)这个类的接口来创建新类，通过继承基类创建出来的类称为该基类的子类

* 覆盖:如果子类只覆盖基类的接口，那么子类和基类就拥有完全相同的接口，这样子类和基类就是完全相同的类型这样就就可以用这个子类来完全替代基类。这叫做纯粹替代，或者叫替代原则。这种情况下子类和基类就是“是”的关系

* 添加：有时必须在子类中添加新的接口元素。这样的子类仍然可以替代基类，带这种替代不完美，因为基类无法访问新添加的方法。这种情况下子类和基类就是“像”的关系

### 多态

在处理类型的层次结构时，可以不把一个对象当作它所属的特定类型来对待，而是将其当作其基类的对象来对待。

这样可以在扩展新类型的基础上，不影响现有的代码。

#### 绑定

这样会牵扯一个问题，在执行一个多态的方法调用时，需要确定调用的具体是哪个方法(因为在多态的行为下，同一个方法在不同的对象中有不同的实现)

不管怎样，执行方法是需要将方法名和方法对应具体代码地址绑定起来

在之前，这种绑定使用的是前期绑定:编译器在编译时就完成了方法绑定，为方法提供了具体代码的地址调用

但在多态环境中，在代码运行前是无法确认方法调用的方法具体是哪个对象的，所以编译时无法进行绑定，只能将绑定的过程放在方法调用时，这就是后期绑定

# 创建和持有对象

通过类的构造器(constructor)构造对象实例，通过`new`关键字，如:

~~~java
new Date();
~~~

创建对象实例后，如果希望对象可以多次使用，需要将对象的引用存储到对应类型的变量中:

~~~java
Date birthday = new Date();
~~~

一个对象变量并没有实际包含一个对象，仅仅是引用一个对象。

在 Java 中，任何对象变量的值都是对存储在另外一个地方的一个对象的引用。new 操作符的返回值也是一个引用  

# Java类

类是构建对象的模板,由 `class`关键字定义，类名一般大写，简单的类定义形式为:

~~~java
class ClassName{
    field1;
    field2;
    ...
    constructor1;
    constructor2;
    ...
    method1;
    method2;
    ...
}
~~~

类名在class关键字后，紧跟着的大括号中定义类成员

类成员包括构造器、域、方法

## Constructor

构造器与类同名。在创建对应类时，构造器会运行，以将实例域初始化为所希望的状态。

构造器方法一定是`public`的

构造器没有返回值，总是伴随着new操作符的执行被调用

构造器可以有0个、1个或多个参数

每个类可以有一个以上的构造器

* 一个类如果不显示地定义构造方法，编译器会隐式地添加一个空参数的构造方法作为默认构造
* 如果程序员定义了构造方法，编译器就不会提供默认构造；
* 一个类中可以定义多个构造方法，它们之间发生重载现象；

* 构造方法的具体处理过程：

  * 初始化所有域的默认值(0、false或null)
  * 按照在类声明中出现的次序，依次执行所有域初始化语句和初始化块。

  * 执行这个构造器的主体。

## 成员域

又叫属性，是定义在成员位置的（类内部，方法体外）的变量

注意与局部变量（方法体内定义的变量）作区分

## 成员方法

又称为函数，是描述一段功能逻辑代码的，通过方法名对其进行调用执行。

方法由返回值类型、方法签名、方法体构成

方法签名包括方法名和参数列表

* 定义格式：

~~~java
修饰符 返回值类型 方法名(参数类型 参数名，参数类型 参数名...){
    ...
    方法体
    ...
    return 返回值;//如果方法需要返回
}
~~~

方法的返回值类型是void时，也可以有return，此时直接在return后加分号，不写任何数据。此时语句只起到结束方法的作用

不能有两个名字相同、参数类型也相同但返回不同类型值的方法。

### 参数传递

在程序设计语言中将参数传递给方法有如下方式:

* 按值调用/值传递(call by value):表示方法接收的时调用者提供的值
* 按引用调用/引用传递(call by reference):表示方法接收的时调用者提供的变量地址。

一个方法可以修改传递引用所对应的变量值，而不能修改传递值调用所对应的变量值。

Java程序设计语言总是采用按值调用。也就是说，方法得到的时所有参数值的一个拷贝，所以方法不能修改传递给它的任何参数变量的内容。

但是，Java的参数类型有两种:基本数据类型和引用数据类型

显然，方法无法修改传递的变量值(不论是引用数据类型变量和基本数据类型变量)，因为值传递只拷贝了一份变量给方法

但是，如果传递的是引用数据类型的变量，方法可以改变该引用指向的对象的状态，因为Java的引用数据类型变量持有的是对象引用，值传递将对象引用拷贝了一份传递给了方法，方法可以通过拷贝的引用访问同一个对象,以更改对象的状态。

### this

一个成员方法有两类参数，一类是显式参数，在方法声明的参数列表中的参数

还有一类是隐式参数，是出现在方法名前的类对象，也就是持有该方法的对象。

在每一个方法中，用this表示隐式参数,我们可以用它来:

* 区分同名的成员变量和局部变量

* 在本类构造方法之间的相互调用

  ~~~java
  this(形参列表);
  ~~~

  在构造器中，对this的调用必须是第一个语句；(与super()冲突)

### 可变参数

当函数

~~~java
修饰符 返回值类型 方法名(数据类型 ... 变量名){

~~~

* 底层是可变数组，在方法体内用数组接收
* 只能定义在形参列表的最后位置
* 只能有一个；

## 代码块

### 构造代码块

一个类的声明中，可以包含多个构造代码块。只要构造类的对象，这些块就会被执行。

* 定义格式：

  ~~~java
  {
      //...
  }
  ~~~

### 静态代码块

随着类的加载而加载，只会被执行一次；可以初始化静态域、或者加载一些类公用的资源

定义格式：

~~~java
static {
    //..
}
~~~

## 内部类

在一个类的内部定义了一个类

外部的类称为外部类，内部的类称为内部类

在类的内部又有一个独立的内部结构，有必要的话可以将其单独定义一个类（内部类），

内部类需要依赖于外部类，不存在单独定义的情况。

### 分类

从定义位置上划分：

​		成员内部类

​		局部内部类

对成员内部类进行划分：

​		非静态成员内部类

​		静态成员内部类

对局部内部类进行划分：

​		局部内部类：定义在局部位置的有名字的内部类

​		匿名内部类：定义在局部位置的没有名字的内部类

### 匿名内部类

作用、意义：

场景搭建：

~~~java
class A{
    func(){
        //...
    }
}

class B extends A{
    @override
    func(){
        //....
	}
}

main(){
    new B().func();
}
~~~

##### 定义格式：

* 情况一：和父类有关

~~~java
new 父类名(){
    //匿名子类成员的设计
}；
~~~



~~~java
new A(){
    @override
    func(){
        //....
	}
}.func();
~~~



* 情况二 ： 和接口有关

~~~java
new 接口名(){
    //匿名实现类成员的设计
}；
~~~

## 重载

在同一个类中，如果多个方法的有相同的方法名、不同的参数(参数类型不同，参数数量不同，参数类型排序不同)，则发生重载。

调用重载方法时，编译器必须挑选出具体执行哪个方法，它通过使用各个方法给出的参数类型和特定方法调用所使用的值类型进行匹配来挑选出相同的方法。如果编译器找不到匹配的参数，就会产生编译时错误。这个过程被称为重载解析

## 修饰符

### 权限修饰符

在类中通过权限修饰符界定类成员的访问权限，权限修饰符有如下:

| 修饰符    | 本类中 | 同包不同类 | 不同包子父类 | 不同包不同类 |
| --------- | ------ | ---------- | ------------ | ------------ |
| private   | ○      | ×          | ×            | ×            |
| 缺省      | ○      | ○          | ×            | ×            |
| protected | ○      | ○          | ○            | ×            |
| public    | ○      | ○          | ○            | ○            |

### final修饰符

final可以修饰类成员中的成员变量和成员方法，也可以直接修饰类:

* 修饰属性：构建对象时必须初始化这样的域。并且在后续的操作中，不能对它进行修改。
* 修饰成员方法：这样的方法不能被子类重写

*  修饰类： 这样的类不能被其他类继承、没有子类

### static修饰符

static可以修饰除构造器外的其他类成员，被static关键字修饰的类成员称为静态成员。否则称为非静态成员。

静态成员随着类加载而加载。而非静态成员随着对象的加载而加载。.

作为对象的模板，类加载的时机时早于对象加载的，静态成员方法无法访问非静态成员。

在类的外部，类的静态成员可以直接通过类名访问,但无法通过具体的对象访问:

~~~java
public class StaticDemo {

    public static int i = 1;

    public static void print(){
        System.out.println("Hello");
    }
}
~~~

可以通过如下格式访问:

~~~java
StaticDemo.i ++;
StaticDemo.print();
~~~

# Java类管理

## 包

Java允许使用包(package)将类组织起来。借助于包可以方便地组织自己的代码，并将自己的代码于别人提供的代码库分开管理。

使用包的主要原因是确保类名的唯一性。

### 类的导入

一个类可以使用所属包中的所有类，以及其他包中的公共类(public class)。我们可以采用两种方式访问另一个包中的公有类。

一种方式是在每个类名前添加完整的包名：

~~~java
java.util.Random r = new java.util.Random();
~~~

另一种是使用`import`语句导入一个特定的类或者整个包

`import`语句应该位于源文件的顶部、package语句的后面:

~~~java
import java.util.Random; //导入Random类
import java.util.* //导入util包中的所有类
~~~

`import`语句不仅可以导入类，还可以导入静态方法和静态域

~~~java
import java.lang.System.*; //导入System类中所有静态方法和静态域
import java.lang.System.out;//导入特定的静态方法和静态域
~~~

这样就可以直接使用System类的静态方法和静态域，而不必加类名前缀。

java.lang是常用的包，不需要导包就能直接使用

## 类路径

路径就是java编译器或JVM用来定位类的基目录，类路径可以有多个，是一组路径的集合。

类路径所列出来的目录和归档文件是搜索类的起始点。

使用`java -classpath 路径集合`或者`java -cp 路径集合`指定类路径

## 文档注释

JDK提供了工具javadoc，它可以由源文件生成一个HTML文档。

它根据源代码中`/**`开始的注释生成文档

### 注释的插入

javadoc从以下特性中抽取信息:

* 包
* 公共类和接口
* 公共的和受保护的构造器和方法
* 公共的和受保护的域

应该在上面几部分编写注释。注释应该放置在所描述特性的前面

注释以`/**`开始，以`*/`结束

`/** ... */`文档注释中的文本叫自由格式文本。

自由格式文本的第一句应该是一个概要性的句子。javadoc自动地将这些句子抽取出来形成概要页。

自由格式文本可以使用特定的标记如`@author`、`@param`等

自由格式文本可以使用HTML修饰符，例如`<em>`、`<strong>`、`<img>`

### 自由格式文本标记

类标记

* `@author`产生作者条目，可以使用多个`@author`

* `@version`产生版本条目

方法标记

* `@param`描述当前方法的参数
* `@return`描述当前方法的返回值
* `@throws`描述当前方法可能抛出的异常

通用标记

* `@since`产生始于条目
* `@ses`新增一个超链接

### 注释的抽取

可以使用`java -d docDirectory nameOfPackage`命令生成包文档

# Java类的继承

Java中使用关键字`extends`表示类的继承:

~~~java
class SubClass extends SuperClass{
    //...
}
~~~

关键字`extends`表明正在构造的新类派生于一个已存在的类。

这个已存在的类称为超类(superclass)、基类(base class)或父类(parent class)

这个新类称为子类(subclass)、派生类(derived class)或孩子类(child class)

子类将自动得到超类中所有的域和方法，但子类是无法访问超类中的私有域和私有方法的。

注意:Java仅支持单继承

## 覆盖方法

有时候，超类中的某些方法对子类不一定适用，那么子类可以提供一个相同的方法，并重写方法体，以覆盖超类的行为

除了方法体和权限修饰符外，子类的方法各个组成部分必须和超类一样

并且子类方法的访问权限修饰符必须不小于父类方法的权限

子类方法的返回值类型可以定义为原返回类型的子类型

## 子类构造器

可以在子类的构造器中通过super关键字显示地调用超类的构造器。该调用语句必须在子类构造器的第一句。

如果子类的构造器没有显式地调用超类的构造器，那么将自动地调用超类的默认构造器。此时如果超类没有定义默认的无参构造器，那么编译器将报错。所以建议为每个类都定义一个默认的无参构造。

## super

在Java中，使用关键字super调用超类的方法，super和this不一样，不是一个对象的引用，它只是一个指示编译器调用超类方法的特殊关键字

可以用super在子类中调用父类的成员

* 调用父类构造方法`super(...)`


* 调用父类的普通方法`super.method(...)`

## 继承层次

继承并不仅限于一个层次，一个类既可以是某个类的子类，同时也可以是某个类的父类。

由一个公共超类派生出来的所有类的集合被称为继承层次

在继承层次中，从某个特定的类到其祖先的路径被称为该类的继承链

## 多态

### 自动向上转型

在Java程序设计语言中，对象变量(引用变量)是多态的，一个某类型的变量既可以引用一个该类型的对象，也可以引用一个该类型的任意一个子类的对象:

~~~java
SuperClass superClass =  new SubClass();
~~~

这样虽然`superClass`变量类型是`SuperClass`,但它引用的对象的实际类型是`SuperClass`的子类`SubClass`。这被称为自动向上转型。这忽略的对象的实际类型，将对象当成它的某个父类来处理。

这种特性能帮助我们很好的统一处理某一些有相同超类的类型对象，例如:

~~~java
Person[] people = new Person[10];
people[0] = new Student();
~~~

在一个`Person`数组可以存储`Person`的子类类型`Student`的对象，这显然是符合逻辑的。

除此之外可能多态场景有:

### 强制向下转型

但是这种自动的类型转换带来一个问题，一个某类型的变量明明引用的是其子类类型对象，但无法使用该子类类型对象独有的方法。如上例，`person[0]`现在作为`Person`类型的变量，无法使用`Student`独有的方法，尽管`person[0]`确实引用的是`Student`类型对象。

可以使用强制类型转换，和基本数据类型的强制类型转换一样，用一对小括号将目标类名括起来，放到要转换的对象引用之前就可以:

~~~java
Student student = (Student) people[0];
~~~

进行类型转换的唯一原因就是:在暂时忽略对象的实际类型之后，使用对象的全部功能。

如果进行强制类型转换的目标类型不是当前类型的子类，将会有编译时异常。这种错误很明显。

但是如果目标类型虽然是当前类型的子类，但不是实际对象类型的父类，在使用这个对象时将会出现运行时异常:

~~~java
Teacher teacher = (Teacher) people[0];//运行时异常:ClassCastException
~~~

所以在进行类型转换是，最好先检查以下是否能够成功转换，可以使用`instanceof`操作符:

~~~java
if (people[0] instanceof Teacher){
    Teacher teacher = (Teacher) people[0];
    ...
}
~~~

### 方法调用

在多态的环境下，因为无法在编译时确定隐式参数(方法持有的对象)，所以对于一些方法，需要使用动态绑定(后期绑定)

以调用`x.f(param)`(x为类C的一个对象,x的实际类型是D,D为C的子类) 为例，描述方法调用的过程:

* 编译器首先列举所有C类中名为f的方法和其超类中名为f的方法(根据调用位置找到合适访问权限的f方法)

* 编译器查看调用方式时提供的参数类型`param`,如果再所有名为f的方法中存在一个域提供的参数类型完全匹配，就选择这个方法，这个过程称为重载解析(overloading reolution)

  由于允许类型转换，所以这个过程很复杂。如果编译器没有找到于参数类型匹配的方法，或者发现经过类型转换后有多个方法与之匹配，就报告一个错误。

* 如果是private、static、final方法或者构造器，那么编译器编译时就可以准确直到应该调用哪个方法，这类方法采用静态绑定。

  其他方法的调用依赖于隐式参数的实际类型，所以需要在运行时实现动态绑定。

* 当程序运行时，调用方法采用动态绑定的方式，虚拟机一定调用于x所引用对象的实际类型最合适的哪个类的方法。如果D定义的方法有匹配，就直接调用它，否则，将在D类的超类中寻找匹配的方法，依此类推

  每次调用方法都进行搜索的话，时间开销很大。所以虚拟机预先为每个类创建了一个方法表，其中列出了所有方法的签名和实际调用的方法。这样真正调用方法的时候，虚拟机仅查这个表就可以了。

## 抽象类

在自上而下的类的继承层次中，位于上层的类更具有通用性，或者更加抽象。

祖先类更加通用，有时候只将它当作派生其他类的基类，而不作为特定的实例类。

有的时候作为基类的方法是无法确定具体的实现的，必须由具体的派生类来实现，可以用`abstract`修饰成员方法，指示该方法是抽象的，这样就不需要实现这个方法。这种方法被称为抽象方法

有抽象方法的类，也必须用`abstract`关键字修饰，被`abstract`修饰的类被称为抽象类

很显然，抽象方法存在的意义就是被重写，所以抽象方法的权限修饰符不能为private，否则无法重写。

抽象类存在的意义就是被继承，它无法被实例化。但是抽象方法仍然有构造器，以供子类调用

如果继承的子类不是抽象类，需要重写父类，祖先类所有的抽象方法。

# Object类

Object类是Java中所有类的始祖，Java中的每个类都由它扩展而来。

定义类是如果没用关键字`extends`指定类的超类，那么这个类将默认继承自Object类。

所以，熟悉Object类提供的服务十分重要

在Java中，只有基本类型不是对象，其他的所有类型，包括数组类型(不论是对象数组还是基本类型数组)都是对象，都是Object的子类

## equals方法

`Object`类中的equals方法用于检测一个对象是否等于另外一个对象。

~~~java
public boolean equals(Object obj) {
    return (this == obj);
}
~~~

在Object类中，这个方法默认将判断两个对象是否具有相同的引用。

对大多数类来说这种判断并没有意义，因为不同对象的引用本身就是不同的。

检测两个对象状态的相等性显然更有意义，比如两个Person对象的身份证号码属性相等，那么这两个对象就视同相等。

所以一个类常常会覆写该方法，以设计符合该类的相等检测

`equals`在设计的时候，应该参照数学中的`=`关系，具备以下性质:自反性、对称性、传递性

一般情况下，一个设计良好的`equals`方法会先判断如下两条:

* 如果两个对象引用相等，直接返回true
* 用`instanceof`检测obj的类型，如果不是期望的类型(往往是当前类类型，或者对应接口类型)，直接返回false

这两个判断之后，将obj进行强制类型转换，成为instanceof检测的类型，

这时再对需要比较的域进行比较。

















