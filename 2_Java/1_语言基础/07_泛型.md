# 泛型程序设计概述

对于一般的类和方法，只能使用确定的具体的类型。如果要编写可以应用于多种类型的代码，这种限制就会束缚代码。

在面向对象编程语言中，多态算是一种泛化机制。例如可以将方法的参数类型设为其父类类型。这样该方法就可以接受从这个基类中导出的任何类作为参数，这样的方法更加通用一些。

但是拘泥于单继承体系，这样的设计还是受限太多。可以让方法的参数是一个接口，而不是一个类，这种限制就放松了许多，任何实现了改接口的类都可以满足该方法。

可以有时候，即使使用了接口，对程序的约束还是太强了，因为一旦指明了接口，它就要求你的代码必须使用特定的接口。

为了能够编写更通用的代码，需要能使代码应用于“某种不具体的类型”，而不是一个具体的接口和类。

这就是泛型的概念。泛型实现了参数化类型的概念，使代码可以应用于多种类型。在定义接口、类、方法时，对于还不确定的类型(返回值类型，入参类型，成员变量的类型等等)，可以使用类型参数，在实现接口、继承类、创建类、调用方法时，可以指定类型参数具体的类型，最终确定需要的类型。

## 场景引入

有了泛型，首先就能创建更加通用的容器类，而不必为每个类型定义专门的容器，或者是存储了`Object`类型的容器类，这样的容器类在添加元素获取元素时必须小心元素的实际类型，很容易会出现类型转换异常。

比如我们要创建一个持有单个对象的容器类，可以明确指定其持有对象的类型，如:

~~~java
class Element{}

public class Holder1 {
    private Element e ;
    public Holder1(Element e){this.e = e;}
    Element get(){return e;}
}
~~~

不过这个类的可重用性很低，它无法持有其他类型的任何对象。

当然我们可以让这个类持有Object类型的对象。

~~~java
public class Holder2 {
    private Object o;
    public Holder2 (Object o )  { this.o = o;}
    public void set(Object o ) { this.o = o;}
    public Object get() {return o;}
}
~~~

这样容器就可以存储任意类型的元素，但这衍生处一个问题，如果不清楚最后一次设置元素的元素类型，那么调用`get`方法后，我们就无法得知获取到的对象的真正类型，也就无法进行正确的强制类型转换和使用它了。

我们可以用泛型来解决这个问题，泛型的主要目的之一就是用来指定容器要持有什么类型的对象，而且由编译器来保证类型的正确性

与其使用`Object`，我们可以使用泛型暂时不指定类型，而是在创建容器对象时，再决定使用什么类型:

~~~java
public class Holder3<T>{
    private T e;
    public Holder3(T e){this.e = e;}
    public void set(T e){this.e = e;}
    public T get(){return e;}
}
~~~

在类名后紧跟着`<T>`表示类型参数T,在声明这样带有类型参数的类时，必须同时指定`T`的具体类型:

~~~java
Holder3<String> h1 = new Holder3<String>("123");
Holder3<Integer> h2 = new Holder3<Integer>(1);
~~~

h1对象在创建时指定T为`String`，那么该对象中所有的`T`都将被替换为`String`，这样`h1`， 的`set`方法和构造方法的入参类型和`get()`方法的返回值类型就是`String`了。这样从`Holder3`中取出对象，自然就知道它的具体类型了。

这样，我们在真正创建`Holder3`对象实例时，才确定了这个对象要存储的类型。这样，通过泛型我们通过一个类`Holder3`，根据需要能够获得存储不同类型的`Holder3`对象实例了。

# 使用泛型

用尖括号`<>`来定义类型参数，在`<>`中可以定义一个或者多个类型参数，如`<T,E,V>`

类型变量使用大写形式，并且比较短，在`Java`库中，使用变量`E`表示集合的元素类型，`K`和`V`表示关键字和值的类型`T`（或者`U`,`S`等）表示任意类型

用具体的类型替换类型变量就可以实例化泛型类型

## 泛型类

泛型类就是有类型参数的类， 在类定义的类名后紧跟着`<...>`定义这个类的类型参数:

~~~java
class ClassName<R,T,...>{
	//类定义中的类型变量指定方法的返回类型以及域和局部变量的类型
    private T t;
    public T test(T t){
        T inner = t;
        return inner;
    }
}
~~~

当然接口也可以有类型参数，成为泛型接口

### 实例化泛型类

在实例化泛型类时，必须指定所有的参数类型:

~~~java
ArrayList<String> strings = new ArrayList<String>();
~~~

如果能够推导出实例化的泛型类型，这种指定可以省略，但需要保留`<>`：

~~~java
ArrayList<String> strings = new ArrayList<String>();
~~~

### 泛型类的继承

在继承泛型类或者实现泛型接口时，需要为父类、父接口的类型参数指定具体的值，否则类型参数将被指定为`Object` 

```java
public class Super <K,V>{
    private K key;
    private V value;
    public Super(K key,V value){
        this.key = key;
        this.value = value;
    }

    public K getKey(){return key;}
    public V getValue(){return value;}
}
```

继承时可以指定所有的类型参数，这样子类就不是泛型类:

~~~java
class Sub extends Super<String,String>{
    public Sub(String key, String value) {
        super(key, value);
    }
}
~~~

如果继承的子类仍然无法确定类型参数的具体类型，那么可以再次声明子类类型参数，将子类的参数类型赋值给父类的参数类型

~~~java
class Sub<K,V> extends Super<K,V>{
    public Sub(K key, V value) {
        super(key, value);
    }
}
~~~

也可以将父类的一部分类型参数指定为具体类型，一部分类型参数指定为子类的类型参数:

~~~java
class Sub<V> extends Super<String,V>{
    public Sub(String key, V value) {
        super(key, value);
    }
}
~~~

这样`Sub`就是只有一个类型参数的泛型类。

## 泛型方法

可以为单独的方法定义类型参数，这样的方法叫做泛型方法。泛型方法所在的类可以是泛型类，也可以不是泛型类。

如果使用泛型方法就可以解决的问题，最好就不要使用泛型类。

在方法的修饰符和返回值之间定义类型参数

如定义一个静态泛型方法:

~~~java
public static<T> T test(T t){
    System.out.println("这个方法没有意义");
    return t;
}
~~~

类型变量指定方法的返回类型以及参数类型。

调用方法时指定类型参数:

~~~java
App.<String>test("123");
~~~

如果可以推导出泛型方法的具体类型参数值，那么调用时可以省略`<>`:

~~~java
App.test("123"); //由入参可以推导出该方法的泛型是String
~~~

## 类型变量的限定

有的时候，类和方法需要对类型参数加以约束，否则，在定义的泛型类和泛型方法内部，我们只能认为泛型对象为`Object`类型的，无法对其进行其他操作。如在一个需要比较大小逻辑的泛型方法中，我们至少希望泛型能有`compareTo`这样的方法。

可以通过`extends`关键字限定类型参数的范围，指示类型参数指示的类型必须是指定类型的子类:

`<T extends SuperClass>`，表示T应该绑定 限定类型`SuperClass`的子类型，T和限定类型可以是接口也可以是类。`SuperClass`也可以叫类型参数`T`的泛型上界

例如：

~~~java
public static<T extends Comparable<T>> T min(T[] a){
    if(a == null || a.length ==0 ) return null;
    T smallest = a[0];
    for (int i = 1; i < a.length; i++) {
        if(smallest.compareTo(a[i]) > 0)
            smallest = a[i];
    }
    return smallest;
}
~~~

在一个返回最小值的泛型方法中，我们至少希望传入的数组中的对象`T`是可比较的，所以可以限定`T`为`Comparable<T>`的实现类，这样就可以在方法中完成比较,调用`comparaTo`方法。以完成方法的功能。

可能会说这里直接将方法入参定义为`Compareable[]`会更方便，但这样返回值也只能是`Compareable`类型，丢失了其真正的类型信息。 调用者还需要再将返回值进行强制类型转换。

这也是使用泛型的一个重要作用，避免向上转型丢失类型信息。

一个类型参数或通配符可以有多个限定，如：

~~~java
<T extends Comparable & Serializable>
~~~







# 通配符